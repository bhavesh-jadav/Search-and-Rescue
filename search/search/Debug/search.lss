
search.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800200  0000311c  000031b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000311c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000004a2  00800216  00800216  000031c6  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  000031c8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  000065c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00006f70  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002ab3  00000000  00000000  00007030  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000456  00000000  00000000  00009ae3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000cd2  00000000  00000000  00009f39  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009ac  00000000  00000000  0000ac0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000989  00000000  00000000  0000b5b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002967  00000000  00000000  0000bf41  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000170  00000000  00000000  0000e8a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d6 04 	jmp	0x9ac	; 0x9ac <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 b1 04 	jmp	0x962	; 0x962 <__vector_5>
      18:	0c 94 d3 03 	jmp	0x7a6	; 0x7a6 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 f8 03 	jmp	0x7f0	; 0x7f0 <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <__vector_25+0x170>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ec e1       	ldi	r30, 0x1C	; 28
     17e:	f1 e3       	ldi	r31, 0x31	; 49
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a6 31       	cpi	r26, 0x16	; 22
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	16 e0       	ldi	r17, 0x06	; 6
     192:	a6 e1       	ldi	r26, 0x16	; 22
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a8 3b       	cpi	r26, 0xB8	; 184
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 47 14 	call	0x288e	; 0x288e <main>
     1a4:	0c 94 8c 18 	jmp	0x3118	; 0x3118 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	01 97       	sbiw	r24, 0x01	; 1
     1b2:	f1 f7       	brne	.-4      	; 0x1b0 <lcd_set_4bit+0x4>
     1b4:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	80 e3       	ldi	r24, 0x30	; 48
     1bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	ef ef       	ldi	r30, 0xFF	; 255
     1c2:	f7 e4       	ldi	r31, 0x47	; 71
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	f1 f7       	brne	.-4      	; 0x1c4 <lcd_set_4bit+0x18>
     1c8:	00 c0       	rjmp	.+0      	; 0x1ca <lcd_set_4bit+0x1e>
     1ca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1cc:	42 98       	cbi	0x08, 2	; 8
     1ce:	e6 e6       	ldi	r30, 0x66	; 102
     1d0:	fe e0       	ldi	r31, 0x0E	; 14
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <lcd_set_4bit+0x26>
     1d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1de:	42 9a       	sbi	0x08, 2	; 8
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f7 e4       	ldi	r31, 0x47	; 71
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_set_4bit+0x38>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <lcd_set_4bit+0x3e>
     1ea:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ec:	42 98       	cbi	0x08, 2	; 8
     1ee:	e6 e6       	ldi	r30, 0x66	; 102
     1f0:	fe e0       	ldi	r31, 0x0E	; 14
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_set_4bit+0x46>
     1f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1fe:	42 9a       	sbi	0x08, 2	; 8
     200:	8f ef       	ldi	r24, 0xFF	; 255
     202:	97 e4       	ldi	r25, 0x47	; 71
     204:	01 97       	sbiw	r24, 0x01	; 1
     206:	f1 f7       	brne	.-4      	; 0x204 <lcd_set_4bit+0x58>
     208:	00 c0       	rjmp	.+0      	; 0x20a <lcd_set_4bit+0x5e>
     20a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8
     20e:	e6 e6       	ldi	r30, 0x66	; 102
     210:	fe e0       	ldi	r31, 0x0E	; 14
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	f1 f7       	brne	.-4      	; 0x212 <lcd_set_4bit+0x66>
     216:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     218:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     21c:	80 e2       	ldi	r24, 0x20	; 32
     21e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     220:	42 9a       	sbi	0x08, 2	; 8
     222:	8f ef       	ldi	r24, 0xFF	; 255
     224:	97 e4       	ldi	r25, 0x47	; 71
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <lcd_set_4bit+0x7a>
     22a:	00 c0       	rjmp	.+0      	; 0x22c <lcd_set_4bit+0x80>
     22c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     22e:	42 98       	cbi	0x08, 2	; 8

	
}
     230:	08 95       	ret

00000232 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     238:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     23a:	28 2f       	mov	r18, r24
     23c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     23e:	92 2b       	or	r25, r18
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	ef ef       	ldi	r30, 0xFF	; 255
     24a:	f7 e4       	ldi	r31, 0x47	; 71
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	f1 f7       	brne	.-4      	; 0x24c <lcd_wr_command+0x1a>
     250:	00 c0       	rjmp	.+0      	; 0x252 <lcd_wr_command+0x20>
     252:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     254:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     256:	98 b1       	in	r25, 0x08	; 8
     258:	9f 70       	andi	r25, 0x0F	; 15
     25a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     25c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     25e:	82 95       	swap	r24
     260:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     262:	89 2b       	or	r24, r25
     264:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     266:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     268:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     26a:	42 9a       	sbi	0x08, 2	; 8
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	97 e4       	ldi	r25, 0x47	; 71
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	f1 f7       	brne	.-4      	; 0x270 <lcd_wr_command+0x3e>
     274:	00 c0       	rjmp	.+0      	; 0x276 <lcd_wr_command+0x44>
     276:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     278:	42 98       	cbi	0x08, 2	; 8
}
     27a:	08 95       	ret

0000027c <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     27c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
     280:	86 e6       	ldi	r24, 0x66	; 102
     282:	9e e0       	ldi	r25, 0x0E	; 14
     284:	01 97       	sbiw	r24, 0x01	; 1
     286:	f1 f7       	brne	.-4      	; 0x284 <lcd_init+0x8>
     288:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     28a:	88 e2       	ldi	r24, 0x28	; 40
     28c:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x01);
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x06);
     296:	86 e0       	ldi	r24, 0x06	; 6
     298:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x0E);
     29c:	8e e0       	ldi	r24, 0x0E	; 14
     29e:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x80);
     2a2:	80 e8       	ldi	r24, 0x80	; 128
     2a4:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
		
}
     2a8:	08 95       	ret

000002aa <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     2aa:	98 b1       	in	r25, 0x08	; 8
     2ac:	9f 70       	andi	r25, 0x0F	; 15
     2ae:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2b0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     2b2:	28 2f       	mov	r18, r24
     2b4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2b6:	92 2b       	or	r25, r18
     2b8:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     2ba:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2bc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2be:	42 9a       	sbi	0x08, 2	; 8
     2c0:	ef ef       	ldi	r30, 0xFF	; 255
     2c2:	f7 e4       	ldi	r31, 0x47	; 71
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <lcd_wr_char+0x1a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <lcd_wr_char+0x20>
     2ca:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2cc:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2ce:	98 b1       	in	r25, 0x08	; 8
     2d0:	9f 70       	andi	r25, 0x0F	; 15
     2d2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2d4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2d6:	82 95       	swap	r24
     2d8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2da:	89 2b       	or	r24, r25
     2dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2de:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2e0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2e2:	42 9a       	sbi	0x08, 2	; 8
     2e4:	8f ef       	ldi	r24, 0xFF	; 255
     2e6:	97 e4       	ldi	r25, 0x47	; 71
     2e8:	01 97       	sbiw	r24, 0x01	; 1
     2ea:	f1 f7       	brne	.-4      	; 0x2e8 <lcd_wr_char+0x3e>
     2ec:	00 c0       	rjmp	.+0      	; 0x2ee <lcd_wr_char+0x44>
     2ee:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2f0:	42 98       	cbi	0x08, 2	; 8
}
     2f2:	08 95       	ret

000002f4 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2f4:	80 e8       	ldi	r24, 0x80	; 128
     2f6:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
}
     2fa:	08 95       	ret

000002fc <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	ec 01       	movw	r28, r24
	while(*str != '\0')
     302:	88 81       	ld	r24, Y
     304:	88 23       	and	r24, r24
     306:	31 f0       	breq	.+12     	; 0x314 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     308:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     30a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     30e:	89 91       	ld	r24, Y+
     310:	88 23       	and	r24, r24
     312:	d9 f7       	brne	.-10     	; 0x30a <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	08 95       	ret

0000031a <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     31a:	82 30       	cpi	r24, 0x02	; 2
     31c:	79 f0       	breq	.+30     	; 0x33c <lcd_cursor+0x22>
     31e:	83 30       	cpi	r24, 0x03	; 3
     320:	18 f4       	brcc	.+6      	; 0x328 <lcd_cursor+0xe>
     322:	81 30       	cpi	r24, 0x01	; 1
     324:	c9 f4       	brne	.+50     	; 0x358 <lcd_cursor+0x3e>
     326:	05 c0       	rjmp	.+10     	; 0x332 <lcd_cursor+0x18>
     328:	83 30       	cpi	r24, 0x03	; 3
     32a:	69 f0       	breq	.+26     	; 0x346 <lcd_cursor+0x2c>
     32c:	84 30       	cpi	r24, 0x04	; 4
     32e:	a1 f4       	brne	.+40     	; 0x358 <lcd_cursor+0x3e>
     330:	0f c0       	rjmp	.+30     	; 0x350 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     332:	86 2f       	mov	r24, r22
     334:	81 58       	subi	r24, 0x81	; 129
     336:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     33a:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     33c:	86 2f       	mov	r24, r22
     33e:	81 54       	subi	r24, 0x41	; 65
     340:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     344:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     346:	86 2f       	mov	r24, r22
     348:	8d 56       	subi	r24, 0x6D	; 109
     34a:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     34e:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     350:	86 2f       	mov	r24, r22
     352:	8d 52       	subi	r24, 0x2D	; 45
     354:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     358:	08 95       	ret

0000035a <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     35a:	0f 93       	push	r16
     35c:	1f 93       	push	r17
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	8a 01       	movw	r16, r20
     364:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     366:	88 23       	and	r24, r24
     368:	11 f0       	breq	.+4      	; 0x36e <lcd_print+0x14>
     36a:	66 23       	and	r22, r22
     36c:	19 f4       	brne	.+6      	; 0x374 <lcd_print+0x1a>
	{
		lcd_home();
     36e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <lcd_home>
     372:	02 c0       	rjmp	.+4      	; 0x378 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     374:	0e 94 8d 01 	call	0x31a	; 0x31a <lcd_cursor>
	}
	if(digits==5 || flag==1)
     378:	c5 30       	cpi	r28, 0x05	; 5
     37a:	d1 05       	cpc	r29, r1
     37c:	71 f4       	brne	.+28     	; 0x39a <lcd_print+0x40>
	{
		million=value/10000+48;
     37e:	c8 01       	movw	r24, r16
     380:	60 e1       	ldi	r22, 0x10	; 16
     382:	77 e2       	ldi	r23, 0x27	; 39
     384:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     388:	cb 01       	movw	r24, r22
     38a:	c0 96       	adiw	r24, 0x30	; 48
     38c:	90 93 a2 06 	sts	0x06A2, r25
     390:	80 93 a1 06 	sts	0x06A1, r24
		lcd_wr_char(million);
     394:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
     398:	03 c0       	rjmp	.+6      	; 0x3a0 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     39a:	c4 30       	cpi	r28, 0x04	; 4
     39c:	d1 05       	cpc	r29, r1
     39e:	b9 f4       	brne	.+46     	; 0x3ce <lcd_print+0x74>
	{
		temp = value/1000;
     3a0:	c8 01       	movw	r24, r16
     3a2:	68 ee       	ldi	r22, 0xE8	; 232
     3a4:	73 e0       	ldi	r23, 0x03	; 3
     3a6:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     3aa:	cb 01       	movw	r24, r22
     3ac:	70 93 a4 06 	sts	0x06A4, r23
     3b0:	60 93 a3 06 	sts	0x06A3, r22
		thousand = temp%10 + 48;
     3b4:	6a e0       	ldi	r22, 0x0A	; 10
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     3bc:	c0 96       	adiw	r24, 0x30	; 48
     3be:	90 93 b7 06 	sts	0x06B7, r25
     3c2:	80 93 b6 06 	sts	0x06B6, r24
		lcd_wr_char(thousand);
     3c6:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3ce:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3d0:	c3 30       	cpi	r28, 0x03	; 3
     3d2:	d1 05       	cpc	r29, r1
     3d4:	11 f0       	breq	.+4      	; 0x3da <lcd_print+0x80>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	b1 f4       	brne	.+44     	; 0x406 <lcd_print+0xac>
	{
		temp = value/100;
     3da:	c8 01       	movw	r24, r16
     3dc:	64 e6       	ldi	r22, 0x64	; 100
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     3e4:	cb 01       	movw	r24, r22
     3e6:	70 93 a4 06 	sts	0x06A4, r23
     3ea:	60 93 a3 06 	sts	0x06A3, r22
		hundred = temp%10 + 48;
     3ee:	6a e0       	ldi	r22, 0x0A	; 10
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     3f6:	c0 96       	adiw	r24, 0x30	; 48
     3f8:	90 93 b1 06 	sts	0x06B1, r25
     3fc:	80 93 b0 06 	sts	0x06B0, r24
		lcd_wr_char(hundred);
     400:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     404:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     406:	c2 30       	cpi	r28, 0x02	; 2
     408:	d1 05       	cpc	r29, r1
     40a:	11 f0       	breq	.+4      	; 0x410 <lcd_print+0xb6>
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	b1 f4       	brne	.+44     	; 0x43c <lcd_print+0xe2>
	{
		temp = value/10;
     410:	2a e0       	ldi	r18, 0x0A	; 10
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	c8 01       	movw	r24, r16
     416:	b9 01       	movw	r22, r18
     418:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     41c:	cb 01       	movw	r24, r22
     41e:	70 93 a4 06 	sts	0x06A4, r23
     422:	60 93 a3 06 	sts	0x06A3, r22
		tens = temp%10 + 48;
     426:	b9 01       	movw	r22, r18
     428:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     42c:	c0 96       	adiw	r24, 0x30	; 48
     42e:	90 93 af 06 	sts	0x06AF, r25
     432:	80 93 ae 06 	sts	0x06AE, r24
		lcd_wr_char(tens);
     436:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     43a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     43c:	c1 30       	cpi	r28, 0x01	; 1
     43e:	d1 05       	cpc	r29, r1
     440:	11 f0       	breq	.+4      	; 0x446 <lcd_print+0xec>
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	61 f4       	brne	.+24     	; 0x45e <lcd_print+0x104>
	{
		unit = value%10 + 48;
     446:	c8 01       	movw	r24, r16
     448:	6a e0       	ldi	r22, 0x0A	; 10
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 65 18 	call	0x30ca	; 0x30ca <__udivmodhi4>
     450:	c0 96       	adiw	r24, 0x30	; 48
     452:	90 93 b5 06 	sts	0x06B5, r25
     456:	80 93 b4 06 	sts	0x06B4, r24
		lcd_wr_char(unit);
     45a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	if(digits>5)
     45e:	c6 30       	cpi	r28, 0x06	; 6
     460:	d1 05       	cpc	r29, r1
     462:	1c f0       	brlt	.+6      	; 0x46a <lcd_print+0x110>
	{
		lcd_wr_char('E');
     464:	85 e4       	ldi	r24, 0x45	; 69
     466:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	
}
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	08 95       	ret

00000474 <led_port_config>:
void led_port_config()
{
	DDRJ = DDRJ | 0xFF;
     474:	e4 e0       	ldi	r30, 0x04	; 4
     476:	f1 e0       	ldi	r31, 0x01	; 1
     478:	80 81       	ld	r24, Z
     47a:	8f ef       	ldi	r24, 0xFF	; 255
     47c:	80 83       	st	Z, r24
	PORTJ = PORTJ & 0x00;
     47e:	e5 e0       	ldi	r30, 0x05	; 5
     480:	f1 e0       	ldi	r31, 0x01	; 1
     482:	80 81       	ld	r24, Z
     484:	10 82       	st	Z, r1
}
     486:	08 95       	ret

00000488 <red_led>:

void red_led()
{
	PORTJ = 0x40;
     488:	80 e4       	ldi	r24, 0x40	; 64
     48a:	80 93 05 01 	sts	0x0105, r24
}
     48e:	08 95       	ret

00000490 <blue_led>:

void blue_led()
{
	PORTJ = 0x10;
     490:	80 e1       	ldi	r24, 0x10	; 16
     492:	80 93 05 01 	sts	0x0105, r24
}
     496:	08 95       	ret

00000498 <green_led>:

void green_led()
{
	PORTJ = 0x20;
     498:	80 e2       	ldi	r24, 0x20	; 32
     49a:	80 93 05 01 	sts	0x0105, r24
}
     49e:	08 95       	ret

000004a0 <turn_off_led>:

void turn_off_led()
{
	PORTJ = 0x00;
     4a0:	10 92 05 01 	sts	0x0105, r1
     4a4:	08 95       	ret

000004a6 <base_servo_pin_config>:
extern int gripper_pos;

//Configure PORTB 5 pin for servo motor 1 operation
void base_servo_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     4a6:	25 9a       	sbi	0x04, 5	; 4
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     4a8:	2d 9a       	sbi	0x05, 5	; 5
}
     4aa:	08 95       	ret

000004ac <elbow_servo_pin_config>:

//Configure PORTB 6 pin for servo motor 2 operation
void elbow_servo_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     4ac:	26 9a       	sbi	0x04, 6	; 4
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     4ae:	2e 9a       	sbi	0x05, 6	; 5
}
     4b0:	08 95       	ret

000004b2 <gripper_servo_pin_config>:

//Configure PORTB 7 pin for servo motor 3 operation
void gripper_servo_pin_config (void)
{
 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
     4b2:	27 9a       	sbi	0x04, 7	; 4
 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
     4b4:	2f 9a       	sbi	0x05, 7	; 5
}
     4b6:	08 95       	ret

000004b8 <timer1_init>:
//pre-scale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     4b8:	e1 e8       	ldi	r30, 0x81	; 129
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     4be:	8c ef       	ldi	r24, 0xFC	; 252
     4c0:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     4ca:	93 e0       	ldi	r25, 0x03	; 3
     4cc:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     4d0:	8f ef       	ldi	r24, 0xFF	; 255
     4d2:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     4d6:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     4da:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     4de:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     4e2:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     4e6:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     4ea:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     4ee:	8b ea       	ldi	r24, 0xAB	; 171
     4f0:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     4f4:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     4f8:	8c e0       	ldi	r24, 0x0C	; 12
     4fa:	80 83       	st	Z, r24
}
     4fc:	08 95       	ret

000004fe <base_servo>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void base_servo(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
     4fe:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void base_servo(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
     502:	68 2f       	mov	r22, r24
     504:	70 e0       	ldi	r23, 0x00	; 0
     506:	80 e0       	ldi	r24, 0x00	; 0
     508:	90 e0       	ldi	r25, 0x00	; 0
     50a:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     50e:	2b e7       	ldi	r18, 0x7B	; 123
     510:	34 e1       	ldi	r19, 0x14	; 20
     512:	4e ee       	ldi	r20, 0xEE	; 238
     514:	5f e3       	ldi	r21, 0x3F	; 63
     516:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
     51a:	20 e0       	ldi	r18, 0x00	; 0
     51c:	30 e0       	ldi	r19, 0x00	; 0
     51e:	4c e0       	ldi	r20, 0x0C	; 12
     520:	52 e4       	ldi	r21, 0x42	; 66
     522:	0e 94 12 15 	call	0x2a24	; 0x2a24 <__addsf3>
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
     526:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__fixunssfsi>
     52a:	60 93 88 00 	sts	0x0088, r22
}
     52e:	08 95       	ret

00000530 <elbow_servo>:
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void elbow_servo(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR1BH = 0x00;
     530:	10 92 8b 00 	sts	0x008B, r1

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void elbow_servo(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
     534:	68 2f       	mov	r22, r24
     536:	70 e0       	ldi	r23, 0x00	; 0
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     540:	2b e7       	ldi	r18, 0x7B	; 123
     542:	34 e1       	ldi	r19, 0x14	; 20
     544:	4e ee       	ldi	r20, 0xEE	; 238
     546:	5f e3       	ldi	r21, 0x3F	; 63
     548:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
     54c:	20 e0       	ldi	r18, 0x00	; 0
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	4c e0       	ldi	r20, 0x0C	; 12
     552:	52 e4       	ldi	r21, 0x42	; 66
     554:	0e 94 12 15 	call	0x2a24	; 0x2a24 <__addsf3>
 OCR1BH = 0x00;
 OCR1BL = (unsigned char) PositionTiltServo;
     558:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__fixunssfsi>
     55c:	60 93 8a 00 	sts	0x008A, r22
}
     560:	08 95       	ret

00000562 <gripper_servo>:
//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void gripper_servo(unsigned char degrees)
{
 float PositionServo = 0;
 PositionServo = ((float)degrees / 1.86) + 35.0;
 OCR1CH = 0x00;
     562:	10 92 8d 00 	sts	0x008D, r1

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void gripper_servo(unsigned char degrees)
{
 float PositionServo = 0;
 PositionServo = ((float)degrees / 1.86) + 35.0;
     566:	68 2f       	mov	r22, r24
     568:	70 e0       	ldi	r23, 0x00	; 0
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     572:	2b e7       	ldi	r18, 0x7B	; 123
     574:	34 e1       	ldi	r19, 0x14	; 20
     576:	4e ee       	ldi	r20, 0xEE	; 238
     578:	5f e3       	ldi	r21, 0x3F	; 63
     57a:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
     57e:	20 e0       	ldi	r18, 0x00	; 0
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	4c e0       	ldi	r20, 0x0C	; 12
     584:	52 e4       	ldi	r21, 0x42	; 66
     586:	0e 94 12 15 	call	0x2a24	; 0x2a24 <__addsf3>
 OCR1CH = 0x00;
 OCR1CL = (unsigned char) PositionServo;
     58a:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__fixunssfsi>
     58e:	60 93 8c 00 	sts	0x008C, r22
}
     592:	08 95       	ret

00000594 <servo_base_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to 
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_base_free (void) //makes servo 1 free rotating
{
 OCR1AH = 0x03; 
     594:	83 e0       	ldi	r24, 0x03	; 3
     596:	80 93 89 00 	sts	0x0089, r24
 OCR1AL = 0xFF; //Servo 1 off
     59a:	8f ef       	ldi	r24, 0xFF	; 255
     59c:	80 93 88 00 	sts	0x0088, r24
}
     5a0:	08 95       	ret

000005a2 <servo_elbow_free>:

void servo_elbow_free (void) //makes servo 2 free rotating
{
 OCR1BH = 0x03;
     5a2:	83 e0       	ldi	r24, 0x03	; 3
     5a4:	80 93 8b 00 	sts	0x008B, r24
 OCR1BL = 0xFF; //Servo 2 off
     5a8:	8f ef       	ldi	r24, 0xFF	; 255
     5aa:	80 93 8a 00 	sts	0x008A, r24
}
     5ae:	08 95       	ret

000005b0 <servo_gripper_free>:

void servo_gripper_free (void) //makes servo 3 free rotating
{
 OCR1CH = 0x03;
     5b0:	83 e0       	ldi	r24, 0x03	; 3
     5b2:	80 93 8d 00 	sts	0x008D, r24
 OCR1CL = 0xFF; //Servo 3 off
     5b6:	8f ef       	ldi	r24, 0xFF	; 255
     5b8:	80 93 8c 00 	sts	0x008C, r24
}
     5bc:	08 95       	ret

000005be <gripper_rotate>:

void gripper_rotate(int deg)
{
     5be:	cf 93       	push	r28
     5c0:	df 93       	push	r29
     5c2:	ec 01       	movw	r28, r24
	
	if(deg < gripper_pos)
     5c4:	80 91 0c 02 	lds	r24, 0x020C
     5c8:	90 91 0d 02 	lds	r25, 0x020D
     5cc:	c8 17       	cp	r28, r24
     5ce:	d9 07       	cpc	r29, r25
     5d0:	ac f4       	brge	.+42     	; 0x5fc <gripper_rotate+0x3e>
	{
		while(gripper_pos != deg)
		{
			gripper_servo(gripper_pos);
     5d2:	0e 94 b1 02 	call	0x562	; 0x562 <gripper_servo>
			gripper_pos--;
     5d6:	80 91 0c 02 	lds	r24, 0x020C
     5da:	90 91 0d 02 	lds	r25, 0x020D
     5de:	01 97       	sbiw	r24, 0x01	; 1
     5e0:	90 93 0d 02 	sts	0x020D, r25
     5e4:	80 93 0c 02 	sts	0x020C, r24
     5e8:	ef ef       	ldi	r30, 0xFF	; 255
     5ea:	ff e8       	ldi	r31, 0x8F	; 143
     5ec:	31 97       	sbiw	r30, 0x01	; 1
     5ee:	f1 f7       	brne	.-4      	; 0x5ec <gripper_rotate+0x2e>
     5f0:	00 c0       	rjmp	.+0      	; 0x5f2 <gripper_rotate+0x34>
     5f2:	00 00       	nop
void gripper_rotate(int deg)
{
	
	if(deg < gripper_pos)
	{
		while(gripper_pos != deg)
     5f4:	8c 17       	cp	r24, r28
     5f6:	9d 07       	cpc	r25, r29
     5f8:	61 f7       	brne	.-40     	; 0x5d2 <gripper_rotate+0x14>
     5fa:	17 c0       	rjmp	.+46     	; 0x62a <gripper_rotate+0x6c>
			gripper_pos--;
			_delay_ms(10);
		}
	}
	
	else if(deg > gripper_pos)
     5fc:	8c 17       	cp	r24, r28
     5fe:	9d 07       	cpc	r25, r29
     600:	a4 f4       	brge	.+40     	; 0x62a <gripper_rotate+0x6c>
	{
		while(gripper_pos != deg)
		{
			gripper_servo(gripper_pos);
     602:	0e 94 b1 02 	call	0x562	; 0x562 <gripper_servo>
			gripper_pos++;
     606:	80 91 0c 02 	lds	r24, 0x020C
     60a:	90 91 0d 02 	lds	r25, 0x020D
     60e:	01 96       	adiw	r24, 0x01	; 1
     610:	90 93 0d 02 	sts	0x020D, r25
     614:	80 93 0c 02 	sts	0x020C, r24
     618:	ef ef       	ldi	r30, 0xFF	; 255
     61a:	ff e8       	ldi	r31, 0x8F	; 143
     61c:	31 97       	sbiw	r30, 0x01	; 1
     61e:	f1 f7       	brne	.-4      	; 0x61c <gripper_rotate+0x5e>
     620:	00 c0       	rjmp	.+0      	; 0x622 <gripper_rotate+0x64>
     622:	00 00       	nop
		}
	}
	
	else if(deg > gripper_pos)
	{
		while(gripper_pos != deg)
     624:	8c 17       	cp	r24, r28
     626:	9d 07       	cpc	r25, r29
     628:	61 f7       	brne	.-40     	; 0x602 <gripper_rotate+0x44>
			gripper_servo(gripper_pos);
			gripper_pos++;
			_delay_ms(10);
		}			
	}
}
     62a:	df 91       	pop	r29
     62c:	cf 91       	pop	r28
     62e:	08 95       	ret

00000630 <elbow_rotate>:

void elbow_rotate(int deg)
{
     630:	cf 93       	push	r28
     632:	df 93       	push	r29
     634:	ec 01       	movw	r28, r24
	
	if(deg < elbow_pos)
     636:	80 91 93 06 	lds	r24, 0x0693
     63a:	90 91 94 06 	lds	r25, 0x0694
     63e:	c8 17       	cp	r28, r24
     640:	d9 07       	cpc	r29, r25
     642:	ac f4       	brge	.+42     	; 0x66e <elbow_rotate+0x3e>
	{
		while(elbow_pos != deg)
		{
			elbow_servo(elbow_pos);
     644:	0e 94 98 02 	call	0x530	; 0x530 <elbow_servo>
			elbow_pos--;
     648:	80 91 93 06 	lds	r24, 0x0693
     64c:	90 91 94 06 	lds	r25, 0x0694
     650:	01 97       	sbiw	r24, 0x01	; 1
     652:	90 93 94 06 	sts	0x0694, r25
     656:	80 93 93 06 	sts	0x0693, r24
     65a:	ec ec       	ldi	r30, 0xCC	; 204
     65c:	f4 e6       	ldi	r31, 0x64	; 100
     65e:	31 97       	sbiw	r30, 0x01	; 1
     660:	f1 f7       	brne	.-4      	; 0x65e <elbow_rotate+0x2e>
     662:	00 c0       	rjmp	.+0      	; 0x664 <elbow_rotate+0x34>
     664:	00 00       	nop
void elbow_rotate(int deg)
{
	
	if(deg < elbow_pos)
	{
		while(elbow_pos != deg)
     666:	8c 17       	cp	r24, r28
     668:	9d 07       	cpc	r25, r29
     66a:	61 f7       	brne	.-40     	; 0x644 <elbow_rotate+0x14>
     66c:	17 c0       	rjmp	.+46     	; 0x69c <elbow_rotate+0x6c>
			elbow_pos--;
			_delay_ms(7);
		}
	}
	
	else if(deg > elbow_pos)
     66e:	8c 17       	cp	r24, r28
     670:	9d 07       	cpc	r25, r29
     672:	a4 f4       	brge	.+40     	; 0x69c <elbow_rotate+0x6c>
	{
		while(elbow_pos != deg)
		{
			elbow_servo(elbow_pos);
     674:	0e 94 98 02 	call	0x530	; 0x530 <elbow_servo>
			elbow_pos++;
     678:	80 91 93 06 	lds	r24, 0x0693
     67c:	90 91 94 06 	lds	r25, 0x0694
     680:	01 96       	adiw	r24, 0x01	; 1
     682:	90 93 94 06 	sts	0x0694, r25
     686:	80 93 93 06 	sts	0x0693, r24
     68a:	ec ec       	ldi	r30, 0xCC	; 204
     68c:	f4 e6       	ldi	r31, 0x64	; 100
     68e:	31 97       	sbiw	r30, 0x01	; 1
     690:	f1 f7       	brne	.-4      	; 0x68e <elbow_rotate+0x5e>
     692:	00 c0       	rjmp	.+0      	; 0x694 <elbow_rotate+0x64>
     694:	00 00       	nop
		}
	}
	
	else if(deg > elbow_pos)
	{
		while(elbow_pos != deg)
     696:	8c 17       	cp	r24, r28
     698:	9d 07       	cpc	r25, r29
     69a:	61 f7       	brne	.-40     	; 0x674 <elbow_rotate+0x44>
			elbow_servo(elbow_pos);
			elbow_pos++;
			_delay_ms(7);
		}			
	}
}
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	08 95       	ret

000006a2 <base_rotate>:

void base_rotate(int deg)
{
     6a2:	cf 93       	push	r28
     6a4:	df 93       	push	r29
     6a6:	ec 01       	movw	r28, r24
	
	if(deg < base_pos)
     6a8:	80 91 0e 02 	lds	r24, 0x020E
     6ac:	90 91 0f 02 	lds	r25, 0x020F
     6b0:	c8 17       	cp	r28, r24
     6b2:	d9 07       	cpc	r29, r25
     6b4:	ac f4       	brge	.+42     	; 0x6e0 <base_rotate+0x3e>
	{
		while(base_pos != deg)
		{
			base_servo(base_pos);
     6b6:	0e 94 7f 02 	call	0x4fe	; 0x4fe <base_servo>
			base_pos--;			
     6ba:	80 91 0e 02 	lds	r24, 0x020E
     6be:	90 91 0f 02 	lds	r25, 0x020F
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	90 93 0f 02 	sts	0x020F, r25
     6c8:	80 93 0e 02 	sts	0x020E, r24
     6cc:	ec ec       	ldi	r30, 0xCC	; 204
     6ce:	f4 e6       	ldi	r31, 0x64	; 100
     6d0:	31 97       	sbiw	r30, 0x01	; 1
     6d2:	f1 f7       	brne	.-4      	; 0x6d0 <base_rotate+0x2e>
     6d4:	00 c0       	rjmp	.+0      	; 0x6d6 <base_rotate+0x34>
     6d6:	00 00       	nop
void base_rotate(int deg)
{
	
	if(deg < base_pos)
	{
		while(base_pos != deg)
     6d8:	8c 17       	cp	r24, r28
     6da:	9d 07       	cpc	r25, r29
     6dc:	61 f7       	brne	.-40     	; 0x6b6 <base_rotate+0x14>
     6de:	17 c0       	rjmp	.+46     	; 0x70e <base_rotate+0x6c>
			base_pos--;			
			_delay_ms(7);
		}
	}
	
	else if(deg > base_pos)
     6e0:	8c 17       	cp	r24, r28
     6e2:	9d 07       	cpc	r25, r29
     6e4:	a4 f4       	brge	.+40     	; 0x70e <base_rotate+0x6c>
	{
		while(base_pos != deg)
		{
			base_servo(base_pos);
     6e6:	0e 94 7f 02 	call	0x4fe	; 0x4fe <base_servo>
			base_pos++;		
     6ea:	80 91 0e 02 	lds	r24, 0x020E
     6ee:	90 91 0f 02 	lds	r25, 0x020F
     6f2:	01 96       	adiw	r24, 0x01	; 1
     6f4:	90 93 0f 02 	sts	0x020F, r25
     6f8:	80 93 0e 02 	sts	0x020E, r24
     6fc:	ec ec       	ldi	r30, 0xCC	; 204
     6fe:	f4 e6       	ldi	r31, 0x64	; 100
     700:	31 97       	sbiw	r30, 0x01	; 1
     702:	f1 f7       	brne	.-4      	; 0x700 <base_rotate+0x5e>
     704:	00 c0       	rjmp	.+0      	; 0x706 <base_rotate+0x64>
     706:	00 00       	nop
		}
	}
	
	else if(deg > base_pos)
	{
		while(base_pos != deg)
     708:	8c 17       	cp	r24, r28
     70a:	9d 07       	cpc	r25, r29
     70c:	61 f7       	brne	.-40     	; 0x6e6 <base_rotate+0x44>
			base_servo(base_pos);
			base_pos++;		
			_delay_ms(7);
		}
	}
} 
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	08 95       	ret

00000714 <color_sensor_pin_interrupt_init>:
void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     714:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     716:	e9 e6       	ldi	r30, 0x69	; 105
     718:	f0 e0       	ldi	r31, 0x00	; 0
     71a:	80 81       	ld	r24, Z
     71c:	82 60       	ori	r24, 0x02	; 2
     71e:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     720:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
     722:	78 94       	sei
}
     724:	08 95       	ret

00000726 <color_sensor_pin_config>:

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
     726:	8a b1       	in	r24, 0x0a	; 10
     728:	8e 6f       	ori	r24, 0xFE	; 254
     72a:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
     72c:	58 9a       	sbi	0x0b, 0	; 11
}
     72e:	08 95       	ret

00000730 <color_sensor_scaling>:

void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from data sheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
     730:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     732:	5d 9a       	sbi	0x0b, 5	; 11
}
     734:	08 95       	ret

00000736 <filter_red>:

void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     736:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     738:	5f 98       	cbi	0x0b, 7	; 11
}
     73a:	08 95       	ret

0000073c <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     73c:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     73e:	5f 9a       	sbi	0x0b, 7	; 11
}
     740:	08 95       	ret

00000742 <turn_on_color_sensor>:

void turn_on_color_sensor()
{
	PORTJ =PORTJ | 0x04;
     742:	e5 e0       	ldi	r30, 0x05	; 5
     744:	f1 e0       	ldi	r31, 0x01	; 1
     746:	80 81       	ld	r24, Z
     748:	84 60       	ori	r24, 0x04	; 4
     74a:	80 83       	st	Z, r24
}
     74c:	08 95       	ret

0000074e <turn_off_color_sensor>:

void turn_off_color_sensor()
{
	PORTJ = 0x00;
     74e:	10 92 05 01 	sts	0x0105, r1
     752:	08 95       	ret

00000754 <motion_pin_config>:
};

//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     754:	81 b1       	in	r24, 0x01	; 1
     756:	8f 60       	ori	r24, 0x0F	; 15
     758:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     75a:	82 b1       	in	r24, 0x02	; 2
     75c:	80 7f       	andi	r24, 0xF0	; 240
     75e:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     760:	ea e0       	ldi	r30, 0x0A	; 10
     762:	f1 e0       	ldi	r31, 0x01	; 1
     764:	80 81       	ld	r24, Z
     766:	88 61       	ori	r24, 0x18	; 24
     768:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     76a:	eb e0       	ldi	r30, 0x0B	; 11
     76c:	f1 e0       	ldi	r31, 0x01	; 1
     76e:	80 81       	ld	r24, Z
     770:	88 61       	ori	r24, 0x18	; 24
     772:	80 83       	st	Z, r24
}
     774:	08 95       	ret

00000776 <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     776:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     778:	74 9a       	sbi	0x0e, 4	; 14
}
     77a:	08 95       	ret

0000077c <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     77c:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     77e:	75 9a       	sbi	0x0e, 5	; 14
}
     780:	08 95       	ret

00000782 <left_position_encoder_interrupt_init>:

 //Interrupt 4 enable
void left_position_encoder_interrupt_init (void)
{
	cli();						//Clears the global interrupt
     782:	f8 94       	cli
	EICRB = EICRB | 0x02;		// INT4 is set to trigger with falling edge
     784:	ea e6       	ldi	r30, 0x6A	; 106
     786:	f0 e0       	ldi	r31, 0x00	; 0
     788:	80 81       	ld	r24, Z
     78a:	82 60       	ori	r24, 0x02	; 2
     78c:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10;		// Enable Interrupt INT4 for left position encoder
     78e:	ec 9a       	sbi	0x1d, 4	; 29
	sei();						// Enables the global interrupt
     790:	78 94       	sei
}
     792:	08 95       	ret

00000794 <right_position_encoder_interrupt_init>:

 //Interrupt 5 enable
void right_position_encoder_interrupt_init (void)
{
	cli();						//Clears the global interrupt
     794:	f8 94       	cli
	EICRB = EICRB | 0x08;		// INT5 is set to trigger with falling edge
     796:	ea e6       	ldi	r30, 0x6A	; 106
     798:	f0 e0       	ldi	r31, 0x00	; 0
     79a:	80 81       	ld	r24, Z
     79c:	88 60       	ori	r24, 0x08	; 8
     79e:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20;		// Enable Interrupt INT5 for right position encoder
     7a0:	ed 9a       	sbi	0x1d, 5	; 29
	sei();						// Enables the global interrupt
     7a2:	78 94       	sei
}
     7a4:	08 95       	ret

000007a6 <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     7a6:	1f 92       	push	r1
     7a8:	0f 92       	push	r0
     7aa:	0f b6       	in	r0, 0x3f	; 63
     7ac:	0f 92       	push	r0
     7ae:	11 24       	eor	r1, r1
     7b0:	8f 93       	push	r24
     7b2:	9f 93       	push	r25
     7b4:	af 93       	push	r26
     7b6:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     7b8:	80 91 4e 06 	lds	r24, 0x064E
     7bc:	90 91 4f 06 	lds	r25, 0x064F
     7c0:	a0 91 50 06 	lds	r26, 0x0650
     7c4:	b0 91 51 06 	lds	r27, 0x0651
     7c8:	01 96       	adiw	r24, 0x01	; 1
     7ca:	a1 1d       	adc	r26, r1
     7cc:	b1 1d       	adc	r27, r1
     7ce:	80 93 4e 06 	sts	0x064E, r24
     7d2:	90 93 4f 06 	sts	0x064F, r25
     7d6:	a0 93 50 06 	sts	0x0650, r26
     7da:	b0 93 51 06 	sts	0x0651, r27
}
     7de:	bf 91       	pop	r27
     7e0:	af 91       	pop	r26
     7e2:	9f 91       	pop	r25
     7e4:	8f 91       	pop	r24
     7e6:	0f 90       	pop	r0
     7e8:	0f be       	out	0x3f, r0	; 63
     7ea:	0f 90       	pop	r0
     7ec:	1f 90       	pop	r1
     7ee:	18 95       	reti

000007f0 <__vector_25>:

ISR(USART0_RX_vect) // ISR for receive complete interrupt for USART0
{
     7f0:	1f 92       	push	r1
     7f2:	0f 92       	push	r0
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	0f 92       	push	r0
     7f8:	0b b6       	in	r0, 0x3b	; 59
     7fa:	0f 92       	push	r0
     7fc:	11 24       	eor	r1, r1
     7fe:	8f 93       	push	r24
     800:	9f 93       	push	r25
     802:	ef 93       	push	r30
     804:	ff 93       	push	r31
	//How to identify the coordinate which is sent by rescue robot is whether its current position or is it coordinate of black debris
	//because its just a 2 digit no. that rescue robot is going to send in both cases? We can distinguish this kind of data by sending  
	//different end packets for both kind of data. For example in case of information about rescue robots current position the end packet
	//will be 2, so when search robot receives data packet 2 the previous data sent must be rescue robots current position
	
	char data = UDR0;  //store the incoming data in 8 bit variable
     806:	80 91 c6 00 	lds	r24, 0x00C6
	rescueData[rescueDataIndex] = data;  //store the received data in int array
     80a:	e0 91 62 06 	lds	r30, 0x0662
     80e:	f0 91 63 06 	lds	r31, 0x0663
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	ee 0f       	add	r30, r30
     816:	ff 1f       	adc	r31, r31
     818:	ec 59       	subi	r30, 0x9C	; 156
     81a:	f9 4f       	sbci	r31, 0xF9	; 249
     81c:	91 83       	std	Z+1, r25	; 0x01
     81e:	80 83       	st	Z, r24
	
	if(rescueData[rescueDataIndex] == 3)  //if end packet received is 3 then the previous data sent must be information about black debris
     820:	e0 91 62 06 	lds	r30, 0x0662
     824:	f0 91 63 06 	lds	r31, 0x0663
     828:	ee 0f       	add	r30, r30
     82a:	ff 1f       	adc	r31, r31
     82c:	ec 59       	subi	r30, 0x9C	; 156
     82e:	f9 4f       	sbci	r31, 0xF9	; 249
     830:	80 81       	ld	r24, Z
     832:	91 81       	ldd	r25, Z+1	; 0x01
     834:	83 30       	cpi	r24, 0x03	; 3
     836:	91 05       	cpc	r25, r1
     838:	99 f5       	brne	.+102    	; 0x8a0 <__vector_25+0xb0>
	{
		cinfo[rescueData[0]][4] = 1;  //update cinfo data structure. on place of black debris coordinate put 1 in 4th column
     83a:	80 91 64 06 	lds	r24, 0x0664
     83e:	90 91 65 06 	lds	r25, 0x0665
     842:	fc 01       	movw	r30, r24
     844:	ee 0f       	add	r30, r30
     846:	ff 1f       	adc	r31, r31
     848:	88 0f       	add	r24, r24
     84a:	99 1f       	adc	r25, r25
     84c:	88 0f       	add	r24, r24
     84e:	99 1f       	adc	r25, r25
     850:	88 0f       	add	r24, r24
     852:	99 1f       	adc	r25, r25
     854:	e8 0f       	add	r30, r24
     856:	f9 1f       	adc	r31, r25
     858:	ea 5e       	subi	r30, 0xEA	; 234
     85a:	fd 4f       	sbci	r31, 0xFD	; 253
     85c:	81 e0       	ldi	r24, 0x01	; 1
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	91 87       	std	Z+9, r25	; 0x09
     862:	80 87       	std	Z+8, r24	; 0x08
		coordinatesWithBlackDebris[blackDebrisCounter] = rescueData[0];  //update the coordinatesWithBlackDebris array
     864:	e0 91 5c 06 	lds	r30, 0x065C
     868:	f0 91 5d 06 	lds	r31, 0x065D
     86c:	80 91 64 06 	lds	r24, 0x0664
     870:	90 91 65 06 	lds	r25, 0x0665
     874:	ee 0f       	add	r30, r30
     876:	ff 1f       	adc	r31, r31
     878:	e2 50       	subi	r30, 0x02	; 2
     87a:	fa 4f       	sbci	r31, 0xFA	; 250
     87c:	91 83       	std	Z+1, r25	; 0x01
     87e:	80 83       	st	Z, r24
		blackDebrisCounter++; //increment blackDebrisCounter after updating coordinatesWithBlackDebris array
     880:	80 91 5c 06 	lds	r24, 0x065C
     884:	90 91 5d 06 	lds	r25, 0x065D
     888:	01 96       	adiw	r24, 0x01	; 1
     88a:	90 93 5d 06 	sts	0x065D, r25
     88e:	80 93 5c 06 	sts	0x065C, r24
		rescueDataIndex = -1; //reset index of rescue data array to -1 so next when it receives data it will store from 0th position
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	9f ef       	ldi	r25, 0xFF	; 255
     896:	90 93 63 06 	sts	0x0663, r25
     89a:	80 93 62 06 	sts	0x0662, r24
     89e:	4d c0       	rjmp	.+154    	; 0x93a <__vector_25+0x14a>
							  //-1 because at the end of the ISR rescueDataIndex is getting incremented so it will become 0 automatically
	}
	
	else if(rescueData[rescueDataIndex] == 2)  //if end packet received is 2 then previous data sent must be the information about rescue current position
     8a0:	e0 91 62 06 	lds	r30, 0x0662
     8a4:	f0 91 63 06 	lds	r31, 0x0663
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	ec 59       	subi	r30, 0x9C	; 156
     8ae:	f9 4f       	sbci	r31, 0xF9	; 249
     8b0:	80 81       	ld	r24, Z
     8b2:	91 81       	ldd	r25, Z+1	; 0x01
     8b4:	82 30       	cpi	r24, 0x02	; 2
     8b6:	91 05       	cpc	r25, r1
     8b8:	79 f4       	brne	.+30     	; 0x8d8 <__vector_25+0xe8>
	{
		rescueCurrentPosition = rescueData[0];  //store the rescue current position in rescueCurrentPosition variable
     8ba:	80 91 64 06 	lds	r24, 0x0664
     8be:	90 91 65 06 	lds	r25, 0x0665
     8c2:	90 93 61 06 	sts	0x0661, r25
     8c6:	80 93 60 06 	sts	0x0660, r24
		rescueDataIndex = -1;  //reset index of rescue data array to -1
     8ca:	8f ef       	ldi	r24, 0xFF	; 255
     8cc:	9f ef       	ldi	r25, 0xFF	; 255
     8ce:	90 93 63 06 	sts	0x0663, r25
     8d2:	80 93 62 06 	sts	0x0662, r24
     8d6:	31 c0       	rjmp	.+98     	; 0x93a <__vector_25+0x14a>
	}
	else if(rescueData[rescueDataIndex] == 7) //if the data received is 7 then set flag variable stopSearchRobot to 1
     8d8:	e0 91 62 06 	lds	r30, 0x0662
     8dc:	f0 91 63 06 	lds	r31, 0x0663
     8e0:	ee 0f       	add	r30, r30
     8e2:	ff 1f       	adc	r31, r31
     8e4:	ec 59       	subi	r30, 0x9C	; 156
     8e6:	f9 4f       	sbci	r31, 0xF9	; 249
     8e8:	80 81       	ld	r24, Z
     8ea:	91 81       	ldd	r25, Z+1	; 0x01
     8ec:	87 30       	cpi	r24, 0x07	; 7
     8ee:	91 05       	cpc	r25, r1
     8f0:	69 f4       	brne	.+26     	; 0x90c <__vector_25+0x11c>
	{
		stopSearchRobot = 1;
     8f2:	81 e0       	ldi	r24, 0x01	; 1
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	90 93 5f 06 	sts	0x065F, r25
     8fa:	80 93 5e 06 	sts	0x065E, r24
		rescueDataIndex = -1;
     8fe:	8f ef       	ldi	r24, 0xFF	; 255
     900:	9f ef       	ldi	r25, 0xFF	; 255
     902:	90 93 63 06 	sts	0x0663, r25
     906:	80 93 62 06 	sts	0x0662, r24
     90a:	17 c0       	rjmp	.+46     	; 0x93a <__vector_25+0x14a>
	}
	else if(rescueData[rescueDataIndex] == 8) //if the data received is 8 then set flag variable stopSearchRobot to 0
     90c:	e0 91 62 06 	lds	r30, 0x0662
     910:	f0 91 63 06 	lds	r31, 0x0663
     914:	ee 0f       	add	r30, r30
     916:	ff 1f       	adc	r31, r31
     918:	ec 59       	subi	r30, 0x9C	; 156
     91a:	f9 4f       	sbci	r31, 0xF9	; 249
     91c:	80 81       	ld	r24, Z
     91e:	91 81       	ldd	r25, Z+1	; 0x01
     920:	88 30       	cpi	r24, 0x08	; 8
     922:	91 05       	cpc	r25, r1
     924:	51 f4       	brne	.+20     	; 0x93a <__vector_25+0x14a>
	{
		stopSearchRobot = 0;
     926:	10 92 5f 06 	sts	0x065F, r1
     92a:	10 92 5e 06 	sts	0x065E, r1
		rescueDataIndex = -1;
     92e:	8f ef       	ldi	r24, 0xFF	; 255
     930:	9f ef       	ldi	r25, 0xFF	; 255
     932:	90 93 63 06 	sts	0x0663, r25
     936:	80 93 62 06 	sts	0x0662, r24
	}
	rescueDataIndex++; //increment the rescueDataIndex after receiving packet
     93a:	80 91 62 06 	lds	r24, 0x0662
     93e:	90 91 63 06 	lds	r25, 0x0663
     942:	01 96       	adiw	r24, 0x01	; 1
     944:	90 93 63 06 	sts	0x0663, r25
     948:	80 93 62 06 	sts	0x0662, r24
}
     94c:	ff 91       	pop	r31
     94e:	ef 91       	pop	r30
     950:	9f 91       	pop	r25
     952:	8f 91       	pop	r24
     954:	0f 90       	pop	r0
     956:	0b be       	out	0x3b, r0	; 59
     958:	0f 90       	pop	r0
     95a:	0f be       	out	0x3f, r0	; 63
     95c:	0f 90       	pop	r0
     95e:	1f 90       	pop	r1
     960:	18 95       	reti

00000962 <__vector_5>:

//ISR for left position encoder
ISR(INT4_vect)
{
     962:	1f 92       	push	r1
     964:	0f 92       	push	r0
     966:	0f b6       	in	r0, 0x3f	; 63
     968:	0f 92       	push	r0
     96a:	11 24       	eor	r1, r1
     96c:	8f 93       	push	r24
     96e:	9f 93       	push	r25
     970:	af 93       	push	r26
     972:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     974:	80 91 52 06 	lds	r24, 0x0652
     978:	90 91 53 06 	lds	r25, 0x0653
     97c:	a0 91 54 06 	lds	r26, 0x0654
     980:	b0 91 55 06 	lds	r27, 0x0655
     984:	01 96       	adiw	r24, 0x01	; 1
     986:	a1 1d       	adc	r26, r1
     988:	b1 1d       	adc	r27, r1
     98a:	80 93 52 06 	sts	0x0652, r24
     98e:	90 93 53 06 	sts	0x0653, r25
     992:	a0 93 54 06 	sts	0x0654, r26
     996:	b0 93 55 06 	sts	0x0655, r27
}
     99a:	bf 91       	pop	r27
     99c:	af 91       	pop	r26
     99e:	9f 91       	pop	r25
     9a0:	8f 91       	pop	r24
     9a2:	0f 90       	pop	r0
     9a4:	0f be       	out	0x3f, r0	; 63
     9a6:	0f 90       	pop	r0
     9a8:	1f 90       	pop	r1
     9aa:	18 95       	reti

000009ac <__vector_1>:

//ISR for color sensor output
ISR(INT0_vect)
{
     9ac:	1f 92       	push	r1
     9ae:	0f 92       	push	r0
     9b0:	0f b6       	in	r0, 0x3f	; 63
     9b2:	0f 92       	push	r0
     9b4:	11 24       	eor	r1, r1
     9b6:	8f 93       	push	r24
     9b8:	9f 93       	push	r25
     9ba:	af 93       	push	r26
     9bc:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     9be:	80 91 56 06 	lds	r24, 0x0656
     9c2:	90 91 57 06 	lds	r25, 0x0657
     9c6:	a0 91 58 06 	lds	r26, 0x0658
     9ca:	b0 91 59 06 	lds	r27, 0x0659
     9ce:	01 96       	adiw	r24, 0x01	; 1
     9d0:	a1 1d       	adc	r26, r1
     9d2:	b1 1d       	adc	r27, r1
     9d4:	80 93 56 06 	sts	0x0656, r24
     9d8:	90 93 57 06 	sts	0x0657, r25
     9dc:	a0 93 58 06 	sts	0x0658, r26
     9e0:	b0 93 59 06 	sts	0x0659, r27
}
     9e4:	bf 91       	pop	r27
     9e6:	af 91       	pop	r26
     9e8:	9f 91       	pop	r25
     9ea:	8f 91       	pop	r24
     9ec:	0f 90       	pop	r0
     9ee:	0f be       	out	0x3f, r0	; 63
     9f0:	0f 90       	pop	r0
     9f2:	1f 90       	pop	r1
     9f4:	18 95       	reti

000009f6 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibble for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     9f6:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibble to 0
     9f8:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibble for the protection
     9fa:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibble to 0
	PortARestore |= Direction; // adding lower nibble for forward command and restoring the PORTA status
     9fc:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     9fe:	92 b9       	out	0x02, r25	; 2
}
     a00:	08 95       	ret

00000a02 <forward>:

//both wheels forward
void forward (void) 
{
	motion_set(0x06);
     a02:	86 e0       	ldi	r24, 0x06	; 6
     a04:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <motion_set>
}
     a08:	08 95       	ret

00000a0a <back>:

//both wheels backward
void back (void)
{
	motion_set(0x09);
     a0a:	89 e0       	ldi	r24, 0x09	; 9
     a0c:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <motion_set>
}
     a10:	08 95       	ret

00000a12 <left>:

//Left wheel backward, Right wheel forward
void left (void) 
{
	motion_set(0x05);
     a12:	85 e0       	ldi	r24, 0x05	; 5
     a14:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <motion_set>
}
     a18:	08 95       	ret

00000a1a <right>:

//Left wheel forward, Right wheel backward
void right (void) 
{
	motion_set(0x0A);
     a1a:	8a e0       	ldi	r24, 0x0A	; 10
     a1c:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <motion_set>
}
     a20:	08 95       	ret

00000a22 <stop>:

//stops the both wheels
void stop (void)
{
	motion_set(0x00);
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <motion_set>
}
     a28:	08 95       	ret

00000a2a <Sharp_GP2D12_estimation>:

// This Function calculates the actual distance in millimeters(mm) from the input
// analog value of Sharp Sensor.
unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     a2a:	0f 93       	push	r16
     a2c:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     a2e:	68 2f       	mov	r22, r24
     a30:	70 e0       	ldi	r23, 0x00	; 0
     a32:	80 e0       	ldi	r24, 0x00	; 0
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     a3a:	2f ee       	ldi	r18, 0xEF	; 239
     a3c:	39 ec       	ldi	r19, 0xC9	; 201
     a3e:	43 e9       	ldi	r20, 0x93	; 147
     a40:	5f e3       	ldi	r21, 0x3F	; 63
     a42:	0e 94 00 17 	call	0x2e00	; 0x2e00 <pow>
     a46:	b6 2f       	mov	r27, r22
     a48:	a7 2f       	mov	r26, r23
     a4a:	38 2f       	mov	r19, r24
     a4c:	29 2f       	mov	r18, r25
     a4e:	60 e0       	ldi	r22, 0x00	; 0
     a50:	70 e0       	ldi	r23, 0x00	; 0
     a52:	80 e8       	ldi	r24, 0x80	; 128
     a54:	9f e3       	ldi	r25, 0x3F	; 63
     a56:	42 2f       	mov	r20, r18
     a58:	0b 2f       	mov	r16, r27
     a5a:	1a 2f       	mov	r17, r26
     a5c:	23 2f       	mov	r18, r19
     a5e:	34 2f       	mov	r19, r20
     a60:	a9 01       	movw	r20, r18
     a62:	98 01       	movw	r18, r16
     a64:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
     a68:	2a e9       	ldi	r18, 0x9A	; 154
     a6a:	39 ef       	ldi	r19, 0xF9	; 249
     a6c:	4e e2       	ldi	r20, 0x2E	; 46
     a6e:	55 e4       	ldi	r21, 0x45	; 69
     a70:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <__mulsf3>
     a74:	20 e0       	ldi	r18, 0x00	; 0
     a76:	30 e0       	ldi	r19, 0x00	; 0
     a78:	40 e2       	ldi	r20, 0x20	; 32
     a7a:	51 e4       	ldi	r21, 0x41	; 65
     a7c:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <__mulsf3>
     a80:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <__fixsfsi>
     a84:	88 27       	eor	r24, r24
     a86:	77 fd       	sbrc	r23, 7
     a88:	80 95       	com	r24
     a8a:	98 2f       	mov	r25, r24
     a8c:	0e 94 11 16 	call	0x2c22	; 0x2c22 <__floatsisf>
	distanceInt = (int)distance;
     a90:	0e 94 de 15 	call	0x2bbc	; 0x2bbc <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     a94:	86 2f       	mov	r24, r22
     a96:	97 2f       	mov	r25, r23
     a98:	23 e0       	ldi	r18, 0x03	; 3
     a9a:	81 32       	cpi	r24, 0x21	; 33
     a9c:	92 07       	cpc	r25, r18
     a9e:	10 f0       	brcs	.+4      	; 0xaa4 <Sharp_GP2D12_estimation+0x7a>
     aa0:	80 e2       	ldi	r24, 0x20	; 32
     aa2:	93 e0       	ldi	r25, 0x03	; 3
}
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	08 95       	ret

00000aaa <angle_rotate>:

//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     aaa:	0f 93       	push	r16
     aac:	1f 93       	push	r17
     aae:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;
	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     ab0:	bc 01       	movw	r22, r24
     ab2:	80 e0       	ldi	r24, 0x00	; 0
     ab4:	90 e0       	ldi	r25, 0x00	; 0
     ab6:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     aba:	28 e4       	ldi	r18, 0x48	; 72
     abc:	31 ee       	ldi	r19, 0xE1	; 225
     abe:	42 e8       	ldi	r20, 0x82	; 130
     ac0:	50 e4       	ldi	r21, 0x40	; 64
     ac2:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     ac6:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__fixunssfsi>
     aca:	dc 01       	movw	r26, r24
     acc:	cb 01       	movw	r24, r22
     ace:	a0 e0       	ldi	r26, 0x00	; 0
     ad0:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     ad2:	10 92 4e 06 	sts	0x064E, r1
     ad6:	10 92 4f 06 	sts	0x064F, r1
     ada:	10 92 50 06 	sts	0x0650, r1
     ade:	10 92 51 06 	sts	0x0651, r1
	ShaftCountLeft = 0;
     ae2:	10 92 52 06 	sts	0x0652, r1
     ae6:	10 92 53 06 	sts	0x0653, r1
     aea:	10 92 54 06 	sts	0x0654, r1
     aee:	10 92 55 06 	sts	0x0655, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     af2:	f1 e0       	ldi	r31, 0x01	; 1
     af4:	c0 e0       	ldi	r28, 0x00	; 0
     af6:	40 91 4e 06 	lds	r20, 0x064E
     afa:	50 91 4f 06 	lds	r21, 0x064F
     afe:	60 91 50 06 	lds	r22, 0x0650
     b02:	70 91 51 06 	lds	r23, 0x0651
     b06:	00 91 52 06 	lds	r16, 0x0652
     b0a:	10 91 53 06 	lds	r17, 0x0653
     b0e:	20 91 54 06 	lds	r18, 0x0654
     b12:	30 91 55 06 	lds	r19, 0x0655
     b16:	ef 2f       	mov	r30, r31
     b18:	48 17       	cp	r20, r24
     b1a:	59 07       	cpc	r21, r25
     b1c:	6a 07       	cpc	r22, r26
     b1e:	7b 07       	cpc	r23, r27
     b20:	08 f4       	brcc	.+2      	; 0xb24 <angle_rotate+0x7a>
     b22:	ec 2f       	mov	r30, r28
     b24:	ee 23       	and	r30, r30
     b26:	49 f4       	brne	.+18     	; 0xb3a <angle_rotate+0x90>
     b28:	4f 2f       	mov	r20, r31
     b2a:	08 17       	cp	r16, r24
     b2c:	19 07       	cpc	r17, r25
     b2e:	2a 07       	cpc	r18, r26
     b30:	3b 07       	cpc	r19, r27
     b32:	08 f4       	brcc	.+2      	; 0xb36 <angle_rotate+0x8c>
     b34:	4c 2f       	mov	r20, r28
     b36:	44 23       	and	r20, r20
     b38:	f1 f2       	breq	.-68     	; 0xaf6 <angle_rotate+0x4c>
			break;
	}
	//stop(); //Stop robot
}
     b3a:	cf 91       	pop	r28
     b3c:	1f 91       	pop	r17
     b3e:	0f 91       	pop	r16
     b40:	08 95       	ret

00000b42 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     b42:	bc 01       	movw	r22, r24
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	90 e0       	ldi	r25, 0x00	; 0
     b48:	0e 94 0f 16 	call	0x2c1e	; 0x2c1e <__floatunsisf>
     b4c:	25 ee       	ldi	r18, 0xE5	; 229
     b4e:	30 ed       	ldi	r19, 0xD0	; 208
     b50:	4a ea       	ldi	r20, 0xAA	; 170
     b52:	50 e4       	ldi	r21, 0x40	; 64
     b54:	0e 94 76 15 	call	0x2aec	; 0x2aec <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     b58:	0e 94 e3 15 	call	0x2bc6	; 0x2bc6 <__fixunssfsi>
     b5c:	46 2f       	mov	r20, r22
     b5e:	57 2f       	mov	r21, r23
     b60:	68 2f       	mov	r22, r24
     b62:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     b64:	10 92 4e 06 	sts	0x064E, r1
     b68:	10 92 4f 06 	sts	0x064F, r1
     b6c:	10 92 50 06 	sts	0x0650, r1
     b70:	10 92 51 06 	sts	0x0651, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     b74:	80 91 4e 06 	lds	r24, 0x064E
     b78:	90 91 4f 06 	lds	r25, 0x064F
     b7c:	a0 91 50 06 	lds	r26, 0x0650
     b80:	b0 91 51 06 	lds	r27, 0x0651
     b84:	48 17       	cp	r20, r24
     b86:	59 07       	cpc	r21, r25
     b88:	6a 07       	cpc	r22, r26
     b8a:	7b 07       	cpc	r23, r27
     b8c:	98 f7       	brcc	.-26     	; 0xb74 <linear_distance_mm+0x32>
		{
			break;
		}
	}
	//stop(); //Stop robot
}
     b8e:	08 95       	ret

00000b90 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     b90:	cf 93       	push	r28
     b92:	df 93       	push	r29
     b94:	ec 01       	movw	r28, r24
	forward();
     b96:	0e 94 01 05 	call	0xa02	; 0xa02 <forward>
	linear_distance_mm(DistanceInMM);
     b9a:	ce 01       	movw	r24, r28
     b9c:	0e 94 a1 05 	call	0xb42	; 0xb42 <linear_distance_mm>
}
     ba0:	df 91       	pop	r29
     ba2:	cf 91       	pop	r28
     ba4:	08 95       	ret

00000ba6 <left_degrees>:


void left_degrees(unsigned int Degrees)
{
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     bac:	0e 94 09 05 	call	0xa12	; 0xa12 <left>
	angle_rotate(Degrees);
     bb0:	ce 01       	movw	r24, r28
     bb2:	0e 94 55 05 	call	0xaaa	; 0xaaa <angle_rotate>
}
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <right_degrees>:

void right_degrees(unsigned int Degrees)
{
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     bc2:	0e 94 0d 05 	call	0xa1a	; 0xa1a <right>
	angle_rotate(Degrees);
     bc6:	ce 01       	movw	r24, r28
     bc8:	0e 94 55 05 	call	0xaaa	; 0xaaa <angle_rotate>
}
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	08 95       	ret

00000bd2 <lcd_port_config>:

//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     bd2:	87 b1       	in	r24, 0x07	; 7
     bd4:	87 6f       	ori	r24, 0xF7	; 247
     bd6:	87 b9       	out	0x07, r24	; 7
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     bd8:	88 b1       	in	r24, 0x08	; 8
     bda:	80 78       	andi	r24, 0x80	; 128
     bdc:	88 b9       	out	0x08, r24	; 8
}
     bde:	08 95       	ret

00000be0 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
	DDRF = 0x00;
     be0:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     be2:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     be4:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     be8:	10 92 08 01 	sts	0x0108, r1
}
     bec:	08 95       	ret

00000bee <buzzer_pin_config>:

void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;			//Setting PORTC 3 as output
     bee:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     bf0:	43 98       	cbi	0x08, 3	; 8
}
     bf2:	08 95       	ret

00000bf4 <port_init>:

//Function to Initialize PORTS
void port_init()
{
	motion_pin_config();			//robot motion pins config
     bf4:	0e 94 aa 03 	call	0x754	; 0x754 <motion_pin_config>
	left_encoder_pin_config();		//left encoder pin config
     bf8:	0e 94 bb 03 	call	0x776	; 0x776 <left_encoder_pin_config>
	right_encoder_pin_config();	    //right encoder pin config
     bfc:	0e 94 be 03 	call	0x77c	; 0x77c <right_encoder_pin_config>
	buzzer_pin_config();			//buzzer pin config
     c00:	0e 94 f7 05 	call	0xbee	; 0xbee <buzzer_pin_config>
	lcd_port_config();				//lcd pin config
     c04:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <lcd_port_config>
	adc_pin_config();				//adc pin config
     c08:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <adc_pin_config>
	motion_pin_config();			//motor driver pin config
     c0c:	0e 94 aa 03 	call	0x754	; 0x754 <motion_pin_config>
	base_servo_pin_config();
     c10:	0e 94 53 02 	call	0x4a6	; 0x4a6 <base_servo_pin_config>
	elbow_servo_pin_config();
     c14:	0e 94 56 02 	call	0x4ac	; 0x4ac <elbow_servo_pin_config>
	gripper_servo_pin_config();
     c18:	0e 94 59 02 	call	0x4b2	; 0x4b2 <gripper_servo_pin_config>
	color_sensor_pin_config();
     c1c:	0e 94 93 03 	call	0x726	; 0x726 <color_sensor_pin_config>
	led_port_config();
     c20:	0e 94 3a 02 	call	0x474	; 0x474 <led_port_config>
}
     c24:	08 95       	ret

00000c26 <timer5_init>:
// Pre-scale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     c26:	e1 e2       	ldi	r30, 0x21	; 33
     c28:	f1 e0       	ldi	r31, 0x01	; 1
     c2a:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     c2c:	8f ef       	ldi	r24, 0xFF	; 255
     c2e:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     c32:	91 e0       	ldi	r25, 0x01	; 1
     c34:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     c38:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     c3c:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     c40:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     c44:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     c48:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     c4c:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     c50:	89 ea       	ldi	r24, 0xA9	; 169
     c52:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     c56:	8b e0       	ldi	r24, 0x0B	; 11
     c58:	80 83       	st	Z, r24
}
     c5a:	08 95       	ret

00000c5c <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     c5c:	e1 ec       	ldi	r30, 0xC1	; 193
     c5e:	f0 e0       	ldi	r31, 0x00	; 0
     c60:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     c62:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
     c66:	86 e0       	ldi	r24, 0x06	; 6
     c68:	80 93 c2 00 	sts	0x00C2, r24
	//UBRR0L = 0x47; //11059200 Hz
	UBRR0L = 0x5F; // 14745600 Hz set baud rate lo
     c6c:	8f e5       	ldi	r24, 0x5F	; 95
     c6e:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     c72:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     c76:	88 e9       	ldi	r24, 0x98	; 152
     c78:	80 83       	st	Z, r24
}
     c7a:	08 95       	ret

00000c7c <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     c7c:	ea e7       	ldi	r30, 0x7A	; 122
     c7e:	f0 e0       	ldi	r31, 0x00	; 0
     c80:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     c82:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     c86:	80 e2       	ldi	r24, 0x20	; 32
     c88:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     c8c:	80 e8       	ldi	r24, 0x80	; 128
     c8e:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     c90:	86 e8       	ldi	r24, 0x86	; 134
     c92:	80 83       	st	Z, r24
}
     c94:	08 95       	ret

00000c96 <ADC_Conversion>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
	unsigned char a;
	if(Ch>7)
     c96:	88 30       	cpi	r24, 0x08	; 8
     c98:	18 f0       	brcs	.+6      	; 0xca0 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     c9a:	98 e0       	ldi	r25, 0x08	; 8
     c9c:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;  			
     ca0:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;	   		
     ca2:	80 62       	ori	r24, 0x20	; 32
     ca4:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     ca8:	ea e7       	ldi	r30, 0x7A	; 122
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	80 81       	ld	r24, Z
     cae:	80 64       	ori	r24, 0x40	; 64
     cb0:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
     cb2:	80 81       	ld	r24, Z
     cb4:	84 ff       	sbrs	r24, 4
     cb6:	fd cf       	rjmp	.-6      	; 0xcb2 <ADC_Conversion+0x1c>
	a=ADCH;
     cb8:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     cbc:	ea e7       	ldi	r30, 0x7A	; 122
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	90 81       	ld	r25, Z
     cc2:	90 61       	ori	r25, 0x10	; 16
     cc4:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     cc6:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     cca:	08 95       	ret

00000ccc <print_sensor>:

//Function To Print Sensor Values At Desired Row And Column Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
     ccc:	cf 93       	push	r28
     cce:	df 93       	push	r29
     cd0:	d8 2f       	mov	r29, r24
     cd2:	c6 2f       	mov	r28, r22
     cd4:	84 2f       	mov	r24, r20
	
	ADC_Value = ADC_Conversion(channel);
     cd6:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     cda:	48 2f       	mov	r20, r24
     cdc:	80 93 ad 06 	sts	0x06AD, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     ce0:	8d 2f       	mov	r24, r29
     ce2:	6c 2f       	mov	r22, r28
     ce4:	50 e0       	ldi	r21, 0x00	; 0
     ce6:	23 e0       	ldi	r18, 0x03	; 3
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
}
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	08 95       	ret

00000cf4 <scanForBlackDebris>:
*				  3) send information about this black debris to rescue robot
* Example Call:	  scanForBlackDebris();
*
*/
void scanForBlackDebris()
{
     cf4:	0f 93       	push	r16
     cf6:	1f 93       	push	r17
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
	int blackDebrisPos;  //variable to store calculated black debris position 
	int x, y;
	x = current_pos % 10; //extract x from current position
     cfc:	20 91 9b 06 	lds	r18, 0x069B
     d00:	30 91 9c 06 	lds	r19, 0x069C
     d04:	c9 01       	movw	r24, r18
     d06:	6a e0       	ldi	r22, 0x0A	; 10
     d08:	70 e0       	ldi	r23, 0x00	; 0
     d0a:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
	y = current_pos / 10; //extract y from current position
	
	//if both x and y are odd means robot is standing on node then scan for black debris in front of it
	if (x % 2 != 0 && y %2 != 0)
     d0e:	80 ff       	sbrs	r24, 0
     d10:	c7 c0       	rjmp	.+398    	; 0xea0 <scanForBlackDebris+0x1ac>
void scanForBlackDebris()
{
	int blackDebrisPos;  //variable to store calculated black debris position 
	int x, y;
	x = current_pos % 10; //extract x from current position
	y = current_pos / 10; //extract y from current position
     d12:	c9 01       	movw	r24, r18
     d14:	6a e0       	ldi	r22, 0x0A	; 10
     d16:	70 e0       	ldi	r23, 0x00	; 0
     d18:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
	
	//if both x and y are odd means robot is standing on node then scan for black debris in front of it
	if (x % 2 != 0 && y %2 != 0)
     d1c:	60 ff       	sbrs	r22, 0
     d1e:	c0 c0       	rjmp	.+384    	; 0xea0 <scanForBlackDebris+0x1ac>
	{
		//take reading from sharp IR sensor
		int sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
     d20:	8b e0       	ldi	r24, 0x0B	; 11
     d22:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
		int value = Sharp_GP2D12_estimation(sharp);
     d26:	0e 94 15 05 	call	0xa2a	; 0xa2a <Sharp_GP2D12_estimation>
     d2a:	ec 01       	movw	r28, r24
		lcd_print(2,1,value,3);
     d2c:	82 e0       	ldi	r24, 0x02	; 2
     d2e:	61 e0       	ldi	r22, 0x01	; 1
     d30:	ae 01       	movw	r20, r28
     d32:	23 e0       	ldi	r18, 0x03	; 3
     d34:	30 e0       	ldi	r19, 0x00	; 0
     d36:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
		
		if(value < 230 && value > 0)  //if value is less then 230 that means black debris is present
     d3a:	21 97       	sbiw	r28, 0x01	; 1
     d3c:	c5 3e       	cpi	r28, 0xE5	; 229
     d3e:	d1 05       	cpc	r29, r1
     d40:	08 f0       	brcs	.+2      	; 0xd44 <scanForBlackDebris+0x50>
     d42:	ae c0       	rjmp	.+348    	; 0xea0 <scanForBlackDebris+0x1ac>
		{
			resetPath = 1;  //set resetPath flag to 1 indicating path needs to recalculated excluding found black debris
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	90 e0       	ldi	r25, 0x00	; 0
     d48:	90 93 5b 06 	sts	0x065B, r25
     d4c:	80 93 5a 06 	sts	0x065A, r24
			print_sensor(2,1,11);
     d50:	82 e0       	ldi	r24, 0x02	; 2
     d52:	61 e0       	ldi	r22, 0x01	; 1
     d54:	4b e0       	ldi	r20, 0x0B	; 11
     d56:	0e 94 66 06 	call	0xccc	; 0xccc <print_sensor>
			
			//calculate position of black debris based on orientation of the robot
			if(orientation == point_north)
     d5a:	80 91 95 06 	lds	r24, 0x0695
     d5e:	90 91 96 06 	lds	r25, 0x0696
     d62:	20 91 9d 06 	lds	r18, 0x069D
     d66:	30 91 9e 06 	lds	r19, 0x069E
     d6a:	82 17       	cp	r24, r18
     d6c:	93 07       	cpc	r25, r19
     d6e:	39 f4       	brne	.+14     	; 0xd7e <scanForBlackDebris+0x8a>
				blackDebrisPos = current_pos + 10;
     d70:	00 91 9b 06 	lds	r16, 0x069B
     d74:	10 91 9c 06 	lds	r17, 0x069C
     d78:	06 5f       	subi	r16, 0xF6	; 246
     d7a:	1f 4f       	sbci	r17, 0xFF	; 255
     d7c:	29 c0       	rjmp	.+82     	; 0xdd0 <scanForBlackDebris+0xdc>
			else if(orientation == point_south)
     d7e:	20 91 12 02 	lds	r18, 0x0212
     d82:	30 91 13 02 	lds	r19, 0x0213
     d86:	82 17       	cp	r24, r18
     d88:	93 07       	cpc	r25, r19
     d8a:	39 f4       	brne	.+14     	; 0xd9a <scanForBlackDebris+0xa6>
				blackDebrisPos = current_pos - 10;
     d8c:	00 91 9b 06 	lds	r16, 0x069B
     d90:	10 91 9c 06 	lds	r17, 0x069C
     d94:	0a 50       	subi	r16, 0x0A	; 10
     d96:	10 40       	sbci	r17, 0x00	; 0
     d98:	1b c0       	rjmp	.+54     	; 0xdd0 <scanForBlackDebris+0xdc>
			else if(orientation == point_east)
     d9a:	20 91 14 02 	lds	r18, 0x0214
     d9e:	30 91 15 02 	lds	r19, 0x0215
     da2:	82 17       	cp	r24, r18
     da4:	93 07       	cpc	r25, r19
     da6:	39 f4       	brne	.+14     	; 0xdb6 <scanForBlackDebris+0xc2>
				blackDebrisPos = current_pos + 1;
     da8:	00 91 9b 06 	lds	r16, 0x069B
     dac:	10 91 9c 06 	lds	r17, 0x069C
     db0:	0f 5f       	subi	r16, 0xFF	; 255
     db2:	1f 4f       	sbci	r17, 0xFF	; 255
     db4:	0d c0       	rjmp	.+26     	; 0xdd0 <scanForBlackDebris+0xdc>
			else if(orientation == point_west)
     db6:	20 91 10 02 	lds	r18, 0x0210
     dba:	30 91 11 02 	lds	r19, 0x0211
     dbe:	82 17       	cp	r24, r18
     dc0:	93 07       	cpc	r25, r19
     dc2:	31 f4       	brne	.+12     	; 0xdd0 <scanForBlackDebris+0xdc>
				blackDebrisPos = current_pos - 1;
     dc4:	00 91 9b 06 	lds	r16, 0x069B
     dc8:	10 91 9c 06 	lds	r17, 0x069C
     dcc:	01 50       	subi	r16, 0x01	; 1
     dce:	10 40       	sbci	r17, 0x00	; 0
			
			//There is a possibility that rescue robot is standing on midpoint and search robot is standing on node facing rescue robot
			//search robot will scan that mid point for black debris and the calculated value will be less then 230. In this case we don't have to consider
			//that mid point as black debris so before updating cinfo matrix, coordinatesWithBlackDebris sending it's position to rescue robot
			//check if calculated black debris position is equal to rescue robot position or not. If it is equal then do not consider it as a black debris
			if(blackDebrisPos != rescueCurrentPosition)
     dd0:	b8 01       	movw	r22, r16
     dd2:	80 91 60 06 	lds	r24, 0x0660
     dd6:	90 91 61 06 	lds	r25, 0x0661
     dda:	08 17       	cp	r16, r24
     ddc:	19 07       	cpc	r17, r25
     dde:	09 f4       	brne	.+2      	; 0xde2 <scanForBlackDebris+0xee>
     de0:	5f c0       	rjmp	.+190    	; 0xea0 <scanForBlackDebris+0x1ac>
			{
				//if calculated black debris position is not equal to rescue robots current position then before doing anything check if it is already scanned or not
				for (int i = 0; coordinatesWithBlackDebris[i] != 0; i++)
     de2:	80 91 fe 05 	lds	r24, 0x05FE
     de6:	90 91 ff 05 	lds	r25, 0x05FF
     dea:	00 97       	sbiw	r24, 0x00	; 0
     dec:	19 f1       	breq	.+70     	; 0xe34 <scanForBlackDebris+0x140>
				{
					//if that position is already scanned then it will be present in coordinatesWithBlackDebris
					if(coordinatesWithBlackDebris[i] == blackDebrisPos)
     dee:	80 91 fe 05 	lds	r24, 0x05FE
     df2:	90 91 ff 05 	lds	r25, 0x05FF
     df6:	08 17       	cp	r16, r24
     df8:	19 07       	cpc	r17, r25
     dfa:	09 f4       	brne	.+2      	; 0xdfe <scanForBlackDebris+0x10a>
     dfc:	51 c0       	rjmp	.+162    	; 0xea0 <scanForBlackDebris+0x1ac>
     dfe:	20 e0       	ldi	r18, 0x00	; 0
     e00:	30 e0       	ldi	r19, 0x00	; 0
			//that mid point as black debris so before updating cinfo matrix, coordinatesWithBlackDebris sending it's position to rescue robot
			//check if calculated black debris position is equal to rescue robot position or not. If it is equal then do not consider it as a black debris
			if(blackDebrisPos != rescueCurrentPosition)
			{
				//if calculated black debris position is not equal to rescue robots current position then before doing anything check if it is already scanned or not
				for (int i = 0; coordinatesWithBlackDebris[i] != 0; i++)
     e02:	4e ef       	ldi	r20, 0xFE	; 254
     e04:	55 e0       	ldi	r21, 0x05	; 5
     e06:	0b c0       	rjmp	.+22     	; 0xe1e <scanForBlackDebris+0x12a>
				{
					//if that position is already scanned then it will be present in coordinatesWithBlackDebris
					if(coordinatesWithBlackDebris[i] == blackDebrisPos)
     e08:	f9 01       	movw	r30, r18
     e0a:	ee 0f       	add	r30, r30
     e0c:	ff 1f       	adc	r31, r31
     e0e:	e4 0f       	add	r30, r20
     e10:	f5 1f       	adc	r31, r21
     e12:	80 81       	ld	r24, Z
     e14:	91 81       	ldd	r25, Z+1	; 0x01
     e16:	68 17       	cp	r22, r24
     e18:	79 07       	cpc	r23, r25
     e1a:	09 f4       	brne	.+2      	; 0xe1e <scanForBlackDebris+0x12a>
     e1c:	41 c0       	rjmp	.+130    	; 0xea0 <scanForBlackDebris+0x1ac>
			//that mid point as black debris so before updating cinfo matrix, coordinatesWithBlackDebris sending it's position to rescue robot
			//check if calculated black debris position is equal to rescue robot position or not. If it is equal then do not consider it as a black debris
			if(blackDebrisPos != rescueCurrentPosition)
			{
				//if calculated black debris position is not equal to rescue robots current position then before doing anything check if it is already scanned or not
				for (int i = 0; coordinatesWithBlackDebris[i] != 0; i++)
     e1e:	2f 5f       	subi	r18, 0xFF	; 255
     e20:	3f 4f       	sbci	r19, 0xFF	; 255
     e22:	f9 01       	movw	r30, r18
     e24:	ee 0f       	add	r30, r30
     e26:	ff 1f       	adc	r31, r31
     e28:	e4 0f       	add	r30, r20
     e2a:	f5 1f       	adc	r31, r21
     e2c:	80 81       	ld	r24, Z
     e2e:	91 81       	ldd	r25, Z+1	; 0x01
     e30:	00 97       	sbiw	r24, 0x00	; 0
     e32:	51 f7       	brne	.-44     	; 0xe08 <scanForBlackDebris+0x114>
					if(coordinatesWithBlackDebris[i] == blackDebrisPos)
						return;  //if it is present then return before updating it
				}
				
				//if it is not present then update coordinatesWithBlackDebris with calculated position
				coordinatesWithBlackDebris[blackDebrisCounter] = blackDebrisPos;
     e34:	e0 91 5c 06 	lds	r30, 0x065C
     e38:	f0 91 5d 06 	lds	r31, 0x065D
     e3c:	ee 0f       	add	r30, r30
     e3e:	ff 1f       	adc	r31, r31
     e40:	e2 50       	subi	r30, 0x02	; 2
     e42:	fa 4f       	sbci	r31, 0xFA	; 250
     e44:	71 83       	std	Z+1, r23	; 0x01
     e46:	60 83       	st	Z, r22
				cinfo[blackDebrisPos][4] = 1;  //update cinfo matrix
     e48:	f8 01       	movw	r30, r16
     e4a:	ee 0f       	add	r30, r30
     e4c:	ff 1f       	adc	r31, r31
     e4e:	c8 01       	movw	r24, r16
     e50:	88 0f       	add	r24, r24
     e52:	99 1f       	adc	r25, r25
     e54:	88 0f       	add	r24, r24
     e56:	99 1f       	adc	r25, r25
     e58:	88 0f       	add	r24, r24
     e5a:	99 1f       	adc	r25, r25
     e5c:	e8 0f       	add	r30, r24
     e5e:	f9 1f       	adc	r31, r25
     e60:	ea 5e       	subi	r30, 0xEA	; 234
     e62:	fd 4f       	sbci	r31, 0xFD	; 253
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	90 e0       	ldi	r25, 0x00	; 0
     e68:	91 87       	std	Z+9, r25	; 0x09
     e6a:	80 87       	std	Z+8, r24	; 0x08
				
				UDR0 = (char)blackDebrisPos;  //send calculated black debris coordinate to rescue robot
     e6c:	e6 ec       	ldi	r30, 0xC6	; 198
     e6e:	f0 e0       	ldi	r31, 0x00	; 0
     e70:	00 83       	st	Z, r16
     e72:	8f ef       	ldi	r24, 0xFF	; 255
     e74:	97 e4       	ldi	r25, 0x47	; 71
     e76:	01 97       	sbiw	r24, 0x01	; 1
     e78:	f1 f7       	brne	.-4      	; 0xe76 <scanForBlackDebris+0x182>
     e7a:	00 c0       	rjmp	.+0      	; 0xe7c <scanForBlackDebris+0x188>
     e7c:	00 00       	nop
				_delay_ms(5);  //wait for data to be sent
				UDR0 = 3;  //send end packet as 3 indicating previous data sent must be information about black debris position
     e7e:	83 e0       	ldi	r24, 0x03	; 3
     e80:	80 83       	st	Z, r24
     e82:	8f ef       	ldi	r24, 0xFF	; 255
     e84:	97 e4       	ldi	r25, 0x47	; 71
     e86:	01 97       	sbiw	r24, 0x01	; 1
     e88:	f1 f7       	brne	.-4      	; 0xe86 <scanForBlackDebris+0x192>
     e8a:	00 c0       	rjmp	.+0      	; 0xe8c <scanForBlackDebris+0x198>
     e8c:	00 00       	nop
				_delay_ms(5);  //wait for data to be sent
				blackDebrisCounter++;  //increment blackDebrisCounter for the next time use
     e8e:	80 91 5c 06 	lds	r24, 0x065C
     e92:	90 91 5d 06 	lds	r25, 0x065D
     e96:	01 96       	adiw	r24, 0x01	; 1
     e98:	90 93 5d 06 	sts	0x065D, r25
     e9c:	80 93 5c 06 	sts	0x065C, r24
			}				
		}
	}	
}
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	08 95       	ret

00000eaa <velocity>:
}

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     eaa:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     eae:	60 93 2a 01 	sts	0x012A, r22
}
     eb2:	08 95       	ret

00000eb4 <init_devices>:

//Initialize the devices
void init_devices (void)
{
 	cli(); //Clears the global interrupts
     eb4:	f8 94       	cli
	port_init();
     eb6:	0e 94 fa 05 	call	0xbf4	; 0xbf4 <port_init>
	adc_init();
     eba:	0e 94 3e 06 	call	0xc7c	; 0xc7c <adc_init>
	timer5_init();
     ebe:	0e 94 13 06 	call	0xc26	; 0xc26 <timer5_init>
	timer1_init();
     ec2:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <timer1_init>
	uart0_init();
     ec6:	0e 94 2e 06 	call	0xc5c	; 0xc5c <uart0_init>
	left_position_encoder_interrupt_init();
     eca:	0e 94 c1 03 	call	0x782	; 0x782 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     ece:	0e 94 ca 03 	call	0x794	; 0x794 <right_position_encoder_interrupt_init>
	color_sensor_pin_interrupt_init();
     ed2:	0e 94 8a 03 	call	0x714	; 0x714 <color_sensor_pin_interrupt_init>
	sei();   //Enables the global interrupts
     ed6:	78 94       	sei
}
     ed8:	08 95       	ret

00000eda <buzzer_on>:


void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     eda:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
     edc:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     ede:	88 b9       	out	0x08, r24	; 8
}
     ee0:	08 95       	ret

00000ee2 <buzzer_off>:

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     ee2:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
     ee4:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     ee6:	88 b9       	out	0x08, r24	; 8
}
     ee8:	08 95       	ret

00000eea <turn_left>:
*				     comes on the black line
* Example Call:	  turn_left();
*
*/
void turn_left(unsigned int deg)
{
     eea:	cf 93       	push	r28
     eec:	df 93       	push	r29
     eee:	ec 01       	movw	r28, r24
	velocity(255, 255);
     ef0:	8f ef       	ldi	r24, 0xFF	; 255
     ef2:	6f ef       	ldi	r22, 0xFF	; 255
     ef4:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
	left_degrees(deg); //turn left by degree specified
     ef8:	ce 01       	movw	r24, r28
     efa:	0e 94 d3 05 	call	0xba6	; 0xba6 <left_degrees>
	Center_white_line = ADC_Conversion(2); //take readings of white line sensor
     efe:	82 e0       	ldi	r24, 0x02	; 2
     f00:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f04:	80 93 69 06 	sts	0x0669, r24
	if(Center_white_line < 70) //check if center white line sensor is on black line or not
     f08:	86 34       	cpi	r24, 0x46	; 70
     f0a:	80 f4       	brcc	.+32     	; 0xf2c <turn_left+0x42>
	{
		left(); //if center white line is not on black line then turn left
     f0c:	0e 94 09 05 	call	0xa12	; 0xa12 <left>
		Center_white_line = ADC_Conversion(2); //take readings of white line sensor
     f10:	82 e0       	ldi	r24, 0x02	; 2
     f12:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f16:	80 93 69 06 	sts	0x0669, r24
		while (Center_white_line < 70) //keep turning left while center white line does not come on black line
     f1a:	86 34       	cpi	r24, 0x46	; 70
     f1c:	38 f4       	brcc	.+14     	; 0xf2c <turn_left+0x42>
			Center_white_line = ADC_Conversion(2); //while turning keep checking the white line sensor
     f1e:	82 e0       	ldi	r24, 0x02	; 2
     f20:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f24:	80 93 69 06 	sts	0x0669, r24
	Center_white_line = ADC_Conversion(2); //take readings of white line sensor
	if(Center_white_line < 70) //check if center white line sensor is on black line or not
	{
		left(); //if center white line is not on black line then turn left
		Center_white_line = ADC_Conversion(2); //take readings of white line sensor
		while (Center_white_line < 70) //keep turning left while center white line does not come on black line
     f28:	86 34       	cpi	r24, 0x46	; 70
     f2a:	c8 f3       	brcs	.-14     	; 0xf1e <turn_left+0x34>
     f2c:	82 e3       	ldi	r24, 0x32	; 50
     f2e:	93 eb       	ldi	r25, 0xB3	; 179
     f30:	a2 e0       	ldi	r26, 0x02	; 2
     f32:	81 50       	subi	r24, 0x01	; 1
     f34:	90 40       	sbci	r25, 0x00	; 0
     f36:	a0 40       	sbci	r26, 0x00	; 0
     f38:	e1 f7       	brne	.-8      	; 0xf32 <turn_left+0x48>
     f3a:	00 c0       	rjmp	.+0      	; 0xf3c <turn_left+0x52>
     f3c:	00 c0       	rjmp	.+0      	; 0xf3e <turn_left+0x54>
			Center_white_line = ADC_Conversion(2); //while turning keep checking the white line sensor
	}
	_delay_ms(60); //wait for some time
	stop(); //stop after turning left
     f3e:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
}
     f42:	df 91       	pop	r29
     f44:	cf 91       	pop	r28
     f46:	08 95       	ret

00000f48 <turn_right>:
*				     comes on the black line
* Example Call:	  turn_right();
*
*/
void turn_right(unsigned int deg)
{
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
     f4c:	ec 01       	movw	r28, r24
	velocity(255, 255);
     f4e:	8f ef       	ldi	r24, 0xFF	; 255
     f50:	6f ef       	ldi	r22, 0xFF	; 255
     f52:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
	right_degrees(deg); //turn right by degree specified
     f56:	ce 01       	movw	r24, r28
     f58:	0e 94 de 05 	call	0xbbc	; 0xbbc <right_degrees>
	Center_white_line = ADC_Conversion(2); //take readings of white line sensor
     f5c:	82 e0       	ldi	r24, 0x02	; 2
     f5e:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f62:	80 93 69 06 	sts	0x0669, r24
	if(Center_white_line < 70) //check if center white line sensor is on black line or not
     f66:	86 34       	cpi	r24, 0x46	; 70
     f68:	80 f4       	brcc	.+32     	; 0xf8a <turn_right+0x42>
	{
		right(); //if center white line is not on black line then turn right
     f6a:	0e 94 0d 05 	call	0xa1a	; 0xa1a <right>
		Center_white_line = ADC_Conversion(2); //take readings of white line sensor
     f6e:	82 e0       	ldi	r24, 0x02	; 2
     f70:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f74:	80 93 69 06 	sts	0x0669, r24
		while (Center_white_line < 70) //keep turning right while center white line does not come on black line
     f78:	86 34       	cpi	r24, 0x46	; 70
     f7a:	38 f4       	brcc	.+14     	; 0xf8a <turn_right+0x42>
			Center_white_line = ADC_Conversion(2); //while turning keep checking the white line sensor
     f7c:	82 e0       	ldi	r24, 0x02	; 2
     f7e:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
     f82:	80 93 69 06 	sts	0x0669, r24
	Center_white_line = ADC_Conversion(2); //take readings of white line sensor
	if(Center_white_line < 70) //check if center white line sensor is on black line or not
	{
		right(); //if center white line is not on black line then turn right
		Center_white_line = ADC_Conversion(2); //take readings of white line sensor
		while (Center_white_line < 70) //keep turning right while center white line does not come on black line
     f86:	86 34       	cpi	r24, 0x46	; 70
     f88:	c8 f3       	brcs	.-14     	; 0xf7c <turn_right+0x34>
     f8a:	82 e3       	ldi	r24, 0x32	; 50
     f8c:	93 eb       	ldi	r25, 0xB3	; 179
     f8e:	a2 e0       	ldi	r26, 0x02	; 2
     f90:	81 50       	subi	r24, 0x01	; 1
     f92:	90 40       	sbci	r25, 0x00	; 0
     f94:	a0 40       	sbci	r26, 0x00	; 0
     f96:	e1 f7       	brne	.-8      	; 0xf90 <turn_right+0x48>
     f98:	00 c0       	rjmp	.+0      	; 0xf9a <turn_right+0x52>
     f9a:	00 c0       	rjmp	.+0      	; 0xf9c <turn_right+0x54>
			Center_white_line = ADC_Conversion(2); //while turning keep checking the white line sensor
	}
	_delay_ms(60); //wait for some time
	stop(); //stop after turning right
     f9c:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
}
     fa0:	df 91       	pop	r29
     fa2:	cf 91       	pop	r28
     fa4:	08 95       	ret

00000fa6 <isValidNode>:
*				 4) If both the above conditions are false then node_coordinate is valid and return 1
* Example Call:	 isValidNode(85);
*
*/
int isValidNode(int node_coordinate)
{
     fa6:	9c 01       	movw	r18, r24
	int x, y;
	x = node_coordinate % 10; //extract x coordinate
     fa8:	6a e0       	ldi	r22, 0x0A	; 10
     faa:	70 e0       	ldi	r23, 0x00	; 0
     fac:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
     fb0:	e8 2f       	mov	r30, r24
     fb2:	f9 2f       	mov	r31, r25
	y = node_coordinate / 10; //extract y coordinate
	
	//If both are event means its a plot coordinate then return 0
	if(x % 2 == 0 && y % 2 == 0)
     fb4:	80 fd       	sbrc	r24, 0
     fb6:	07 c0       	rjmp	.+14     	; 0xfc6 <isValidNode+0x20>
*/
int isValidNode(int node_coordinate)
{
	int x, y;
	x = node_coordinate % 10; //extract x coordinate
	y = node_coordinate / 10; //extract y coordinate
     fb8:	c9 01       	movw	r24, r18
     fba:	6a e0       	ldi	r22, 0x0A	; 10
     fbc:	70 e0       	ldi	r23, 0x00	; 0
     fbe:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
	
	//If both are event means its a plot coordinate then return 0
	if(x % 2 == 0 && y % 2 == 0)
     fc2:	60 ff       	sbrs	r22, 0
     fc4:	0c c0       	rjmp	.+24     	; 0xfde <isValidNode+0x38>
		return 0;
		
	//if it is less then 11 or greater then 99 or its a multiple of 10 then passed coordinate is not part of arena then return 0
	if((node_coordinate % 10 == 0) || (node_coordinate < 11 || node_coordinate > 99))
     fc6:	30 97       	sbiw	r30, 0x00	; 0
     fc8:	69 f0       	breq	.+26     	; 0xfe4 <isValidNode+0x3e>
     fca:	2b 50       	subi	r18, 0x0B	; 11
     fcc:	30 40       	sbci	r19, 0x00	; 0
	x = node_coordinate % 10; //extract x coordinate
	y = node_coordinate / 10; //extract y coordinate
	
	//If both are event means its a plot coordinate then return 0
	if(x % 2 == 0 && y % 2 == 0)
		return 0;
     fce:	81 e0       	ldi	r24, 0x01	; 1
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	29 35       	cpi	r18, 0x59	; 89
     fd4:	31 05       	cpc	r19, r1
     fd6:	40 f0       	brcs	.+16     	; 0xfe8 <isValidNode+0x42>
     fd8:	80 e0       	ldi	r24, 0x00	; 0
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	08 95       	ret
     fde:	80 e0       	ldi	r24, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	08 95       	ret
		
	//if it is less then 11 or greater then 99 or its a multiple of 10 then passed coordinate is not part of arena then return 0
	if((node_coordinate % 10 == 0) || (node_coordinate < 11 || node_coordinate > 99))
		return 0;
     fe4:	80 e0       	ldi	r24, 0x00	; 0
     fe6:	90 e0       	ldi	r25, 0x00	; 0
	
	//if above both the conditions are false then passed coordinate is valid so return 1
	return 1;
}
     fe8:	08 95       	ret

00000fea <isPlotValid>:
*				 3) If above condition are false then plot_coordinate is valid and return 1
* Example Call:	 isPlotValid(22);
*
*/
int isPlotValid(int plot_coordinate)
{
     fea:	9c 01       	movw	r18, r24
	//if it is less then 11 or greater then 99 or its a multiple of 10 then passed coordinate is not part of arena then return 0
	if(plot_coordinate % 10 == 0 || plot_coordinate < 11 || plot_coordinate > 99)
     fec:	6a e0       	ldi	r22, 0x0A	; 10
     fee:	70 e0       	ldi	r23, 0x00	; 0
     ff0:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
     ff4:	00 97       	sbiw	r24, 0x00	; 0
     ff6:	59 f0       	breq	.+22     	; 0x100e <isPlotValid+0x24>
     ff8:	2b 30       	cpi	r18, 0x0B	; 11
     ffa:	31 05       	cpc	r19, r1
     ffc:	5c f0       	brlt	.+22     	; 0x1014 <isPlotValid+0x2a>
		return 0;
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	24 36       	cpi	r18, 0x64	; 100
    1004:	31 05       	cpc	r19, r1
    1006:	44 f0       	brlt	.+16     	; 0x1018 <isPlotValid+0x2e>
    1008:	80 e0       	ldi	r24, 0x00	; 0
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	08 95       	ret
    100e:	80 e0       	ldi	r24, 0x00	; 0
    1010:	90 e0       	ldi	r25, 0x00	; 0
    1012:	08 95       	ret
    1014:	80 e0       	ldi	r24, 0x00	; 0
    1016:	90 e0       	ldi	r25, 0x00	; 0
	else
		return 1;
}
    1018:	08 95       	ret

0000101a <init_cinfo_matrix>:
*                
* Example Call:	  init_cinfo_matrix();
*
*/
void init_cinfo_matrix()
{
    101a:	8f 92       	push	r8
    101c:	9f 92       	push	r9
    101e:	af 92       	push	r10
    1020:	bf 92       	push	r11
    1022:	cf 92       	push	r12
    1024:	df 92       	push	r13
    1026:	ef 92       	push	r14
    1028:	ff 92       	push	r15
    102a:	0f 93       	push	r16
    102c:	1f 93       	push	r17
    102e:	cf 93       	push	r28
    1030:	df 93       	push	r29
    1032:	0f 2e       	mov	r0, r31
    1034:	f5 e1       	ldi	r31, 0x15	; 21
    1036:	ef 2e       	mov	r14, r31
    1038:	ff 24       	eor	r15, r15
    103a:	f0 2d       	mov	r31, r0
    103c:	cc 24       	eor	r12, r12
    103e:	dd 24       	eor	r13, r13
    1040:	c3 94       	inc	r12
    1042:	0f 2e       	mov	r0, r31
    1044:	fa e0       	ldi	r31, 0x0A	; 10
    1046:	af 2e       	mov	r10, r31
    1048:	bb 24       	eor	r11, r11
    104a:	f0 2d       	mov	r31, r0
    104c:	0c e0       	ldi	r16, 0x0C	; 12
    104e:	10 e0       	ldi	r17, 0x00	; 0
			if(isValidNode(temp))  //temp shall hold the node to the west which shall be the N-1
			cinfo[i][j+3] = temp; //checks if the node to west is valid or not
			else
			cinfo[i][j+3] = 0;  //if node is invalid then it shall be zero
			
			cinfo[i][j+4] = 0; //initially all the coordinates are set as unblocked by BLACK DERBIS
    1050:	0f 2e       	mov	r0, r31
    1052:	f6 e1       	ldi	r31, 0x16	; 22
    1054:	8f 2e       	mov	r8, r31
    1056:	f2 e0       	ldi	r31, 0x02	; 2
    1058:	9f 2e       	mov	r9, r31
    105a:	f0 2d       	mov	r31, r0
*				  5) the entry at the 4th position shall be 0 for all vertices i.e initially all co-ordinates shall be UNBLOCKED
*                
* Example Call:	  init_cinfo_matrix();
*
*/
void init_cinfo_matrix()
    105c:	e8 01       	movw	r28, r16
    105e:	21 97       	sbiw	r28, 0x01	; 1
{
	int i, j, temp;
	for(i = 11; i <= 99; i++)
	{
		if(isValidNode(i))
    1060:	ce 01       	movw	r24, r28
    1062:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <isValidNode>
    1066:	00 97       	sbiw	r24, 0x00	; 0
    1068:	09 f4       	brne	.+2      	; 0x106c <init_cinfo_matrix+0x52>
    106a:	b1 c0       	rjmp	.+354    	; 0x11ce <init_cinfo_matrix+0x1b4>
		{
			//for j value  0 = north, 1 = east, 2 = south, 3 = west, 4 = black debris present or not
			j = 0;
			temp = i + 10;   //temp shall hold the node to the north which shall be the N+10
			if(isValidNode(temp))  //checks if the node to north is valid or not
    106c:	c7 01       	movw	r24, r14
    106e:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <isValidNode>
    1072:	00 97       	sbiw	r24, 0x00	; 0
    1074:	91 f0       	breq	.+36     	; 0x109a <init_cinfo_matrix+0x80>
			cinfo[i][j] = temp;
    1076:	ce 01       	movw	r24, r28
    1078:	88 0f       	add	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	9e 01       	movw	r18, r28
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	22 0f       	add	r18, r18
    1088:	33 1f       	adc	r19, r19
    108a:	82 0f       	add	r24, r18
    108c:	93 1f       	adc	r25, r19
    108e:	88 0d       	add	r24, r8
    1090:	99 1d       	adc	r25, r9
    1092:	fc 01       	movw	r30, r24
    1094:	f1 82       	std	Z+1, r15	; 0x01
    1096:	e0 82       	st	Z, r14
    1098:	11 c0       	rjmp	.+34     	; 0x10bc <init_cinfo_matrix+0xa2>
			else
			cinfo[i][j] = 0; //if node is invalid then it shall be zero
    109a:	ce 01       	movw	r24, r28
    109c:	88 0f       	add	r24, r24
    109e:	99 1f       	adc	r25, r25
    10a0:	9e 01       	movw	r18, r28
    10a2:	22 0f       	add	r18, r18
    10a4:	33 1f       	adc	r19, r19
    10a6:	22 0f       	add	r18, r18
    10a8:	33 1f       	adc	r19, r19
    10aa:	22 0f       	add	r18, r18
    10ac:	33 1f       	adc	r19, r19
    10ae:	82 0f       	add	r24, r18
    10b0:	93 1f       	adc	r25, r19
    10b2:	88 0d       	add	r24, r8
    10b4:	99 1d       	adc	r25, r9
    10b6:	fc 01       	movw	r30, r24
    10b8:	11 82       	std	Z+1, r1	; 0x01
    10ba:	10 82       	st	Z, r1

			temp = i + 1;
			if(isValidNode(temp))  //temp shall hold the node to the east which shall be the N+1
    10bc:	c8 01       	movw	r24, r16
    10be:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <isValidNode>
    10c2:	00 97       	sbiw	r24, 0x00	; 0
    10c4:	91 f0       	breq	.+36     	; 0x10ea <init_cinfo_matrix+0xd0>
			cinfo[i][j+1] = temp; //checks if the node to east is valid or not
    10c6:	ce 01       	movw	r24, r28
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	9e 01       	movw	r18, r28
    10ce:	22 0f       	add	r18, r18
    10d0:	33 1f       	adc	r19, r19
    10d2:	22 0f       	add	r18, r18
    10d4:	33 1f       	adc	r19, r19
    10d6:	22 0f       	add	r18, r18
    10d8:	33 1f       	adc	r19, r19
    10da:	82 0f       	add	r24, r18
    10dc:	93 1f       	adc	r25, r19
    10de:	88 0d       	add	r24, r8
    10e0:	99 1d       	adc	r25, r9
    10e2:	fc 01       	movw	r30, r24
    10e4:	13 83       	std	Z+3, r17	; 0x03
    10e6:	02 83       	std	Z+2, r16	; 0x02
    10e8:	11 c0       	rjmp	.+34     	; 0x110c <init_cinfo_matrix+0xf2>
			else
			cinfo[i][j+1] = 0;  //if node is invalid then it shall be zero
    10ea:	ce 01       	movw	r24, r28
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	9e 01       	movw	r18, r28
    10f2:	22 0f       	add	r18, r18
    10f4:	33 1f       	adc	r19, r19
    10f6:	22 0f       	add	r18, r18
    10f8:	33 1f       	adc	r19, r19
    10fa:	22 0f       	add	r18, r18
    10fc:	33 1f       	adc	r19, r19
    10fe:	82 0f       	add	r24, r18
    1100:	93 1f       	adc	r25, r19
    1102:	88 0d       	add	r24, r8
    1104:	99 1d       	adc	r25, r9
    1106:	fc 01       	movw	r30, r24
    1108:	13 82       	std	Z+3, r1	; 0x03
    110a:	12 82       	std	Z+2, r1	; 0x02

			temp = i - 10;
			if(isValidNode(temp))  //temp shall hold the node to the south which shall be the N-10
    110c:	c6 01       	movw	r24, r12
    110e:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <isValidNode>
    1112:	00 97       	sbiw	r24, 0x00	; 0
    1114:	91 f0       	breq	.+36     	; 0x113a <init_cinfo_matrix+0x120>
			cinfo[i][j+2] = temp;  //checks if the node to south is valid or not
    1116:	ce 01       	movw	r24, r28
    1118:	88 0f       	add	r24, r24
    111a:	99 1f       	adc	r25, r25
    111c:	9e 01       	movw	r18, r28
    111e:	22 0f       	add	r18, r18
    1120:	33 1f       	adc	r19, r19
    1122:	22 0f       	add	r18, r18
    1124:	33 1f       	adc	r19, r19
    1126:	22 0f       	add	r18, r18
    1128:	33 1f       	adc	r19, r19
    112a:	82 0f       	add	r24, r18
    112c:	93 1f       	adc	r25, r19
    112e:	88 0d       	add	r24, r8
    1130:	99 1d       	adc	r25, r9
    1132:	fc 01       	movw	r30, r24
    1134:	d5 82       	std	Z+5, r13	; 0x05
    1136:	c4 82       	std	Z+4, r12	; 0x04
    1138:	11 c0       	rjmp	.+34     	; 0x115c <init_cinfo_matrix+0x142>
			else
			cinfo[i][j+2] = 0;  //if node is invalid then it shall be zero
    113a:	ce 01       	movw	r24, r28
    113c:	88 0f       	add	r24, r24
    113e:	99 1f       	adc	r25, r25
    1140:	9e 01       	movw	r18, r28
    1142:	22 0f       	add	r18, r18
    1144:	33 1f       	adc	r19, r19
    1146:	22 0f       	add	r18, r18
    1148:	33 1f       	adc	r19, r19
    114a:	22 0f       	add	r18, r18
    114c:	33 1f       	adc	r19, r19
    114e:	82 0f       	add	r24, r18
    1150:	93 1f       	adc	r25, r19
    1152:	88 0d       	add	r24, r8
    1154:	99 1d       	adc	r25, r9
    1156:	fc 01       	movw	r30, r24
    1158:	15 82       	std	Z+5, r1	; 0x05
    115a:	14 82       	std	Z+4, r1	; 0x04

			temp = i - 1;
			if(isValidNode(temp))  //temp shall hold the node to the west which shall be the N-1
    115c:	c5 01       	movw	r24, r10
    115e:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <isValidNode>
    1162:	00 97       	sbiw	r24, 0x00	; 0
    1164:	91 f0       	breq	.+36     	; 0x118a <init_cinfo_matrix+0x170>
			cinfo[i][j+3] = temp; //checks if the node to west is valid or not
    1166:	ce 01       	movw	r24, r28
    1168:	88 0f       	add	r24, r24
    116a:	99 1f       	adc	r25, r25
    116c:	9e 01       	movw	r18, r28
    116e:	22 0f       	add	r18, r18
    1170:	33 1f       	adc	r19, r19
    1172:	22 0f       	add	r18, r18
    1174:	33 1f       	adc	r19, r19
    1176:	22 0f       	add	r18, r18
    1178:	33 1f       	adc	r19, r19
    117a:	82 0f       	add	r24, r18
    117c:	93 1f       	adc	r25, r19
    117e:	88 0d       	add	r24, r8
    1180:	99 1d       	adc	r25, r9
    1182:	fc 01       	movw	r30, r24
    1184:	b7 82       	std	Z+7, r11	; 0x07
    1186:	a6 82       	std	Z+6, r10	; 0x06
    1188:	11 c0       	rjmp	.+34     	; 0x11ac <init_cinfo_matrix+0x192>
			else
			cinfo[i][j+3] = 0;  //if node is invalid then it shall be zero
    118a:	ce 01       	movw	r24, r28
    118c:	88 0f       	add	r24, r24
    118e:	99 1f       	adc	r25, r25
    1190:	9e 01       	movw	r18, r28
    1192:	22 0f       	add	r18, r18
    1194:	33 1f       	adc	r19, r19
    1196:	22 0f       	add	r18, r18
    1198:	33 1f       	adc	r19, r19
    119a:	22 0f       	add	r18, r18
    119c:	33 1f       	adc	r19, r19
    119e:	82 0f       	add	r24, r18
    11a0:	93 1f       	adc	r25, r19
    11a2:	88 0d       	add	r24, r8
    11a4:	99 1d       	adc	r25, r9
    11a6:	fc 01       	movw	r30, r24
    11a8:	17 82       	std	Z+7, r1	; 0x07
    11aa:	16 82       	std	Z+6, r1	; 0x06
			
			cinfo[i][j+4] = 0; //initially all the coordinates are set as unblocked by BLACK DERBIS
    11ac:	9e 01       	movw	r18, r28
    11ae:	22 0f       	add	r18, r18
    11b0:	33 1f       	adc	r19, r19
    11b2:	ce 01       	movw	r24, r28
    11b4:	88 0f       	add	r24, r24
    11b6:	99 1f       	adc	r25, r25
    11b8:	88 0f       	add	r24, r24
    11ba:	99 1f       	adc	r25, r25
    11bc:	88 0f       	add	r24, r24
    11be:	99 1f       	adc	r25, r25
    11c0:	82 0f       	add	r24, r18
    11c2:	93 1f       	adc	r25, r19
    11c4:	88 0d       	add	r24, r8
    11c6:	99 1d       	adc	r25, r9
    11c8:	fc 01       	movw	r30, r24
    11ca:	11 86       	std	Z+9, r1	; 0x09
    11cc:	10 86       	std	Z+8, r1	; 0x08
    11ce:	0f 5f       	subi	r16, 0xFF	; 255
    11d0:	1f 4f       	sbci	r17, 0xFF	; 255
    11d2:	08 94       	sec
    11d4:	a1 1c       	adc	r10, r1
    11d6:	b1 1c       	adc	r11, r1
    11d8:	08 94       	sec
    11da:	c1 1c       	adc	r12, r1
    11dc:	d1 1c       	adc	r13, r1
    11de:	08 94       	sec
    11e0:	e1 1c       	adc	r14, r1
    11e2:	f1 1c       	adc	r15, r1
*
*/
void init_cinfo_matrix()
{
	int i, j, temp;
	for(i = 11; i <= 99; i++)
    11e4:	05 36       	cpi	r16, 0x65	; 101
    11e6:	11 05       	cpc	r17, r1
    11e8:	09 f0       	breq	.+2      	; 0x11ec <init_cinfo_matrix+0x1d2>
    11ea:	38 cf       	rjmp	.-400    	; 0x105c <init_cinfo_matrix+0x42>
			cinfo[i][j+3] = 0;  //if node is invalid then it shall be zero
			
			cinfo[i][j+4] = 0; //initially all the coordinates are set as unblocked by BLACK DERBIS
		}
	}
}
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	1f 91       	pop	r17
    11f2:	0f 91       	pop	r16
    11f4:	ff 90       	pop	r15
    11f6:	ef 90       	pop	r14
    11f8:	df 90       	pop	r13
    11fa:	cf 90       	pop	r12
    11fc:	bf 90       	pop	r11
    11fe:	af 90       	pop	r10
    1200:	9f 90       	pop	r9
    1202:	8f 90       	pop	r8
    1204:	08 95       	ret

00001206 <change_location>:
*
* Example Call: change_location();
*
*/
void change_location(){
	int x=current_pos%10;  //x bit is obtained
    1206:	80 91 9b 06 	lds	r24, 0x069B
    120a:	90 91 9c 06 	lds	r25, 0x069C
    120e:	6a e0       	ldi	r22, 0x0A	; 10
    1210:	70 e0       	ldi	r23, 0x00	; 0
    1212:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    1216:	ac 01       	movw	r20, r24
	int y=current_pos/10;  //y-bit is obtained
	if (orientation==point_north)//if orientation is north
    1218:	80 91 95 06 	lds	r24, 0x0695
    121c:	90 91 96 06 	lds	r25, 0x0696
    1220:	20 91 9d 06 	lds	r18, 0x069D
    1224:	30 91 9e 06 	lds	r19, 0x069E
    1228:	82 17       	cp	r24, r18
    122a:	93 07       	cpc	r25, r19
    122c:	a1 f4       	brne	.+40     	; 0x1256 <change_location+0x50>
	{
		y++; //co-ordinate changed in positive y direction
    122e:	6f 5f       	subi	r22, 0xFF	; 255
    1230:	7f 4f       	sbci	r23, 0xFF	; 255
		current_pos=y*10+x;
    1232:	cb 01       	movw	r24, r22
    1234:	88 0f       	add	r24, r24
    1236:	99 1f       	adc	r25, r25
    1238:	66 0f       	add	r22, r22
    123a:	77 1f       	adc	r23, r23
    123c:	66 0f       	add	r22, r22
    123e:	77 1f       	adc	r23, r23
    1240:	66 0f       	add	r22, r22
    1242:	77 1f       	adc	r23, r23
    1244:	86 0f       	add	r24, r22
    1246:	97 1f       	adc	r25, r23
    1248:	48 0f       	add	r20, r24
    124a:	59 1f       	adc	r21, r25
    124c:	50 93 9c 06 	sts	0x069C, r21
    1250:	40 93 9b 06 	sts	0x069B, r20
    1254:	08 95       	ret
	}
	else if (orientation==point_west)//if orientation is west
    1256:	20 91 10 02 	lds	r18, 0x0210
    125a:	30 91 11 02 	lds	r19, 0x0211
    125e:	82 17       	cp	r24, r18
    1260:	93 07       	cpc	r25, r19
    1262:	a1 f4       	brne	.+40     	; 0x128c <change_location+0x86>
	{
		x--; //co-ordinate changed in negative x direction
		current_pos=y*10+x;
    1264:	cb 01       	movw	r24, r22
    1266:	88 0f       	add	r24, r24
    1268:	99 1f       	adc	r25, r25
    126a:	66 0f       	add	r22, r22
    126c:	77 1f       	adc	r23, r23
    126e:	66 0f       	add	r22, r22
    1270:	77 1f       	adc	r23, r23
    1272:	66 0f       	add	r22, r22
    1274:	77 1f       	adc	r23, r23
    1276:	86 0f       	add	r24, r22
    1278:	97 1f       	adc	r25, r23
		y++; //co-ordinate changed in positive y direction
		current_pos=y*10+x;
	}
	else if (orientation==point_west)//if orientation is west
	{
		x--; //co-ordinate changed in negative x direction
    127a:	41 50       	subi	r20, 0x01	; 1
    127c:	50 40       	sbci	r21, 0x00	; 0
		current_pos=y*10+x;
    127e:	84 0f       	add	r24, r20
    1280:	95 1f       	adc	r25, r21
    1282:	90 93 9c 06 	sts	0x069C, r25
    1286:	80 93 9b 06 	sts	0x069B, r24
    128a:	08 95       	ret
	}
	else if (orientation==point_east)//if orientation is east
    128c:	20 91 14 02 	lds	r18, 0x0214
    1290:	30 91 15 02 	lds	r19, 0x0215
    1294:	82 17       	cp	r24, r18
    1296:	93 07       	cpc	r25, r19
    1298:	a1 f4       	brne	.+40     	; 0x12c2 <change_location+0xbc>
	{
		x++; //co-ordinate changed in positive x direction
		current_pos=y*10+x;
    129a:	cb 01       	movw	r24, r22
    129c:	88 0f       	add	r24, r24
    129e:	99 1f       	adc	r25, r25
    12a0:	66 0f       	add	r22, r22
    12a2:	77 1f       	adc	r23, r23
    12a4:	66 0f       	add	r22, r22
    12a6:	77 1f       	adc	r23, r23
    12a8:	66 0f       	add	r22, r22
    12aa:	77 1f       	adc	r23, r23
    12ac:	86 0f       	add	r24, r22
    12ae:	97 1f       	adc	r25, r23
		x--; //co-ordinate changed in negative x direction
		current_pos=y*10+x;
	}
	else if (orientation==point_east)//if orientation is east
	{
		x++; //co-ordinate changed in positive x direction
    12b0:	4f 5f       	subi	r20, 0xFF	; 255
    12b2:	5f 4f       	sbci	r21, 0xFF	; 255
		current_pos=y*10+x;
    12b4:	84 0f       	add	r24, r20
    12b6:	95 1f       	adc	r25, r21
    12b8:	90 93 9c 06 	sts	0x069C, r25
    12bc:	80 93 9b 06 	sts	0x069B, r24
    12c0:	08 95       	ret
	}
	else if(orientation==point_south){ //if orientation is south
    12c2:	20 91 12 02 	lds	r18, 0x0212
    12c6:	30 91 13 02 	lds	r19, 0x0213
    12ca:	82 17       	cp	r24, r18
    12cc:	93 07       	cpc	r25, r19
    12ce:	99 f4       	brne	.+38     	; 0x12f6 <change_location+0xf0>
	y--;  //co-ordinate changed in negative y direction
    12d0:	61 50       	subi	r22, 0x01	; 1
    12d2:	70 40       	sbci	r23, 0x00	; 0
	current_pos=y*10+x;
    12d4:	cb 01       	movw	r24, r22
    12d6:	88 0f       	add	r24, r24
    12d8:	99 1f       	adc	r25, r25
    12da:	66 0f       	add	r22, r22
    12dc:	77 1f       	adc	r23, r23
    12de:	66 0f       	add	r22, r22
    12e0:	77 1f       	adc	r23, r23
    12e2:	66 0f       	add	r22, r22
    12e4:	77 1f       	adc	r23, r23
    12e6:	86 0f       	add	r24, r22
    12e8:	97 1f       	adc	r25, r23
    12ea:	48 0f       	add	r20, r24
    12ec:	59 1f       	adc	r21, r25
    12ee:	50 93 9c 06 	sts	0x069C, r21
    12f2:	40 93 9b 06 	sts	0x069B, r20
    12f6:	08 95       	ret

000012f8 <findUnscannedPlot>:
* Example Call:	  findUnscannedPlot();
*
*/

int findUnscannedPlot()
{
    12f8:	ef 92       	push	r14
    12fa:	ff 92       	push	r15
    12fc:	0f 93       	push	r16
    12fe:	1f 93       	push	r17
    1300:	cf 93       	push	r28
    1302:	df 93       	push	r29
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
			{
				if(scannedPlot[i][j] == 0)
    1304:	eb e6       	ldi	r30, 0x6B	; 107
    1306:	f6 e0       	ldi	r31, 0x06	; 6
*/

int findUnscannedPlot()
{
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
    1308:	20 e0       	ldi	r18, 0x00	; 0
    130a:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
			{
				if(scannedPlot[i][j] == 0)
    130c:	bf 01       	movw	r22, r30
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
    130e:	0f ef       	ldi	r16, 0xFF	; 255
    1310:	1f ef       	ldi	r17, 0xFF	; 255
				}
			}
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
    1312:	ee 24       	eor	r14, r14
    1314:	ff 24       	eor	r15, r15
    1316:	68 94       	set
    1318:	e2 f8       	bld	r14, 2
int findUnscannedPlot()
{
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
    131a:	22 30       	cpi	r18, 0x02	; 2
    131c:	31 05       	cpc	r19, r1
    131e:	2c f0       	brlt	.+10     	; 0x132a <findUnscannedPlot+0x32>
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
			{
				if(scannedPlot[i][j] == 0)
    1320:	80 81       	ld	r24, Z
    1322:	91 81       	ldd	r25, Z+1	; 0x01
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	39 f5       	brne	.+78     	; 0x1376 <findUnscannedPlot+0x7e>
    1328:	6d c0       	rjmp	.+218    	; 0x1404 <findUnscannedPlot+0x10c>
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
			{
				if(scannedPlot[i][j] == 0)
    132a:	86 81       	ldd	r24, Z+6	; 0x06
    132c:	97 81       	ldd	r25, Z+7	; 0x07
    132e:	00 97       	sbiw	r24, 0x00	; 0
    1330:	09 f4       	brne	.+2      	; 0x1334 <findUnscannedPlot+0x3c>
    1332:	6b c0       	rjmp	.+214    	; 0x140a <findUnscannedPlot+0x112>
    1334:	c9 01       	movw	r24, r18
    1336:	88 0f       	add	r24, r24
    1338:	99 1f       	adc	r25, r25
    133a:	88 0f       	add	r24, r24
    133c:	99 1f       	adc	r25, r25
    133e:	88 0f       	add	r24, r24
    1340:	99 1f       	adc	r25, r25
    1342:	86 0f       	add	r24, r22
    1344:	97 1f       	adc	r25, r23
    1346:	dc 01       	movw	r26, r24
    1348:	14 96       	adiw	r26, 0x04	; 4
    134a:	8d 91       	ld	r24, X+
    134c:	9c 91       	ld	r25, X
    134e:	15 97       	sbiw	r26, 0x05	; 5
    1350:	00 97       	sbiw	r24, 0x00	; 0
    1352:	59 f0       	breq	.+22     	; 0x136a <findUnscannedPlot+0x72>
    1354:	82 81       	ldd	r24, Z+2	; 0x02
    1356:	93 81       	ldd	r25, Z+3	; 0x03
    1358:	00 97       	sbiw	r24, 0x00	; 0
    135a:	51 f0       	breq	.+20     	; 0x1370 <findUnscannedPlot+0x78>
    135c:	80 81       	ld	r24, Z
    135e:	91 81       	ldd	r25, Z+1	; 0x01
    1360:	00 97       	sbiw	r24, 0x00	; 0
    1362:	41 f5       	brne	.+80     	; 0x13b4 <findUnscannedPlot+0xbc>
    1364:	40 e0       	ldi	r20, 0x00	; 0
    1366:	50 e0       	ldi	r21, 0x00	; 0
    1368:	2f c0       	rjmp	.+94     	; 0x13c8 <findUnscannedPlot+0xd0>
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
    136a:	42 e0       	ldi	r20, 0x02	; 2
    136c:	50 e0       	ldi	r21, 0x00	; 0
    136e:	2c c0       	rjmp	.+88     	; 0x13c8 <findUnscannedPlot+0xd0>
    1370:	41 e0       	ldi	r20, 0x01	; 1
    1372:	50 e0       	ldi	r21, 0x00	; 0
    1374:	29 c0       	rjmp	.+82     	; 0x13c8 <findUnscannedPlot+0xd0>
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
			{
				if(scannedPlot[i][j] == 0)
    1376:	c9 01       	movw	r24, r18
    1378:	88 0f       	add	r24, r24
    137a:	99 1f       	adc	r25, r25
    137c:	88 0f       	add	r24, r24
    137e:	99 1f       	adc	r25, r25
    1380:	88 0f       	add	r24, r24
    1382:	99 1f       	adc	r25, r25
    1384:	86 0f       	add	r24, r22
    1386:	97 1f       	adc	r25, r23
    1388:	ec 01       	movw	r28, r24
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	9b 81       	ldd	r25, Y+3	; 0x03
    138e:	00 97       	sbiw	r24, 0x00	; 0
    1390:	59 f0       	breq	.+22     	; 0x13a8 <findUnscannedPlot+0xb0>
    1392:	84 81       	ldd	r24, Z+4	; 0x04
    1394:	95 81       	ldd	r25, Z+5	; 0x05
    1396:	00 97       	sbiw	r24, 0x00	; 0
    1398:	51 f0       	breq	.+20     	; 0x13ae <findUnscannedPlot+0xb6>
    139a:	86 81       	ldd	r24, Z+6	; 0x06
    139c:	97 81       	ldd	r25, Z+7	; 0x07
    139e:	00 97       	sbiw	r24, 0x00	; 0
    13a0:	59 f4       	brne	.+22     	; 0x13b8 <findUnscannedPlot+0xc0>
    13a2:	43 e0       	ldi	r20, 0x03	; 3
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	10 c0       	rjmp	.+32     	; 0x13c8 <findUnscannedPlot+0xd0>
				}
			}
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
    13a8:	41 e0       	ldi	r20, 0x01	; 1
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	0d c0       	rjmp	.+26     	; 0x13c8 <findUnscannedPlot+0xd0>
    13ae:	42 e0       	ldi	r20, 0x02	; 2
    13b0:	50 e0       	ldi	r21, 0x00	; 0
    13b2:	0a c0       	rjmp	.+20     	; 0x13c8 <findUnscannedPlot+0xd0>
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
    13b4:	a8 01       	movw	r20, r16
    13b6:	01 c0       	rjmp	.+2      	; 0x13ba <findUnscannedPlot+0xc2>
				}
			}
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
    13b8:	a7 01       	movw	r20, r14
*/

int findUnscannedPlot()
{
	int flag = 0, i, j, x, y, plot;
	for(i = 0; i < 4; i++)  //loop shall iterate from row 0 to 4 
    13ba:	2f 5f       	subi	r18, 0xFF	; 255
    13bc:	3f 4f       	sbci	r19, 0xFF	; 255
    13be:	38 96       	adiw	r30, 0x08	; 8
    13c0:	24 30       	cpi	r18, 0x04	; 4
    13c2:	31 05       	cpc	r19, r1
    13c4:	09 f0       	breq	.+2      	; 0x13c8 <findUnscannedPlot+0xd0>
    13c6:	a9 cf       	rjmp	.-174    	; 0x131a <findUnscannedPlot+0x22>
			break;
	}
	
	//in the following code plot coordinate is computed from the values of i and j
	//eg. if i=0 and j=3 then survivor plot coordinate shall be x=0*2+2=2 and y=3*2+2=8 so that yx is  8*10+2=82
	y = i * 2 + 2;
    13c8:	2f 5f       	subi	r18, 0xFF	; 255
    13ca:	3f 4f       	sbci	r19, 0xFF	; 255
    13cc:	22 0f       	add	r18, r18
    13ce:	33 1f       	adc	r19, r19
	x = j * 2 + 2;
	plot = y * 10 + x;
    13d0:	b9 01       	movw	r22, r18
    13d2:	66 0f       	add	r22, r22
    13d4:	77 1f       	adc	r23, r23
    13d6:	c9 01       	movw	r24, r18
    13d8:	88 0f       	add	r24, r24
    13da:	99 1f       	adc	r25, r25
    13dc:	88 0f       	add	r24, r24
    13de:	99 1f       	adc	r25, r25
    13e0:	88 0f       	add	r24, r24
    13e2:	99 1f       	adc	r25, r25
    13e4:	68 0f       	add	r22, r24
    13e6:	79 1f       	adc	r23, r25
	}
	
	//in the following code plot coordinate is computed from the values of i and j
	//eg. if i=0 and j=3 then survivor plot coordinate shall be x=0*2+2=2 and y=3*2+2=8 so that yx is  8*10+2=82
	y = i * 2 + 2;
	x = j * 2 + 2;
    13e8:	4f 5f       	subi	r20, 0xFF	; 255
    13ea:	5f 4f       	sbci	r21, 0xFF	; 255
    13ec:	ca 01       	movw	r24, r20
    13ee:	88 0f       	add	r24, r24
    13f0:	99 1f       	adc	r25, r25
	plot = y * 10 + x;
    13f2:	86 0f       	add	r24, r22
    13f4:	97 1f       	adc	r25, r23
	return plot;
}
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	08 95       	ret
		}			
		else //if the row index is greater than 1 (i.e for upper 2 rows of survivor plots) then the arena shall be scanned from right to left
		{
			for(j = 0; j < 4; j++)//as scan is from left to right column shall change as j=0 to j=3
			{
				if(scannedPlot[i][j] == 0)
    1404:	40 e0       	ldi	r20, 0x00	; 0
    1406:	50 e0       	ldi	r21, 0x00	; 0
    1408:	df cf       	rjmp	.-66     	; 0x13c8 <findUnscannedPlot+0xd0>
	{
		if(i < 2) //if the row index is less than 2 (i.e for lower 2 rows of survivor plots) then the arena arena shall be scanned from right to left
		{
			for(j = 3; j >= 0; j--)//as scan is from right to left column shall change as j=3 to j=0
			{
				if(scannedPlot[i][j] == 0)
    140a:	43 e0       	ldi	r20, 0x03	; 3
    140c:	50 e0       	ldi	r21, 0x00	; 0
    140e:	dc cf       	rjmp	.-72     	; 0x13c8 <findUnscannedPlot+0xd0>

00001410 <getAdjacentPlotPoints>:
*				  2) if black debris is present on any of the adjacent point then it will set 0 on its position in array
* Example Call:	  getAdjacentPlotPoints(46);
*
*/
void getAdjacentPlotPoints(int plot_coordinate)
{
    1410:	ef 92       	push	r14
    1412:	ff 92       	push	r15
    1414:	0f 93       	push	r16
    1416:	1f 93       	push	r17
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
	int i,j;
	pltadjpoints[0] = plot_coordinate+10;  //calculate adjacent point present on north side of the plot
    141c:	2b e8       	ldi	r18, 0x8B	; 139
    141e:	36 e0       	ldi	r19, 0x06	; 6
    1420:	ac 01       	movw	r20, r24
    1422:	46 5f       	subi	r20, 0xF6	; 246
    1424:	5f 4f       	sbci	r21, 0xFF	; 255
    1426:	50 93 8c 06 	sts	0x068C, r21
    142a:	40 93 8b 06 	sts	0x068B, r20
	pltadjpoints[1] = plot_coordinate+1;   //calculate adjacent point present on east side of the plot
    142e:	ac 01       	movw	r20, r24
    1430:	4f 5f       	subi	r20, 0xFF	; 255
    1432:	5f 4f       	sbci	r21, 0xFF	; 255
    1434:	50 93 8e 06 	sts	0x068E, r21
    1438:	40 93 8d 06 	sts	0x068D, r20
	pltadjpoints[2] = plot_coordinate-10;  //calculate adjacent point present on south side of the plot
    143c:	ac 01       	movw	r20, r24
    143e:	4a 50       	subi	r20, 0x0A	; 10
    1440:	50 40       	sbci	r21, 0x00	; 0
    1442:	50 93 90 06 	sts	0x0690, r21
    1446:	40 93 8f 06 	sts	0x068F, r20
	pltadjpoints[3] = plot_coordinate-1;   //calculate adjacent point present on west side of the plot
    144a:	01 97       	sbiw	r24, 0x01	; 1
    144c:	90 93 92 06 	sts	0x0692, r25
    1450:	80 93 91 06 	sts	0x0691, r24
    1454:	d9 01       	movw	r26, r18
*					 this will indicate all the available plot adjacent points
*				  2) if black debris is present on any of the adjacent point then it will set 0 on its position in array
* Example Call:	  getAdjacentPlotPoints(46);
*
*/
void getAdjacentPlotPoints(int plot_coordinate)
    1456:	b9 01       	movw	r22, r18
    1458:	68 5f       	subi	r22, 0xF8	; 248
    145a:	7f 4f       	sbci	r23, 0xFF	; 255
	//iterate over all calculated adjacent point to check if black debris is present on them or not
	for(i = 0; i < 4; i++)
	{
		j = 0;
		//go through coordinatesWithBlackDebris array and compare them with the selected adjacent point
		while(coordinatesWithBlackDebris[j] != 0)
    145c:	ee ef       	ldi	r30, 0xFE	; 254
    145e:	f5 e0       	ldi	r31, 0x05	; 5
		{
			//if any of the black debris coordinate present in array is equal to adjacent point then it is blocked
			if(coordinatesWithBlackDebris[j] == pltadjpoints[i])
    1460:	00 e0       	ldi	r16, 0x00	; 0
    1462:	10 e0       	ldi	r17, 0x00	; 0
    1464:	1f c0       	rjmp	.+62     	; 0x14a4 <getAdjacentPlotPoints+0x94>
    1466:	c9 01       	movw	r24, r18
    1468:	88 0f       	add	r24, r24
    146a:	99 1f       	adc	r25, r25
    146c:	8e 0f       	add	r24, r30
    146e:	9f 1f       	adc	r25, r31
    1470:	ec 01       	movw	r28, r24
    1472:	88 81       	ld	r24, Y
    1474:	99 81       	ldd	r25, Y+1	; 0x01
    1476:	84 17       	cp	r24, r20
    1478:	95 07       	cpc	r25, r21
    147a:	21 f4       	brne	.+8      	; 0x1484 <getAdjacentPlotPoints+0x74>
			{
				pltadjpoints[i] = 0;  //set 0 in place of blocked adjacent point
    147c:	e7 01       	movw	r28, r14
    147e:	19 82       	std	Y+1, r1	; 0x01
    1480:	18 82       	st	Y, r1
				break;
    1482:	0c c0       	rjmp	.+24     	; 0x149c <getAdjacentPlotPoints+0x8c>
			}				
			j++; //increment j to goto next coordinatesWithBlackDebris position
    1484:	2f 5f       	subi	r18, 0xFF	; 255
    1486:	3f 4f       	sbci	r19, 0xFF	; 255
	//iterate over all calculated adjacent point to check if black debris is present on them or not
	for(i = 0; i < 4; i++)
	{
		j = 0;
		//go through coordinatesWithBlackDebris array and compare them with the selected adjacent point
		while(coordinatesWithBlackDebris[j] != 0)
    1488:	c9 01       	movw	r24, r18
    148a:	88 0f       	add	r24, r24
    148c:	99 1f       	adc	r25, r25
    148e:	8e 0f       	add	r24, r30
    1490:	9f 1f       	adc	r25, r31
    1492:	ec 01       	movw	r28, r24
    1494:	88 81       	ld	r24, Y
    1496:	99 81       	ldd	r25, Y+1	; 0x01
    1498:	00 97       	sbiw	r24, 0x00	; 0
    149a:	29 f7       	brne	.-54     	; 0x1466 <getAdjacentPlotPoints+0x56>
    149c:	12 96       	adiw	r26, 0x02	; 2
	pltadjpoints[1] = plot_coordinate+1;   //calculate adjacent point present on east side of the plot
	pltadjpoints[2] = plot_coordinate-10;  //calculate adjacent point present on south side of the plot
	pltadjpoints[3] = plot_coordinate-1;   //calculate adjacent point present on west side of the plot
	
	//iterate over all calculated adjacent point to check if black debris is present on them or not
	for(i = 0; i < 4; i++)
    149e:	a6 17       	cp	r26, r22
    14a0:	b7 07       	cpc	r27, r23
    14a2:	79 f0       	breq	.+30     	; 0x14c2 <getAdjacentPlotPoints+0xb2>
	{
		j = 0;
		//go through coordinatesWithBlackDebris array and compare them with the selected adjacent point
		while(coordinatesWithBlackDebris[j] != 0)
    14a4:	80 81       	ld	r24, Z
    14a6:	91 81       	ldd	r25, Z+1	; 0x01
    14a8:	00 97       	sbiw	r24, 0x00	; 0
    14aa:	c1 f3       	breq	.-16     	; 0x149c <getAdjacentPlotPoints+0x8c>
		{
			//if any of the black debris coordinate present in array is equal to adjacent point then it is blocked
			if(coordinatesWithBlackDebris[j] == pltadjpoints[i])
    14ac:	80 81       	ld	r24, Z
    14ae:	91 81       	ldd	r25, Z+1	; 0x01
*					 this will indicate all the available plot adjacent points
*				  2) if black debris is present on any of the adjacent point then it will set 0 on its position in array
* Example Call:	  getAdjacentPlotPoints(46);
*
*/
void getAdjacentPlotPoints(int plot_coordinate)
    14b0:	7d 01       	movw	r14, r26
		j = 0;
		//go through coordinatesWithBlackDebris array and compare them with the selected adjacent point
		while(coordinatesWithBlackDebris[j] != 0)
		{
			//if any of the black debris coordinate present in array is equal to adjacent point then it is blocked
			if(coordinatesWithBlackDebris[j] == pltadjpoints[i])
    14b2:	4d 91       	ld	r20, X+
    14b4:	5c 91       	ld	r21, X
    14b6:	11 97       	sbiw	r26, 0x01	; 1
    14b8:	84 17       	cp	r24, r20
    14ba:	95 07       	cpc	r25, r21
    14bc:	f9 f2       	breq	.-66     	; 0x147c <getAdjacentPlotPoints+0x6c>
    14be:	98 01       	movw	r18, r16
    14c0:	e1 cf       	rjmp	.-62     	; 0x1484 <getAdjacentPlotPoints+0x74>
				break;
			}				
			j++; //increment j to goto next coordinatesWithBlackDebris position
		}
	}
}
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	1f 91       	pop	r17
    14c8:	0f 91       	pop	r16
    14ca:	ff 90       	pop	r15
    14cc:	ef 90       	pop	r14
    14ce:	08 95       	ret

000014d0 <computeMinIndex>:
*
*
* Example Call: computeMinIndex(int d[],int v[]);
*
*/
int computeMinIndex(int d[],int v[]){
    14d0:	cf 93       	push	r28
    14d2:	df 93       	push	r29
	int min_i=0; // it is the index of the element with least value
	for(i=0;i<100;i++)
	{
		if(min>d[i]&&v[i]==0)   //if the min is greater that the distance array element being pointed to and is unvisited(i.e. v[i]==0) then...
		{
			min=d[i];           //min is assigned the above condition is true
    14d4:	a8 2f       	mov	r26, r24
    14d6:	b9 2f       	mov	r27, r25
    14d8:	e6 2f       	mov	r30, r22
    14da:	f7 2f       	mov	r31, r23
*
*/
int computeMinIndex(int d[],int v[]){
	int i;
	int min=999; // variable is set to a large value(infinity)
	int min_i=0; // it is the index of the element with least value
    14dc:	c0 e0       	ldi	r28, 0x00	; 0
    14de:	d0 e0       	ldi	r29, 0x00	; 0
* Example Call: computeMinIndex(int d[],int v[]);
*
*/
int computeMinIndex(int d[],int v[]){
	int i;
	int min=999; // variable is set to a large value(infinity)
    14e0:	67 ee       	ldi	r22, 0xE7	; 231
    14e2:	73 e0       	ldi	r23, 0x03	; 3
	int min_i=0; // it is the index of the element with least value
	for(i=0;i<100;i++)
    14e4:	20 e0       	ldi	r18, 0x00	; 0
    14e6:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(min>d[i]&&v[i]==0)   //if the min is greater that the distance array element being pointed to and is unvisited(i.e. v[i]==0) then...
    14e8:	4d 91       	ld	r20, X+
    14ea:	5d 91       	ld	r21, X+
    14ec:	46 17       	cp	r20, r22
    14ee:	57 07       	cpc	r21, r23
    14f0:	34 f4       	brge	.+12     	; 0x14fe <computeMinIndex+0x2e>
    14f2:	80 81       	ld	r24, Z
    14f4:	91 81       	ldd	r25, Z+1	; 0x01
    14f6:	00 97       	sbiw	r24, 0x00	; 0
    14f8:	11 f4       	brne	.+4      	; 0x14fe <computeMinIndex+0x2e>
    14fa:	e9 01       	movw	r28, r18
		{
			min=d[i];           //min is assigned the above condition is true
    14fc:	ba 01       	movw	r22, r20
*/
int computeMinIndex(int d[],int v[]){
	int i;
	int min=999; // variable is set to a large value(infinity)
	int min_i=0; // it is the index of the element with least value
	for(i=0;i<100;i++)
    14fe:	2f 5f       	subi	r18, 0xFF	; 255
    1500:	3f 4f       	sbci	r19, 0xFF	; 255
    1502:	32 96       	adiw	r30, 0x02	; 2
    1504:	24 36       	cpi	r18, 0x64	; 100
    1506:	31 05       	cpc	r19, r1
    1508:	79 f7       	brne	.-34     	; 0x14e8 <computeMinIndex+0x18>
			min=d[i];           //min is assigned the above condition is true
			min_i=i;            // the index of that node which also happens to be it co-ordinate
		}
	}
	return min_i;
}
    150a:	8c 2f       	mov	r24, r28
    150c:	9d 2f       	mov	r25, r29
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	08 95       	ret

00001514 <findPath>:
*
* Example Call: findPath(int s, int d);
*
*/
struct pathStack findPath(int s, int d)
{
    1514:	2f 92       	push	r2
    1516:	3f 92       	push	r3
    1518:	4f 92       	push	r4
    151a:	5f 92       	push	r5
    151c:	6f 92       	push	r6
    151e:	7f 92       	push	r7
    1520:	8f 92       	push	r8
    1522:	9f 92       	push	r9
    1524:	af 92       	push	r10
    1526:	bf 92       	push	r11
    1528:	cf 92       	push	r12
    152a:	df 92       	push	r13
    152c:	ef 92       	push	r14
    152e:	ff 92       	push	r15
    1530:	0f 93       	push	r16
    1532:	1f 93       	push	r17
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	cd b7       	in	r28, 0x3d	; 61
    153a:	de b7       	in	r29, 0x3e	; 62
    153c:	c6 52       	subi	r28, 0x26	; 38
    153e:	d3 40       	sbci	r29, 0x03	; 3
    1540:	0f b6       	in	r0, 0x3f	; 63
    1542:	f8 94       	cli
    1544:	de bf       	out	0x3e, r29	; 62
    1546:	0f be       	out	0x3f, r0	; 63
    1548:	cd bf       	out	0x3d, r28	; 61
    154a:	cd 5d       	subi	r28, 0xDD	; 221
    154c:	dc 4f       	sbci	r29, 0xFC	; 252
    154e:	99 83       	std	Y+1, r25	; 0x01
    1550:	88 83       	st	Y, r24
    1552:	c3 52       	subi	r28, 0x23	; 35
    1554:	d3 40       	sbci	r29, 0x03	; 3
    1556:	4b 01       	movw	r8, r22
    1558:	1a 01       	movw	r2, r20
int visited[100] = {0};  //all elements of the visited array is set to 0 i.e all are set as unvisited
    155a:	fe 01       	movw	r30, r28
    155c:	31 96       	adiw	r30, 0x01	; 1
    155e:	88 ec       	ldi	r24, 0xC8	; 200
    1560:	df 01       	movw	r26, r30
    1562:	1d 92       	st	X+, r1
    1564:	8a 95       	dec	r24
    1566:	e9 f7       	brne	.-6      	; 0x1562 <findPath+0x4e>
    1568:	fe 01       	movw	r30, r28
    156a:	ef 56       	subi	r30, 0x6F	; 111
    156c:	fe 4f       	sbci	r31, 0xFE	; 254
    156e:	de 01       	movw	r26, r28
    1570:	a7 53       	subi	r26, 0x37	; 55
    1572:	bf 4f       	sbci	r27, 0xFF	; 255
*		  pathStack variable, the path shall be read in reverse manner from the destination until the source is reached.
*
* Example Call: findPath(int s, int d);
*
*/
struct pathStack findPath(int s, int d)
    1574:	ce 01       	movw	r24, r28
    1576:	87 5a       	subi	r24, 0xA7	; 167
    1578:	9d 4f       	sbci	r25, 0xFD	; 253
	int temp;  
	struct pathStack paths;  //this structure shall contain requested path to be followed. It shall be returned later
	int i,j,k,min_index;
	for(i=0;i<100;i++)
	{
		parent[i] =- 1; //the parent of all nodes is set to -1
    157a:	2f ef       	ldi	r18, 0xFF	; 255
    157c:	3f ef       	ldi	r19, 0xFF	; 255
		distance[i] = 999; //the distance of the nodes from the source 's' set to a large value(infinity)
    157e:	47 ee       	ldi	r20, 0xE7	; 231
    1580:	53 e0       	ldi	r21, 0x03	; 3
	int temp;  
	struct pathStack paths;  //this structure shall contain requested path to be followed. It shall be returned later
	int i,j,k,min_index;
	for(i=0;i<100;i++)
	{
		parent[i] =- 1; //the parent of all nodes is set to -1
    1582:	21 93       	st	Z+, r18
    1584:	31 93       	st	Z+, r19
		distance[i] = 999; //the distance of the nodes from the source 's' set to a large value(infinity)
    1586:	4d 93       	st	X+, r20
    1588:	5d 93       	st	X+, r21
	int distance[100];  //the distance stores the distance of all the coordinates from the source
	int parent[100];  //this array stores the parent of each node to be that must be reached to reach with minimum path
	int temp;  
	struct pathStack paths;  //this structure shall contain requested path to be followed. It shall be returned later
	int i,j,k,min_index;
	for(i=0;i<100;i++)
    158a:	e8 17       	cp	r30, r24
    158c:	f9 07       	cpc	r31, r25
    158e:	c9 f7       	brne	.-14     	; 0x1582 <findPath+0x6e>
	{
		parent[i] =- 1; //the parent of all nodes is set to -1
		distance[i] = 999; //the distance of the nodes from the source 's' set to a large value(infinity)
	}
	visited[s] = 1; //parent is set as visited
    1590:	c4 01       	movw	r24, r8
    1592:	88 0f       	add	r24, r24
    1594:	99 1f       	adc	r25, r25
    1596:	fe 01       	movw	r30, r28
    1598:	e8 0f       	add	r30, r24
    159a:	f9 1f       	adc	r31, r25
    159c:	21 e0       	ldi	r18, 0x01	; 1
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	32 83       	std	Z+2, r19	; 0x02
    15a2:	21 83       	std	Z+1, r18	; 0x01
	distance[s] = 0; //distance of source vertex from itself shall be 0
    15a4:	e9 ec       	ldi	r30, 0xC9	; 201
    15a6:	f0 e0       	ldi	r31, 0x00	; 0
    15a8:	ec 0f       	add	r30, r28
    15aa:	fd 1f       	adc	r31, r29
    15ac:	e8 0f       	add	r30, r24
    15ae:	f9 1f       	adc	r31, r25
    15b0:	11 82       	std	Z+1, r1	; 0x01
    15b2:	10 82       	st	Z, r1
	parent[s] = s; //parent of the source node shall be itself
    15b4:	e1 e9       	ldi	r30, 0x91	; 145
    15b6:	f1 e0       	ldi	r31, 0x01	; 1
    15b8:	ec 0f       	add	r30, r28
    15ba:	fd 1f       	adc	r31, r29
    15bc:	8e 0f       	add	r24, r30
    15be:	9f 1f       	adc	r25, r31
    15c0:	dc 01       	movw	r26, r24
    15c2:	11 96       	adiw	r26, 0x01	; 1
    15c4:	9c 92       	st	X, r9
    15c6:	8e 92       	st	-X, r8
	k = 1;
	for(j=0;j<4;j++) //the loop iterates 4 times since in our graph(i.e arena) any node can have maximum of 4 neighbors
    15c8:	20 e0       	ldi	r18, 0x00	; 0
    15ca:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(cinfo[s][j ] != 0) //it is checked whether the node is a valid vertex or not
    15cc:	c4 01       	movw	r24, r8
    15ce:	88 0f       	add	r24, r24
    15d0:	99 1f       	adc	r25, r25
    15d2:	88 0f       	add	r24, r24
    15d4:	99 1f       	adc	r25, r25
    15d6:	ac 01       	movw	r20, r24
    15d8:	48 0d       	add	r20, r8
    15da:	59 1d       	adc	r21, r9
    15dc:	66 e1       	ldi	r22, 0x16	; 22
    15de:	72 e0       	ldi	r23, 0x02	; 2
		{
			distance[cinfo[s][j]] = 1; //distance of all the coordinates adjacent to the source is et to 1
    15e0:	ee 24       	eor	r14, r14
    15e2:	ff 24       	eor	r15, r15
    15e4:	e3 94       	inc	r14
	distance[s] = 0; //distance of source vertex from itself shall be 0
	parent[s] = s; //parent of the source node shall be itself
	k = 1;
	for(j=0;j<4;j++) //the loop iterates 4 times since in our graph(i.e arena) any node can have maximum of 4 neighbors
	{
		if(cinfo[s][j ] != 0) //it is checked whether the node is a valid vertex or not
    15e6:	ca 01       	movw	r24, r20
    15e8:	82 0f       	add	r24, r18
    15ea:	93 1f       	adc	r25, r19
    15ec:	88 0f       	add	r24, r24
    15ee:	99 1f       	adc	r25, r25
    15f0:	86 0f       	add	r24, r22
    15f2:	97 1f       	adc	r25, r23
    15f4:	fc 01       	movw	r30, r24
    15f6:	80 81       	ld	r24, Z
    15f8:	91 81       	ldd	r25, Z+1	; 0x01
    15fa:	00 97       	sbiw	r24, 0x00	; 0
    15fc:	19 f1       	breq	.+70     	; 0x1644 <findPath+0x130>
		{
			distance[cinfo[s][j]] = 1; //distance of all the coordinates adjacent to the source is et to 1
    15fe:	ca 01       	movw	r24, r20
    1600:	82 0f       	add	r24, r18
    1602:	93 1f       	adc	r25, r19
    1604:	88 0f       	add	r24, r24
    1606:	99 1f       	adc	r25, r25
    1608:	fb 01       	movw	r30, r22
    160a:	e8 0f       	add	r30, r24
    160c:	f9 1f       	adc	r31, r25
    160e:	80 81       	ld	r24, Z
    1610:	91 81       	ldd	r25, Z+1	; 0x01
    1612:	88 0f       	add	r24, r24
    1614:	99 1f       	adc	r25, r25
    1616:	09 ec       	ldi	r16, 0xC9	; 201
    1618:	10 e0       	ldi	r17, 0x00	; 0
    161a:	0c 0f       	add	r16, r28
    161c:	1d 1f       	adc	r17, r29
    161e:	80 0f       	add	r24, r16
    1620:	91 1f       	adc	r25, r17
    1622:	dc 01       	movw	r26, r24
    1624:	ed 92       	st	X+, r14
    1626:	fc 92       	st	X, r15
			parent[cinfo[s][j]] =s ;//the parent of these coordinates is set to the source itself
    1628:	80 81       	ld	r24, Z
    162a:	91 81       	ldd	r25, Z+1	; 0x01
    162c:	88 0f       	add	r24, r24
    162e:	99 1f       	adc	r25, r25
    1630:	e1 e9       	ldi	r30, 0x91	; 145
    1632:	f1 e0       	ldi	r31, 0x01	; 1
    1634:	ec 0f       	add	r30, r28
    1636:	fd 1f       	adc	r31, r29
    1638:	8e 0f       	add	r24, r30
    163a:	9f 1f       	adc	r25, r31
    163c:	dc 01       	movw	r26, r24
    163e:	11 96       	adiw	r26, 0x01	; 1
    1640:	9c 92       	st	X, r9
    1642:	8e 92       	st	-X, r8
	}
	visited[s] = 1; //parent is set as visited
	distance[s] = 0; //distance of source vertex from itself shall be 0
	parent[s] = s; //parent of the source node shall be itself
	k = 1;
	for(j=0;j<4;j++) //the loop iterates 4 times since in our graph(i.e arena) any node can have maximum of 4 neighbors
    1644:	2f 5f       	subi	r18, 0xFF	; 255
    1646:	3f 4f       	sbci	r19, 0xFF	; 255
    1648:	24 30       	cpi	r18, 0x04	; 4
    164a:	31 05       	cpc	r19, r1
    164c:	61 f6       	brne	.-104    	; 0x15e6 <findPath+0xd2>
    164e:	0f 2e       	mov	r0, r31
    1650:	f1 e4       	ldi	r31, 0x41	; 65
    1652:	ef 2e       	mov	r14, r31
    1654:	ff 24       	eor	r15, r15
    1656:	f0 2d       	mov	r31, r0
		}
	}
	while(k <= 65) //loop shall iterate to a maximum of 65
	{
		min_index=computeMinIndex(distance,visited); //the UNVISITED node with the least distance is computed
		visited[min_index]=1; //the node computed in the previous node is marked as visited
    1658:	66 24       	eor	r6, r6
    165a:	77 24       	eor	r7, r7
    165c:	63 94       	inc	r6
		for(j=0;j<4;j++)
    165e:	44 24       	eor	r4, r4
    1660:	55 24       	eor	r5, r5
		{
			if(cinfo[min_index][j]!=0) //validity of the node adjacent to min_index is checked
    1662:	06 e1       	ldi	r16, 0x16	; 22
    1664:	12 e0       	ldi	r17, 0x02	; 2
			parent[cinfo[s][j]] =s ;//the parent of these coordinates is set to the source itself
		}
	}
	while(k <= 65) //loop shall iterate to a maximum of 65
	{
		min_index=computeMinIndex(distance,visited); //the UNVISITED node with the least distance is computed
    1666:	ce 01       	movw	r24, r28
    1668:	87 53       	subi	r24, 0x37	; 55
    166a:	9f 4f       	sbci	r25, 0xFF	; 255
    166c:	be 01       	movw	r22, r28
    166e:	6f 5f       	subi	r22, 0xFF	; 255
    1670:	7f 4f       	sbci	r23, 0xFF	; 255
    1672:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <computeMinIndex>
    1676:	cb 5d       	subi	r28, 0xDB	; 219
    1678:	dc 4f       	sbci	r29, 0xFC	; 252
    167a:	99 83       	std	Y+1, r25	; 0x01
    167c:	88 83       	st	Y, r24
    167e:	c5 52       	subi	r28, 0x25	; 37
    1680:	d3 40       	sbci	r29, 0x03	; 3
		visited[min_index]=1; //the node computed in the previous node is marked as visited
    1682:	88 0f       	add	r24, r24
    1684:	99 1f       	adc	r25, r25
    1686:	e1 e0       	ldi	r30, 0x01	; 1
    1688:	f0 e0       	ldi	r31, 0x00	; 0
    168a:	ec 0f       	add	r30, r28
    168c:	fd 1f       	adc	r31, r29
    168e:	8e 0f       	add	r24, r30
    1690:	9f 1f       	adc	r25, r31
    1692:	dc 01       	movw	r26, r24
    1694:	6d 92       	st	X+, r6
    1696:	7c 92       	st	X, r7
		for(j=0;j<4;j++)
    1698:	a2 01       	movw	r20, r4
		{
			if(cinfo[min_index][j]!=0) //validity of the node adjacent to min_index is checked
    169a:	cb 5d       	subi	r28, 0xDB	; 219
    169c:	dc 4f       	sbci	r29, 0xFC	; 252
    169e:	88 81       	ld	r24, Y
    16a0:	99 81       	ldd	r25, Y+1	; 0x01
    16a2:	c5 52       	subi	r28, 0x25	; 37
    16a4:	d3 40       	sbci	r29, 0x03	; 3
    16a6:	88 0f       	add	r24, r24
    16a8:	99 1f       	adc	r25, r25
    16aa:	88 0f       	add	r24, r24
    16ac:	99 1f       	adc	r25, r25
    16ae:	cb 5d       	subi	r28, 0xDB	; 219
    16b0:	dc 4f       	sbci	r29, 0xFC	; 252
    16b2:	e8 81       	ld	r30, Y
    16b4:	f9 81       	ldd	r31, Y+1	; 0x01
    16b6:	c5 52       	subi	r28, 0x25	; 37
    16b8:	d3 40       	sbci	r29, 0x03	; 3
    16ba:	e8 0f       	add	r30, r24
    16bc:	f9 1f       	adc	r31, r25
			{
				if( distance[cinfo[min_index][j]]>distance[min_index]+1   //this condition checks whether the distance of the node adjacent to the min_index, from the source, is less greater than 1 edge more than that of the min_index
    16be:	cb 5d       	subi	r28, 0xDB	; 219
    16c0:	dc 4f       	sbci	r29, 0xFC	; 252
    16c2:	88 81       	ld	r24, Y
    16c4:	99 81       	ldd	r25, Y+1	; 0x01
    16c6:	c5 52       	subi	r28, 0x25	; 37
    16c8:	d3 40       	sbci	r29, 0x03	; 3
    16ca:	88 0f       	add	r24, r24
    16cc:	99 1f       	adc	r25, r25
    16ce:	0f 2e       	mov	r0, r31
    16d0:	f9 ec       	ldi	r31, 0xC9	; 201
    16d2:	cf 2e       	mov	r12, r31
    16d4:	dd 24       	eor	r13, r13
    16d6:	f0 2d       	mov	r31, r0
    16d8:	cc 0e       	add	r12, r28
    16da:	dd 1e       	adc	r13, r29
    16dc:	c8 0e       	add	r12, r24
    16de:	d9 1e       	adc	r13, r25
				                &&  cinfo[min_index][4]==0 )  //checks if the node is having a black debris(checks if its blocked) or not. IF zero then its UNBLOCKED
    16e0:	cb 5d       	subi	r28, 0xDB	; 219
    16e2:	dc 4f       	sbci	r29, 0xFC	; 252
    16e4:	28 81       	ld	r18, Y
    16e6:	39 81       	ldd	r19, Y+1	; 0x01
    16e8:	c5 52       	subi	r28, 0x25	; 37
    16ea:	d3 40       	sbci	r29, 0x03	; 3
    16ec:	22 0f       	add	r18, r18
    16ee:	33 1f       	adc	r19, r19
    16f0:	22 0f       	add	r18, r18
    16f2:	33 1f       	adc	r19, r19
    16f4:	22 0f       	add	r18, r18
    16f6:	33 1f       	adc	r19, r19
    16f8:	82 0f       	add	r24, r18
    16fa:	93 1f       	adc	r25, r19
    16fc:	80 0f       	add	r24, r16
    16fe:	91 1f       	adc	r25, r17
    1700:	aa 24       	eor	r10, r10
    1702:	bb 24       	eor	r11, r11
    1704:	68 94       	set
    1706:	a3 f8       	bld	r10, 3
    1708:	a8 0e       	add	r10, r24
    170a:	b9 1e       	adc	r11, r25
	{
		min_index=computeMinIndex(distance,visited); //the UNVISITED node with the least distance is computed
		visited[min_index]=1; //the node computed in the previous node is marked as visited
		for(j=0;j<4;j++)
		{
			if(cinfo[min_index][j]!=0) //validity of the node adjacent to min_index is checked
    170c:	cf 01       	movw	r24, r30
    170e:	84 0f       	add	r24, r20
    1710:	95 1f       	adc	r25, r21
    1712:	88 0f       	add	r24, r24
    1714:	99 1f       	adc	r25, r25
    1716:	80 0f       	add	r24, r16
    1718:	91 1f       	adc	r25, r17
    171a:	dc 01       	movw	r26, r24
    171c:	8d 91       	ld	r24, X+
    171e:	9c 91       	ld	r25, X
    1720:	11 97       	sbiw	r26, 0x01	; 1
    1722:	00 97       	sbiw	r24, 0x00	; 0
    1724:	09 f4       	brne	.+2      	; 0x1728 <findPath+0x214>
    1726:	49 c0       	rjmp	.+146    	; 0x17ba <findPath+0x2a6>
			{
				if( distance[cinfo[min_index][j]]>distance[min_index]+1   //this condition checks whether the distance of the node adjacent to the min_index, from the source, is less greater than 1 edge more than that of the min_index
    1728:	2d 91       	ld	r18, X+
    172a:	3c 91       	ld	r19, X
    172c:	d6 01       	movw	r26, r12
    172e:	8d 91       	ld	r24, X+
    1730:	9c 91       	ld	r25, X
    1732:	bc 01       	movw	r22, r24
    1734:	6f 5f       	subi	r22, 0xFF	; 255
    1736:	7f 4f       	sbci	r23, 0xFF	; 255
    1738:	c9 01       	movw	r24, r18
    173a:	88 0f       	add	r24, r24
    173c:	99 1f       	adc	r25, r25
    173e:	29 ec       	ldi	r18, 0xC9	; 201
    1740:	30 e0       	ldi	r19, 0x00	; 0
    1742:	2c 0f       	add	r18, r28
    1744:	3d 1f       	adc	r19, r29
    1746:	82 0f       	add	r24, r18
    1748:	93 1f       	adc	r25, r19
    174a:	dc 01       	movw	r26, r24
    174c:	8d 91       	ld	r24, X+
    174e:	9c 91       	ld	r25, X
    1750:	11 97       	sbiw	r26, 0x01	; 1
    1752:	68 17       	cp	r22, r24
    1754:	79 07       	cpc	r23, r25
    1756:	8c f5       	brge	.+98     	; 0x17ba <findPath+0x2a6>
				                &&  cinfo[min_index][4]==0 )  //checks if the node is having a black debris(checks if its blocked) or not. IF zero then its UNBLOCKED
    1758:	d5 01       	movw	r26, r10
    175a:	8d 91       	ld	r24, X+
    175c:	9c 91       	ld	r25, X
    175e:	11 97       	sbiw	r26, 0x01	; 1
    1760:	00 97       	sbiw	r24, 0x00	; 0
    1762:	59 f5       	brne	.+86     	; 0x17ba <findPath+0x2a6>
				{
					distance[cinfo[min_index][j]]=distance[min_index]+1; //the shorter distance is saved
    1764:	cf 01       	movw	r24, r30
    1766:	84 0f       	add	r24, r20
    1768:	95 1f       	adc	r25, r21
    176a:	88 0f       	add	r24, r24
    176c:	99 1f       	adc	r25, r25
    176e:	98 01       	movw	r18, r16
    1770:	28 0f       	add	r18, r24
    1772:	39 1f       	adc	r19, r25
    1774:	d9 01       	movw	r26, r18
    1776:	8d 91       	ld	r24, X+
    1778:	9c 91       	ld	r25, X
    177a:	88 0f       	add	r24, r24
    177c:	99 1f       	adc	r25, r25
    177e:	a9 ec       	ldi	r26, 0xC9	; 201
    1780:	b0 e0       	ldi	r27, 0x00	; 0
    1782:	ac 0f       	add	r26, r28
    1784:	bd 1f       	adc	r27, r29
    1786:	8a 0f       	add	r24, r26
    1788:	9b 1f       	adc	r25, r27
    178a:	dc 01       	movw	r26, r24
    178c:	6d 93       	st	X+, r22
    178e:	7c 93       	st	X, r23
					parent[cinfo[min_index][j]]=min_index; //parent of this node is set to the min_index
    1790:	d9 01       	movw	r26, r18
    1792:	8d 91       	ld	r24, X+
    1794:	9c 91       	ld	r25, X
    1796:	88 0f       	add	r24, r24
    1798:	99 1f       	adc	r25, r25
    179a:	21 e9       	ldi	r18, 0x91	; 145
    179c:	31 e0       	ldi	r19, 0x01	; 1
    179e:	2c 0f       	add	r18, r28
    17a0:	3d 1f       	adc	r19, r29
    17a2:	82 0f       	add	r24, r18
    17a4:	93 1f       	adc	r25, r19
    17a6:	cb 5d       	subi	r28, 0xDB	; 219
    17a8:	dc 4f       	sbci	r29, 0xFC	; 252
    17aa:	28 81       	ld	r18, Y
    17ac:	39 81       	ldd	r19, Y+1	; 0x01
    17ae:	c5 52       	subi	r28, 0x25	; 37
    17b0:	d3 40       	sbci	r29, 0x03	; 3
    17b2:	dc 01       	movw	r26, r24
    17b4:	11 96       	adiw	r26, 0x01	; 1
    17b6:	3c 93       	st	X, r19
    17b8:	2e 93       	st	-X, r18
	}
	while(k <= 65) //loop shall iterate to a maximum of 65
	{
		min_index=computeMinIndex(distance,visited); //the UNVISITED node with the least distance is computed
		visited[min_index]=1; //the node computed in the previous node is marked as visited
		for(j=0;j<4;j++)
    17ba:	4f 5f       	subi	r20, 0xFF	; 255
    17bc:	5f 4f       	sbci	r21, 0xFF	; 255
    17be:	44 30       	cpi	r20, 0x04	; 4
    17c0:	51 05       	cpc	r21, r1
    17c2:	09 f0       	breq	.+2      	; 0x17c6 <findPath+0x2b2>
    17c4:	a3 cf       	rjmp	.-186    	; 0x170c <findPath+0x1f8>
    17c6:	08 94       	sec
    17c8:	e1 08       	sbc	r14, r1
    17ca:	f1 08       	sbc	r15, r1
		{
			distance[cinfo[s][j]] = 1; //distance of all the coordinates adjacent to the source is et to 1
			parent[cinfo[s][j]] =s ;//the parent of these coordinates is set to the source itself
		}
	}
	while(k <= 65) //loop shall iterate to a maximum of 65
    17cc:	e1 14       	cp	r14, r1
    17ce:	f1 04       	cpc	r15, r1
    17d0:	09 f0       	breq	.+2      	; 0x17d4 <findPath+0x2c0>
    17d2:	49 cf       	rjmp	.-366    	; 0x1666 <findPath+0x152>
		}
		k++; //counter incremented
	}
	//In the following lines the path from the specified source (s) to the destination (d) shall be computed
	paths.length=-1; //the length of the path is set to -1
	paths.path[++paths.length]=d;//the destination shall be at the bottom of the stack and the source at the top
    17d4:	c7 5a       	subi	r28, 0xA7	; 167
    17d6:	dd 4f       	sbci	r29, 0xFD	; 253
    17d8:	39 82       	std	Y+1, r3	; 0x01
    17da:	28 82       	st	Y, r2
    17dc:	c9 55       	subi	r28, 0x59	; 89
    17de:	d2 40       	sbci	r29, 0x02	; 2
	temp=parent[d];//parent of the destination node is stored in temp
    17e0:	f1 01       	movw	r30, r2
    17e2:	ee 0f       	add	r30, r30
    17e4:	ff 1f       	adc	r31, r31
    17e6:	61 e9       	ldi	r22, 0x91	; 145
    17e8:	71 e0       	ldi	r23, 0x01	; 1
    17ea:	6c 0f       	add	r22, r28
    17ec:	7d 1f       	adc	r23, r29
    17ee:	e6 0f       	add	r30, r22
    17f0:	f7 1f       	adc	r31, r23
    17f2:	80 81       	ld	r24, Z
    17f4:	91 81       	ldd	r25, Z+1	; 0x01
	while(temp!=s)//until the source is reached the path stack will keep building up
    17f6:	88 16       	cp	r8, r24
    17f8:	99 06       	cpc	r9, r25
    17fa:	d1 f0       	breq	.+52     	; 0x1830 <findPath+0x31c>
    17fc:	fe 01       	movw	r30, r28
    17fe:	e5 5a       	subi	r30, 0xA5	; 165
    1800:	fd 4f       	sbci	r31, 0xFD	; 253
    1802:	21 e0       	ldi	r18, 0x01	; 1
    1804:	30 e0       	ldi	r19, 0x00	; 0
	{
		paths.path[++paths.length]=temp;//the parent node(which must be arrived to to get shortest distance) is saved. This shall precede its intended destination
    1806:	a9 01       	movw	r20, r18
    1808:	81 93       	st	Z+, r24
    180a:	91 93       	st	Z+, r25
		temp=parent[temp];//parent of the other parent is then copied in a temporary variable
    180c:	88 0f       	add	r24, r24
    180e:	99 1f       	adc	r25, r25
    1810:	a1 e9       	ldi	r26, 0x91	; 145
    1812:	b1 e0       	ldi	r27, 0x01	; 1
    1814:	ac 0f       	add	r26, r28
    1816:	bd 1f       	adc	r27, r29
    1818:	8a 0f       	add	r24, r26
    181a:	9b 1f       	adc	r25, r27
    181c:	dc 01       	movw	r26, r24
    181e:	8d 91       	ld	r24, X+
    1820:	9c 91       	ld	r25, X
    1822:	11 97       	sbiw	r26, 0x01	; 1
    1824:	2f 5f       	subi	r18, 0xFF	; 255
    1826:	3f 4f       	sbci	r19, 0xFF	; 255
	}
	//In the following lines the path from the specified source (s) to the destination (d) shall be computed
	paths.length=-1; //the length of the path is set to -1
	paths.path[++paths.length]=d;//the destination shall be at the bottom of the stack and the source at the top
	temp=parent[d];//parent of the destination node is stored in temp
	while(temp!=s)//until the source is reached the path stack will keep building up
    1828:	88 16       	cp	r8, r24
    182a:	99 06       	cpc	r9, r25
    182c:	61 f7       	brne	.-40     	; 0x1806 <findPath+0x2f2>
    182e:	02 c0       	rjmp	.+4      	; 0x1834 <findPath+0x320>
		}
		k++; //counter incremented
	}
	//In the following lines the path from the specified source (s) to the destination (d) shall be computed
	paths.length=-1; //the length of the path is set to -1
	paths.path[++paths.length]=d;//the destination shall be at the bottom of the stack and the source at the top
    1830:	40 e0       	ldi	r20, 0x00	; 0
    1832:	50 e0       	ldi	r21, 0x00	; 0
	while(temp!=s)//until the source is reached the path stack will keep building up
	{
		paths.path[++paths.length]=temp;//the parent node(which must be arrived to to get shortest distance) is saved. This shall precede its intended destination
		temp=parent[temp];//parent of the other parent is then copied in a temporary variable
	}
	paths.path[++paths.length]=s;//since the loop terminated at the arrival of the source. The source is saved at the top of the path
    1834:	4f 5f       	subi	r20, 0xFF	; 255
    1836:	5f 4f       	sbci	r21, 0xFF	; 255
    1838:	fa 01       	movw	r30, r20
    183a:	ee 0f       	add	r30, r30
    183c:	ff 1f       	adc	r31, r31
    183e:	09 e5       	ldi	r16, 0x59	; 89
    1840:	12 e0       	ldi	r17, 0x02	; 2
    1842:	0c 0f       	add	r16, r28
    1844:	1d 1f       	adc	r17, r29
    1846:	e0 0f       	add	r30, r16
    1848:	f1 1f       	adc	r31, r17
    184a:	91 82       	std	Z+1, r9	; 0x01
    184c:	80 82       	st	Z, r8
	return paths;  //the path is returned
    184e:	cd 5d       	subi	r28, 0xDD	; 221
    1850:	dc 4f       	sbci	r29, 0xFC	; 252
    1852:	a8 81       	ld	r26, Y
    1854:	b9 81       	ldd	r27, Y+1	; 0x01
    1856:	c3 52       	subi	r28, 0x23	; 35
    1858:	d3 40       	sbci	r29, 0x03	; 3
    185a:	f8 01       	movw	r30, r16
    185c:	8a ec       	ldi	r24, 0xCA	; 202
    185e:	01 90       	ld	r0, Z+
    1860:	0d 92       	st	X+, r0
    1862:	81 50       	subi	r24, 0x01	; 1
    1864:	e1 f7       	brne	.-8      	; 0x185e <findPath+0x34a>
    1866:	cd 5d       	subi	r28, 0xDD	; 221
    1868:	dc 4f       	sbci	r29, 0xFC	; 252
    186a:	e8 81       	ld	r30, Y
    186c:	f9 81       	ldd	r31, Y+1	; 0x01
    186e:	c3 52       	subi	r28, 0x23	; 35
    1870:	d3 40       	sbci	r29, 0x03	; 3
    1872:	e8 53       	subi	r30, 0x38	; 56
    1874:	ff 4f       	sbci	r31, 0xFF	; 255
    1876:	51 83       	std	Z+1, r21	; 0x01
    1878:	40 83       	st	Z, r20
}
    187a:	cd 5d       	subi	r28, 0xDD	; 221
    187c:	dc 4f       	sbci	r29, 0xFC	; 252
    187e:	88 81       	ld	r24, Y
    1880:	99 81       	ldd	r25, Y+1	; 0x01
    1882:	c3 52       	subi	r28, 0x23	; 35
    1884:	d3 40       	sbci	r29, 0x03	; 3
    1886:	ca 5d       	subi	r28, 0xDA	; 218
    1888:	dc 4f       	sbci	r29, 0xFC	; 252
    188a:	0f b6       	in	r0, 0x3f	; 63
    188c:	f8 94       	cli
    188e:	de bf       	out	0x3e, r29	; 62
    1890:	0f be       	out	0x3f, r0	; 63
    1892:	cd bf       	out	0x3d, r28	; 61
    1894:	df 91       	pop	r29
    1896:	cf 91       	pop	r28
    1898:	1f 91       	pop	r17
    189a:	0f 91       	pop	r16
    189c:	ff 90       	pop	r15
    189e:	ef 90       	pop	r14
    18a0:	df 90       	pop	r13
    18a2:	cf 90       	pop	r12
    18a4:	bf 90       	pop	r11
    18a6:	af 90       	pop	r10
    18a8:	9f 90       	pop	r9
    18aa:	8f 90       	pop	r8
    18ac:	7f 90       	pop	r7
    18ae:	6f 90       	pop	r6
    18b0:	5f 90       	pop	r5
    18b2:	4f 90       	pop	r4
    18b4:	3f 90       	pop	r3
    18b6:	2f 90       	pop	r2
    18b8:	08 95       	ret

000018ba <selectMinPathtoDestinationPlot>:
*				  4) finally return path which has minimum length and minimum turns
* Example Call:	  selectMinPathtoDestinationPlot();
*
*/
struct pathStack selectMinPathtoDestinationPlot()
{
    18ba:	2f 92       	push	r2
    18bc:	3f 92       	push	r3
    18be:	4f 92       	push	r4
    18c0:	5f 92       	push	r5
    18c2:	6f 92       	push	r6
    18c4:	7f 92       	push	r7
    18c6:	8f 92       	push	r8
    18c8:	9f 92       	push	r9
    18ca:	af 92       	push	r10
    18cc:	bf 92       	push	r11
    18ce:	cf 92       	push	r12
    18d0:	df 92       	push	r13
    18d2:	ef 92       	push	r14
    18d4:	ff 92       	push	r15
    18d6:	0f 93       	push	r16
    18d8:	1f 93       	push	r17
    18da:	cf 93       	push	r28
    18dc:	df 93       	push	r29
    18de:	cd b7       	in	r28, 0x3d	; 61
    18e0:	de b7       	in	r29, 0x3e	; 62
    18e2:	c6 59       	subi	r28, 0x96	; 150
    18e4:	d1 40       	sbci	r29, 0x01	; 1
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	de bf       	out	0x3e, r29	; 62
    18ec:	0f be       	out	0x3f, r0	; 63
    18ee:	cd bf       	out	0x3d, r28	; 61
    18f0:	1c 01       	movw	r2, r24
					minpath = path;  //assign calculated path to minpath
				}
				else if(path.length == minlength) //if calculated path length and minlength both are same
				{
					//then calculate the numbers of turns available in both the paths
					for(int i = 1; i < minlength; i++)
    18f2:	0f 2e       	mov	r0, r31
    18f4:	fb e8       	ldi	r31, 0x8B	; 139
    18f6:	af 2e       	mov	r10, r31
    18f8:	f6 e0       	ldi	r31, 0x06	; 6
    18fa:	bf 2e       	mov	r11, r31
    18fc:	f0 2d       	mov	r31, r0
*                    turns will be only compared when 2 paths have same length
*				  4) finally return path which has minimum length and minimum turns
* Example Call:	  selectMinPathtoDestinationPlot();
*
*/
struct pathStack selectMinPathtoDestinationPlot()
    18fe:	66 24       	eor	r6, r6
    1900:	77 24       	eor	r7, r7
    1902:	68 94       	set
    1904:	63 f8       	bld	r6, 3
    1906:	6a 0c       	add	r6, r10
    1908:	7b 1c       	adc	r7, r11
{
	int minlength = 999;  //initialize minlength to infinity
	int path_turn = 0; //initialize turns for the path that is calculated
	int minpath_turn = 0;  //initialize turns for path that is stored in minpath
	struct pathStack path, minpath;  //declare variables to store minpath and calculated path
	minpath.length = 0;  //initialize minpath length to 0. In case of any path not found the length of minpath returned will be 0
    190a:	44 24       	eor	r4, r4
    190c:	55 24       	eor	r5, r5
* Example Call:	  selectMinPathtoDestinationPlot();
*
*/
struct pathStack selectMinPathtoDestinationPlot()
{
	int minlength = 999;  //initialize minlength to infinity
    190e:	07 ee       	ldi	r16, 0xE7	; 231
    1910:	13 e0       	ldi	r17, 0x03	; 3
	int minpath_turn = 0;  //initialize turns for path that is stored in minpath
	struct pathStack path, minpath;  //declare variables to store minpath and calculated path
	minpath.length = 0;  //initialize minpath length to 0. In case of any path not found the length of minpath returned will be 0
	for(int i = 0; i < 4; i++)  //iterate over all the 4 plot adjacent point stored in pltadjpoints array
	{
		if(pltadjpoints[i] != 0) //if the adjacent point is not 0
    1912:	f5 01       	movw	r30, r10
    1914:	41 91       	ld	r20, Z+
    1916:	51 91       	ld	r21, Z+
    1918:	5f 01       	movw	r10, r30
    191a:	41 15       	cp	r20, r1
    191c:	51 05       	cpc	r21, r1
    191e:	09 f4       	brne	.+2      	; 0x1922 <selectMinPathtoDestinationPlot+0x68>
    1920:	ac c0       	rjmp	.+344    	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
		{
			path = findPath(current_pos, pltadjpoints[i]); // calculate the path between current position and selected adjacent point   
    1922:	60 91 9b 06 	lds	r22, 0x069B
    1926:	70 91 9c 06 	lds	r23, 0x069C
    192a:	ce 01       	movw	r24, r28
    192c:	01 96       	adiw	r24, 0x01	; 1
    192e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <findPath>
    1932:	c7 53       	subi	r28, 0x37	; 55
    1934:	df 4f       	sbci	r29, 0xFF	; 255
    1936:	88 80       	ld	r8, Y
    1938:	99 80       	ldd	r9, Y+1	; 0x01
    193a:	c9 5c       	subi	r28, 0xC9	; 201
    193c:	d0 40       	sbci	r29, 0x00	; 0
			if(path.length != 0)  //if length of calculated path is not 0
    193e:	81 14       	cp	r8, r1
    1940:	91 04       	cpc	r9, r1
    1942:	09 f4       	brne	.+2      	; 0x1946 <selectMinPathtoDestinationPlot+0x8c>
    1944:	93 c0       	rjmp	.+294    	; 0x1a6c <selectMinPathtoDestinationPlot+0x1b2>
			{
				if(path.length < minlength)  //compare path length with minlength
    1946:	80 16       	cp	r8, r16
    1948:	91 06       	cpc	r9, r17
    194a:	6c f4       	brge	.+26     	; 0x1966 <selectMinPathtoDestinationPlot+0xac>
				{
					minlength = path.length;  //if calculated path length is less then minlength then assign path length to minlength
					minpath = path;  //assign calculated path to minpath
    194c:	fe 01       	movw	r30, r28
    194e:	e5 53       	subi	r30, 0x35	; 53
    1950:	ff 4f       	sbci	r31, 0xFF	; 255
    1952:	de 01       	movw	r26, r28
    1954:	11 96       	adiw	r26, 0x01	; 1
    1956:	8a ec       	ldi	r24, 0xCA	; 202
    1958:	0d 90       	ld	r0, X+
    195a:	01 92       	st	Z+, r0
    195c:	81 50       	subi	r24, 0x01	; 1
    195e:	e1 f7       	brne	.-8      	; 0x1958 <selectMinPathtoDestinationPlot+0x9e>
    1960:	24 01       	movw	r4, r8
    1962:	84 01       	movw	r16, r8
    1964:	8a c0       	rjmp	.+276    	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
				}
				else if(path.length == minlength) //if calculated path length and minlength both are same
    1966:	80 16       	cp	r8, r16
    1968:	91 06       	cpc	r9, r17
    196a:	09 f0       	breq	.+2      	; 0x196e <selectMinPathtoDestinationPlot+0xb4>
    196c:	81 c0       	rjmp	.+258    	; 0x1a70 <selectMinPathtoDestinationPlot+0x1b6>
				{
					//then calculate the numbers of turns available in both the paths
					for(int i = 1; i < minlength; i++)
    196e:	f2 e0       	ldi	r31, 0x02	; 2
    1970:	8f 16       	cp	r8, r31
    1972:	91 04       	cpc	r9, r1
    1974:	0c f4       	brge	.+2      	; 0x1978 <selectMinPathtoDestinationPlot+0xbe>
    1976:	7e c0       	rjmp	.+252    	; 0x1a74 <selectMinPathtoDestinationPlot+0x1ba>
    1978:	fe 01       	movw	r30, r28
    197a:	31 96       	adiw	r30, 0x01	; 1
    197c:	de 01       	movw	r26, r28
    197e:	a5 53       	subi	r26, 0x35	; 53
    1980:	bf 4f       	sbci	r27, 0xFF	; 255
    1982:	01 e0       	ldi	r16, 0x01	; 1
    1984:	10 e0       	ldi	r17, 0x00	; 0
    1986:	ee 24       	eor	r14, r14
    1988:	ff 24       	eor	r15, r15
    198a:	cc 24       	eor	r12, r12
    198c:	dd 24       	eor	r13, r13
    198e:	cb 56       	subi	r28, 0x6B	; 107
    1990:	de 4f       	sbci	r29, 0xFE	; 254
    1992:	f9 83       	std	Y+1, r31	; 0x01
    1994:	e8 83       	st	Y, r30
    1996:	c5 59       	subi	r28, 0x95	; 149
    1998:	d1 40       	sbci	r29, 0x01	; 1
*                    turns will be only compared when 2 paths have same length
*				  4) finally return path which has minimum length and minimum turns
* Example Call:	  selectMinPathtoDestinationPlot();
*
*/
struct pathStack selectMinPathtoDestinationPlot()
    199a:	cb 56       	subi	r28, 0x6B	; 107
    199c:	de 4f       	sbci	r29, 0xFE	; 254
    199e:	68 81       	ld	r22, Y
    19a0:	79 81       	ldd	r23, Y+1	; 0x01
    19a2:	c5 59       	subi	r28, 0x95	; 149
    19a4:	d1 40       	sbci	r29, 0x01	; 1
				{
					//then calculate the numbers of turns available in both the paths
					for(int i = 1; i < minlength; i++)
					{
						int a1 = path.path[i-1];
						int a2 = path.path[i];
    19a6:	fb 01       	movw	r30, r22
    19a8:	42 81       	ldd	r20, Z+2	; 0x02
    19aa:	53 81       	ldd	r21, Z+3	; 0x03
						int a3 = path.path[i+1];
    19ac:	0f 5f       	subi	r16, 0xFF	; 255
    19ae:	1f 4f       	sbci	r17, 0xFF	; 255
						if(abs(a1-a2) != abs(a2-a3))
    19b0:	80 81       	ld	r24, Z
    19b2:	91 81       	ldd	r25, Z+1	; 0x01
    19b4:	9c 01       	movw	r18, r24
    19b6:	24 1b       	sub	r18, r20
    19b8:	35 0b       	sbc	r19, r21
    19ba:	1a f4       	brpl	.+6      	; 0x19c2 <selectMinPathtoDestinationPlot+0x108>
    19bc:	30 95       	com	r19
    19be:	21 95       	neg	r18
    19c0:	3f 4f       	sbci	r19, 0xFF	; 255
    19c2:	fb 01       	movw	r30, r22
    19c4:	84 81       	ldd	r24, Z+4	; 0x04
    19c6:	95 81       	ldd	r25, Z+5	; 0x05
    19c8:	ba 01       	movw	r22, r20
    19ca:	68 1b       	sub	r22, r24
    19cc:	79 0b       	sbc	r23, r25
    19ce:	cb 01       	movw	r24, r22
    19d0:	99 23       	and	r25, r25
    19d2:	1c f4       	brge	.+6      	; 0x19da <selectMinPathtoDestinationPlot+0x120>
    19d4:	90 95       	com	r25
    19d6:	81 95       	neg	r24
    19d8:	9f 4f       	sbci	r25, 0xFF	; 255
    19da:	28 17       	cp	r18, r24
    19dc:	39 07       	cpc	r19, r25
    19de:	19 f0       	breq	.+6      	; 0x19e6 <selectMinPathtoDestinationPlot+0x12c>
							path_turn++;
    19e0:	08 94       	sec
    19e2:	c1 1c       	adc	r12, r1
    19e4:	d1 1c       	adc	r13, r1
*                    turns will be only compared when 2 paths have same length
*				  4) finally return path which has minimum length and minimum turns
* Example Call:	  selectMinPathtoDestinationPlot();
*
*/
struct pathStack selectMinPathtoDestinationPlot()
    19e6:	bd 01       	movw	r22, r26
						int a3 = path.path[i+1];
						if(abs(a1-a2) != abs(a2-a3))
							path_turn++;
					
						a1 = minpath.path[i-1];
						a2 = minpath.path[i];
    19e8:	12 96       	adiw	r26, 0x02	; 2
    19ea:	4d 91       	ld	r20, X+
    19ec:	5c 91       	ld	r21, X
    19ee:	13 97       	sbiw	r26, 0x03	; 3
						a3 = minpath.path[i+1];
						if(abs(a1-a2) != abs(a2-a3))
    19f0:	8d 91       	ld	r24, X+
    19f2:	9c 91       	ld	r25, X
    19f4:	11 97       	sbiw	r26, 0x01	; 1
    19f6:	9c 01       	movw	r18, r24
    19f8:	24 1b       	sub	r18, r20
    19fa:	35 0b       	sbc	r19, r21
    19fc:	1a f4       	brpl	.+6      	; 0x1a04 <selectMinPathtoDestinationPlot+0x14a>
    19fe:	30 95       	com	r19
    1a00:	21 95       	neg	r18
    1a02:	3f 4f       	sbci	r19, 0xFF	; 255
    1a04:	fb 01       	movw	r30, r22
    1a06:	84 81       	ldd	r24, Z+4	; 0x04
    1a08:	95 81       	ldd	r25, Z+5	; 0x05
    1a0a:	ba 01       	movw	r22, r20
    1a0c:	68 1b       	sub	r22, r24
    1a0e:	79 0b       	sbc	r23, r25
    1a10:	cb 01       	movw	r24, r22
    1a12:	99 23       	and	r25, r25
    1a14:	1c f4       	brge	.+6      	; 0x1a1c <selectMinPathtoDestinationPlot+0x162>
    1a16:	90 95       	com	r25
    1a18:	81 95       	neg	r24
    1a1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1a1c:	28 17       	cp	r18, r24
    1a1e:	39 07       	cpc	r19, r25
    1a20:	19 f0       	breq	.+6      	; 0x1a28 <selectMinPathtoDestinationPlot+0x16e>
							minpath_turn++;
    1a22:	08 94       	sec
    1a24:	e1 1c       	adc	r14, r1
    1a26:	f1 1c       	adc	r15, r1
    1a28:	cb 56       	subi	r28, 0x6B	; 107
    1a2a:	de 4f       	sbci	r29, 0xFE	; 254
    1a2c:	88 81       	ld	r24, Y
    1a2e:	99 81       	ldd	r25, Y+1	; 0x01
    1a30:	c5 59       	subi	r28, 0x95	; 149
    1a32:	d1 40       	sbci	r29, 0x01	; 1
    1a34:	02 96       	adiw	r24, 0x02	; 2
    1a36:	cb 56       	subi	r28, 0x6B	; 107
    1a38:	de 4f       	sbci	r29, 0xFE	; 254
    1a3a:	99 83       	std	Y+1, r25	; 0x01
    1a3c:	88 83       	st	Y, r24
    1a3e:	c5 59       	subi	r28, 0x95	; 149
    1a40:	d1 40       	sbci	r29, 0x01	; 1
    1a42:	12 96       	adiw	r26, 0x02	; 2
					minpath = path;  //assign calculated path to minpath
				}
				else if(path.length == minlength) //if calculated path length and minlength both are same
				{
					//then calculate the numbers of turns available in both the paths
					for(int i = 1; i < minlength; i++)
    1a44:	08 15       	cp	r16, r8
    1a46:	19 05       	cpc	r17, r9
    1a48:	09 f0       	breq	.+2      	; 0x1a4c <selectMinPathtoDestinationPlot+0x192>
    1a4a:	a7 cf       	rjmp	.-178    	; 0x199a <selectMinPathtoDestinationPlot+0xe0>
						a2 = minpath.path[i];
						a3 = minpath.path[i+1];
						if(abs(a1-a2) != abs(a2-a3))
							minpath_turn++;
					}
					if(path_turn < minpath_turn)  //if the calculated path turn in less then minpath_turn
    1a4c:	ce 14       	cp	r12, r14
    1a4e:	df 04       	cpc	r13, r15
    1a50:	9c f4       	brge	.+38     	; 0x1a78 <selectMinPathtoDestinationPlot+0x1be>
						minpath = path;  //then assign calculated path minpath 
    1a52:	fe 01       	movw	r30, r28
    1a54:	e5 53       	subi	r30, 0x35	; 53
    1a56:	ff 4f       	sbci	r31, 0xFF	; 255
    1a58:	de 01       	movw	r26, r28
    1a5a:	11 96       	adiw	r26, 0x01	; 1
    1a5c:	8a ec       	ldi	r24, 0xCA	; 202
    1a5e:	0d 90       	ld	r0, X+
    1a60:	01 92       	st	Z+, r0
    1a62:	81 50       	subi	r24, 0x01	; 1
    1a64:	e1 f7       	brne	.-8      	; 0x1a5e <selectMinPathtoDestinationPlot+0x1a4>
    1a66:	24 01       	movw	r4, r8
    1a68:	84 01       	movw	r16, r8
    1a6a:	07 c0       	rjmp	.+14     	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
	for(int i = 0; i < 4; i++)  //iterate over all the 4 plot adjacent point stored in pltadjpoints array
	{
		if(pltadjpoints[i] != 0) //if the adjacent point is not 0
		{
			path = findPath(current_pos, pltadjpoints[i]); // calculate the path between current position and selected adjacent point   
			if(path.length != 0)  //if length of calculated path is not 0
    1a6c:	82 01       	movw	r16, r4
    1a6e:	05 c0       	rjmp	.+10     	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
				if(path.length < minlength)  //compare path length with minlength
				{
					minlength = path.length;  //if calculated path length is less then minlength then assign path length to minlength
					minpath = path;  //assign calculated path to minpath
				}
				else if(path.length == minlength) //if calculated path length and minlength both are same
    1a70:	82 01       	movw	r16, r4
    1a72:	03 c0       	rjmp	.+6      	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
				{
					//then calculate the numbers of turns available in both the paths
					for(int i = 1; i < minlength; i++)
    1a74:	82 01       	movw	r16, r4
    1a76:	01 c0       	rjmp	.+2      	; 0x1a7a <selectMinPathtoDestinationPlot+0x1c0>
						a2 = minpath.path[i];
						a3 = minpath.path[i+1];
						if(abs(a1-a2) != abs(a2-a3))
							minpath_turn++;
					}
					if(path_turn < minpath_turn)  //if the calculated path turn in less then minpath_turn
    1a78:	82 01       	movw	r16, r4
	int minlength = 999;  //initialize minlength to infinity
	int path_turn = 0; //initialize turns for the path that is calculated
	int minpath_turn = 0;  //initialize turns for path that is stored in minpath
	struct pathStack path, minpath;  //declare variables to store minpath and calculated path
	minpath.length = 0;  //initialize minpath length to 0. In case of any path not found the length of minpath returned will be 0
	for(int i = 0; i < 4; i++)  //iterate over all the 4 plot adjacent point stored in pltadjpoints array
    1a7a:	a6 14       	cp	r10, r6
    1a7c:	b7 04       	cpc	r11, r7
    1a7e:	09 f0       	breq	.+2      	; 0x1a82 <selectMinPathtoDestinationPlot+0x1c8>
    1a80:	48 cf       	rjmp	.-368    	; 0x1912 <selectMinPathtoDestinationPlot+0x58>
			}
			path_turn = minpath_turn = 0; //reset both path turn and minpath turn to 0
			minlength = minpath.length;	 //assign minpathlength to minlength variable
		}
	}
	return minpath; //finally return calculated minpath. 
    1a82:	d1 01       	movw	r26, r2
    1a84:	fe 01       	movw	r30, r28
    1a86:	e5 53       	subi	r30, 0x35	; 53
    1a88:	ff 4f       	sbci	r31, 0xFF	; 255
    1a8a:	8a ec       	ldi	r24, 0xCA	; 202
    1a8c:	01 90       	ld	r0, Z+
    1a8e:	0d 92       	st	X+, r0
    1a90:	81 50       	subi	r24, 0x01	; 1
    1a92:	e1 f7       	brne	.-8      	; 0x1a8c <selectMinPathtoDestinationPlot+0x1d2>
    1a94:	f1 01       	movw	r30, r2
    1a96:	e8 53       	subi	r30, 0x38	; 56
    1a98:	ff 4f       	sbci	r31, 0xFF	; 255
    1a9a:	51 82       	std	Z+1, r5	; 0x01
    1a9c:	40 82       	st	Z, r4
}
    1a9e:	c1 01       	movw	r24, r2
    1aa0:	ca 56       	subi	r28, 0x6A	; 106
    1aa2:	de 4f       	sbci	r29, 0xFE	; 254
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	de bf       	out	0x3e, r29	; 62
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	cd bf       	out	0x3d, r28	; 61
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	1f 91       	pop	r17
    1ab4:	0f 91       	pop	r16
    1ab6:	ff 90       	pop	r15
    1ab8:	ef 90       	pop	r14
    1aba:	df 90       	pop	r13
    1abc:	cf 90       	pop	r12
    1abe:	bf 90       	pop	r11
    1ac0:	af 90       	pop	r10
    1ac2:	9f 90       	pop	r9
    1ac4:	8f 90       	pop	r8
    1ac6:	7f 90       	pop	r7
    1ac8:	6f 90       	pop	r6
    1aca:	5f 90       	pop	r5
    1acc:	4f 90       	pop	r4
    1ace:	3f 90       	pop	r3
    1ad0:	2f 90       	pop	r2
    1ad2:	08 95       	ret

00001ad4 <follow>:
*				  or else it will follow the line
* Example Call:	  follow();
*
*/
void follow()
{
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
	while(1)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    1ad8:	83 e0       	ldi	r24, 0x03	; 3
    1ada:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
    1ade:	80 93 6a 06 	sts	0x066A, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    1ae2:	82 e0       	ldi	r24, 0x02	; 2
    1ae4:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
    1ae8:	80 93 69 06 	sts	0x0669, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
    1af2:	80 93 68 06 	sts	0x0668, r24

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    1af6:	81 e0       	ldi	r24, 0x01	; 1
    1af8:	61 e0       	ldi	r22, 0x01	; 1
    1afa:	43 e0       	ldi	r20, 0x03	; 3
    1afc:	0e 94 66 06 	call	0xccc	; 0xccc <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    1b00:	81 e0       	ldi	r24, 0x01	; 1
    1b02:	65 e0       	ldi	r22, 0x05	; 5
    1b04:	42 e0       	ldi	r20, 0x02	; 2
    1b06:	0e 94 66 06 	call	0xccc	; 0xccc <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line 
    1b0a:	81 e0       	ldi	r24, 0x01	; 1
    1b0c:	69 e0       	ldi	r22, 0x09	; 9
    1b0e:	41 e0       	ldi	r20, 0x01	; 1
    1b10:	0e 94 66 06 	call	0xccc	; 0xccc <print_sensor>
		
		//sum value will be greater than 120 if bot is on the one of the node or midpoint
		int sum = Left_white_line + Center_white_line + Right_white_line;
    1b14:	30 91 6a 06 	lds	r19, 0x066A
    1b18:	20 91 69 06 	lds	r18, 0x0669
    1b1c:	40 91 68 06 	lds	r20, 0x0668
    1b20:	82 2f       	mov	r24, r18
    1b22:	90 e0       	ldi	r25, 0x00	; 0
    1b24:	83 0f       	add	r24, r19
    1b26:	91 1d       	adc	r25, r1
    1b28:	84 0f       	add	r24, r20
    1b2a:	91 1d       	adc	r25, r1
		
		if(sum > 120)  //if sum value is greater than 120 then bot is on the node or midpoint
    1b2c:	89 37       	cpi	r24, 0x79	; 121
    1b2e:	91 05       	cpc	r25, r1
    1b30:	0c f4       	brge	.+2      	; 0x1b34 <follow+0x60>
    1b32:	6c c0       	rjmp	.+216    	; 0x1c0c <follow+0x138>
		{
			//below condition will be used at the start of the run. At start the current_pos of search robot will be initialized to 0
            //when it encounters the node then it will be set to 15 according to our coordinate system
			if(current_pos == 0)
    1b34:	80 91 9b 06 	lds	r24, 0x069B
    1b38:	90 91 9c 06 	lds	r25, 0x069C
    1b3c:	00 97       	sbiw	r24, 0x00	; 0
    1b3e:	99 f4       	brne	.+38     	; 0x1b66 <follow+0x92>
			{
				current_pos = 15;
    1b40:	8f e0       	ldi	r24, 0x0F	; 15
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	90 93 9c 06 	sts	0x069C, r25
    1b48:	80 93 9b 06 	sts	0x069B, r24
				orientation = point_north; //set orientation to north because at the start of the run bot will be facing north
    1b4c:	80 91 9d 06 	lds	r24, 0x069D
    1b50:	90 91 9e 06 	lds	r25, 0x069E
    1b54:	90 93 96 06 	sts	0x0696, r25
    1b58:	80 93 95 06 	sts	0x0695, r24
				forward_mm(60);
    1b5c:	8c e3       	ldi	r24, 0x3C	; 60
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	0e 94 c8 05 	call	0xb90	; 0xb90 <forward_mm>
				return;
    1b64:	79 c0       	rjmp	.+242    	; 0x1c58 <follow+0x184>
			}
			//whenever the node is encountered the change_location function will change current position of the robot
			//so before changing the location send previous node position where search came from. This information will used by
			//rescue robot to release node from search robot path
			UDR0 = (char)current_pos;  //send search robot position before changing it
    1b66:	c6 ec       	ldi	r28, 0xC6	; 198
    1b68:	d0 e0       	ldi	r29, 0x00	; 0
    1b6a:	88 83       	st	Y, r24
    1b6c:	8f ef       	ldi	r24, 0xFF	; 255
    1b6e:	97 e4       	ldi	r25, 0x47	; 71
    1b70:	01 97       	sbiw	r24, 0x01	; 1
    1b72:	f1 f7       	brne	.-4      	; 0x1b70 <follow+0x9c>
    1b74:	00 c0       	rjmp	.+0      	; 0x1b76 <follow+0xa2>
    1b76:	00 00       	nop
			_delay_ms(5);  //wait for data to be sent

			change_location(current_pos);  //change the current position after encountering the node
    1b78:	80 91 9b 06 	lds	r24, 0x069B
    1b7c:	90 91 9c 06 	lds	r25, 0x069C
    1b80:	0e 94 03 09 	call	0x1206	; 0x1206 <change_location>

			//and also send the new current position. It will be used by rescue robot to exclude search robot detection as a black debris
			UDR0 = (char)current_pos; //send search robot position after changing it
    1b84:	80 91 9b 06 	lds	r24, 0x069B
    1b88:	88 83       	st	Y, r24
    1b8a:	8f ef       	ldi	r24, 0xFF	; 255
    1b8c:	97 e4       	ldi	r25, 0x47	; 71
    1b8e:	01 97       	sbiw	r24, 0x01	; 1
    1b90:	f1 f7       	brne	.-4      	; 0x1b8e <follow+0xba>
    1b92:	00 c0       	rjmp	.+0      	; 0x1b94 <follow+0xc0>
    1b94:	00 00       	nop
			_delay_ms(5);  //wait for data to be sent
			UDR0 = 2;  //send terminal packet as 2 indicating previous data sent must be search robots current position
    1b96:	82 e0       	ldi	r24, 0x02	; 2
    1b98:	88 83       	st	Y, r24
    1b9a:	8f ef       	ldi	r24, 0xFF	; 255
    1b9c:	97 e4       	ldi	r25, 0x47	; 71
    1b9e:	01 97       	sbiw	r24, 0x01	; 1
    1ba0:	f1 f7       	brne	.-4      	; 0x1b9e <follow+0xca>
    1ba2:	00 c0       	rjmp	.+0      	; 0x1ba4 <follow+0xd0>
    1ba4:	00 00       	nop
			_delay_ms(5);  //wait for data to be sent
			
			velocity(255,255);
    1ba6:	8f ef       	ldi	r24, 0xFF	; 255
    1ba8:	6f ef       	ldi	r22, 0xFF	; 255
    1baa:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
			
			//extract x and y from current position
			int x = current_pos % 10;  
    1bae:	c0 91 9b 06 	lds	r28, 0x069B
    1bb2:	d0 91 9c 06 	lds	r29, 0x069C
			int y = current_pos / 10;
			
			//both search and rescue robot will scan mid point for black debris for total of 2 times. One here in follow function before going forward mm
			//and second in travel function after going forward mm. This is to ensure that black debris detection happens properly
			scanForBlackDebris();
    1bb6:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <scanForBlackDebris>
			_delay_ms(5);  //wait for data to be sent
			
			velocity(255,255);
			
			//extract x and y from current position
			int x = current_pos % 10;  
    1bba:	ce 01       	movw	r24, r28
    1bbc:	6a e0       	ldi	r22, 0x0A	; 10
    1bbe:	70 e0       	ldi	r23, 0x00	; 0
    1bc0:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			//both search and rescue robot will scan mid point for black debris for total of 2 times. One here in follow function before going forward mm
			//and second in travel function after going forward mm. This is to ensure that black debris detection happens properly
			scanForBlackDebris();
			
			//forward mm is done to ensure proper turn on nodes and avoid double detection of nodes and mid points
			if(x % 2 != 0 && y % 2 != 0) //if its a node for which both x and y coordinate will be odd go 45 mm forward 
    1bc4:	80 ff       	sbrs	r24, 0
    1bc6:	0c c0       	rjmp	.+24     	; 0x1be0 <follow+0x10c>
			
			velocity(255,255);
			
			//extract x and y from current position
			int x = current_pos % 10;  
			int y = current_pos / 10;
    1bc8:	ce 01       	movw	r24, r28
    1bca:	6a e0       	ldi	r22, 0x0A	; 10
    1bcc:	70 e0       	ldi	r23, 0x00	; 0
    1bce:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			//both search and rescue robot will scan mid point for black debris for total of 2 times. One here in follow function before going forward mm
			//and second in travel function after going forward mm. This is to ensure that black debris detection happens properly
			scanForBlackDebris();
			
			//forward mm is done to ensure proper turn on nodes and avoid double detection of nodes and mid points
			if(x % 2 != 0 && y % 2 != 0) //if its a node for which both x and y coordinate will be odd go 45 mm forward 
    1bd2:	60 ff       	sbrs	r22, 0
    1bd4:	05 c0       	rjmp	.+10     	; 0x1be0 <follow+0x10c>
				forward_mm(45);
    1bd6:	8d e2       	ldi	r24, 0x2D	; 45
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	0e 94 c8 05 	call	0xb90	; 0xb90 <forward_mm>
    1bde:	04 c0       	rjmp	.+8      	; 0x1be8 <follow+0x114>
			else                       //else go 20 mm forward
				forward_mm(20);
    1be0:	84 e1       	ldi	r24, 0x14	; 20
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	0e 94 c8 05 	call	0xb90	; 0xb90 <forward_mm>
			
			//check stopSearchRobot flag if it is 1 then stop the robot. This is used in collision avoidance. Whenever rescue robot is standing still on 
			//search robots path rescue robot will send packet and stopSearchRobot will be set 1 to indicating search robot to stop. after telling search 
			//robot to stop rescue robot will go to the nearest free node and after reaching nearest free node, rescue robot will tell search robot move
			//by sending another packet where stopSearchRobot will be set to 0
			if(stopSearchRobot == 1)  //stopSearchRobot is one then stop the robot
    1be8:	80 91 5e 06 	lds	r24, 0x065E
    1bec:	90 91 5f 06 	lds	r25, 0x065F
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	91 05       	cpc	r25, r1
    1bf4:	11 f4       	brne	.+4      	; 0x1bfa <follow+0x126>
				stop();
    1bf6:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
			while(stopSearchRobot != 0);  //wait while stopSearchRobot becomes 0
    1bfa:	80 91 5e 06 	lds	r24, 0x065E
    1bfe:	90 91 5f 06 	lds	r25, 0x065F
    1c02:	00 97       	sbiw	r24, 0x00	; 0
    1c04:	d1 f7       	brne	.-12     	; 0x1bfa <follow+0x126>
			forward();  //after stopSearchRobot becomes 0 search robot can move now
    1c06:	0e 94 01 05 	call	0xa02	; 0xa02 <forward>
			
			break;  //break the line following loop after encountering node to perform further actions
    1c0a:	26 c0       	rjmp	.+76     	; 0x1c58 <follow+0x184>
		}		
		else  //if no node is encounter then simply follow the line
		{
			if(Center_white_line>15)
    1c0c:	20 31       	cpi	r18, 0x10	; 16
    1c0e:	38 f0       	brcs	.+14     	; 0x1c1e <follow+0x14a>
			{
				forward();
    1c10:	0e 94 01 05 	call	0xa02	; 0xa02 <forward>
				velocity(255,255);
    1c14:	8f ef       	ldi	r24, 0xFF	; 255
    1c16:	6f ef       	ldi	r22, 0xFF	; 255
    1c18:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
    1c1c:	5d cf       	rjmp	.-326    	; 0x1ad8 <follow+0x4>
			}

			else if(Left_white_line>15)
    1c1e:	30 31       	cpi	r19, 0x10	; 16
    1c20:	48 f0       	brcs	.+18     	; 0x1c34 <follow+0x160>
			{
				stop();
    1c22:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
				velocity(140,140);
    1c26:	8c e8       	ldi	r24, 0x8C	; 140
    1c28:	6c e8       	ldi	r22, 0x8C	; 140
    1c2a:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
				left();
    1c2e:	0e 94 09 05 	call	0xa12	; 0xa12 <left>
    1c32:	52 cf       	rjmp	.-348    	; 0x1ad8 <follow+0x4>
			}

			else if(Right_white_line>15)
    1c34:	40 31       	cpi	r20, 0x10	; 16
    1c36:	48 f0       	brcs	.+18     	; 0x1c4a <follow+0x176>
			{
				stop();
    1c38:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
				velocity(140,140);
    1c3c:	8c e8       	ldi	r24, 0x8C	; 140
    1c3e:	6c e8       	ldi	r22, 0x8C	; 140
    1c40:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
				right();
    1c44:	0e 94 0d 05 	call	0xa1a	; 0xa1a <right>
    1c48:	47 cf       	rjmp	.-370    	; 0x1ad8 <follow+0x4>
			}
			
			else if(Center_white_line<=15 && Left_white_line<=15 && Right_white_line<=15)
			{
				forward();
    1c4a:	0e 94 01 05 	call	0xa02	; 0xa02 <forward>
				velocity(255,255);
    1c4e:	8f ef       	ldi	r24, 0xFF	; 255
    1c50:	6f ef       	ldi	r22, 0xFF	; 255
    1c52:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
    1c56:	40 cf       	rjmp	.-384    	; 0x1ad8 <follow+0x4>
			}
		}
	}
}
    1c58:	df 91       	pop	r29
    1c5a:	cf 91       	pop	r28
    1c5c:	08 95       	ret

00001c5e <scanPlots>:
*				  2) After performing IDR update scannedPlot matrix that the plot has been scanned
* Example Call:	  scanPlots(22, 44);
*
*/
void scanPlots(int plot1, int plot2)
{
    1c5e:	0f 93       	push	r16
    1c60:	1f 93       	push	r17
    1c62:	cf 93       	push	r28
    1c64:	df 93       	push	r29
    1c66:	ec 01       	movw	r28, r24
    1c68:	8b 01       	movw	r16, r22
	int i, j;  //variable to store calculated row and column to update scannedPlot matrix 
	stop();  //stop the robot before scanning the plot
    1c6a:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
	
	//If both the passed plot coordinates are 0 than both plots are scanned then return from the function
	if(plot1 == 0 && plot2 == 0)
    1c6e:	20 97       	sbiw	r28, 0x00	; 0
    1c70:	21 f4       	brne	.+8      	; 0x1c7a <scanPlots+0x1c>
    1c72:	01 15       	cp	r16, r1
    1c74:	11 05       	cpc	r17, r1
    1c76:	51 f5       	brne	.+84     	; 0x1ccc <scanPlots+0x6e>
    1c78:	50 c0       	rjmp	.+160    	; 0x1d1a <scanPlots+0xbc>
		return;
		
	if(plot1 != 0)  //if coordinate of plot1 is not 0 means it is a valid coordinate
	{
		performIDR(plot1);  //perform IDR on that plot
    1c7a:	ce 01       	movw	r24, r28
    1c7c:	0e 94 0f 11 	call	0x221e	; 0x221e <performIDR>
		
		i = plot1 / 20 - 1;  //calculate row of matrix which needs to updated
    1c80:	ce 01       	movw	r24, r28
    1c82:	64 e1       	ldi	r22, 0x14	; 20
    1c84:	70 e0       	ldi	r23, 0x00	; 0
    1c86:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
		j = (plot1 % 10)/2 - 1;  //calculate column of the matrix which needs to updated
		
		scannedPlot[i][j] = 1;  //set in place of calculated row and column indicating that plot has been scanned
    1c8a:	fb 01       	movw	r30, r22
    1c8c:	31 97       	sbiw	r30, 0x01	; 1
	if(plot1 != 0)  //if coordinate of plot1 is not 0 means it is a valid coordinate
	{
		performIDR(plot1);  //perform IDR on that plot
		
		i = plot1 / 20 - 1;  //calculate row of matrix which needs to updated
		j = (plot1 % 10)/2 - 1;  //calculate column of the matrix which needs to updated
    1c8e:	ce 01       	movw	r24, r28
    1c90:	6a e0       	ldi	r22, 0x0A	; 10
    1c92:	70 e0       	ldi	r23, 0x00	; 0
    1c94:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    1c98:	9c 01       	movw	r18, r24
    1c9a:	99 23       	and	r25, r25
    1c9c:	14 f4       	brge	.+4      	; 0x1ca2 <scanPlots+0x44>
    1c9e:	2f 5f       	subi	r18, 0xFF	; 255
    1ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca2:	c9 01       	movw	r24, r18
    1ca4:	95 95       	asr	r25
    1ca6:	87 95       	ror	r24
		
		scannedPlot[i][j] = 1;  //set in place of calculated row and column indicating that plot has been scanned
    1ca8:	ee 0f       	add	r30, r30
    1caa:	ff 1f       	adc	r31, r31
    1cac:	ee 0f       	add	r30, r30
    1cae:	ff 1f       	adc	r31, r31
    1cb0:	8e 0f       	add	r24, r30
    1cb2:	9f 1f       	adc	r25, r31
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	ee 0f       	add	r30, r30
    1cb8:	ff 1f       	adc	r31, r31
    1cba:	e7 59       	subi	r30, 0x97	; 151
    1cbc:	f9 4f       	sbci	r31, 0xF9	; 249
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	91 83       	std	Z+1, r25	; 0x01
    1cc4:	80 83       	st	Z, r24
	} 
	if(plot2 != 0)  //if coordinate of plot2 is not 0 means it is a valid coordinate
    1cc6:	01 15       	cp	r16, r1
    1cc8:	11 05       	cpc	r17, r1
    1cca:	39 f1       	breq	.+78     	; 0x1d1a <scanPlots+0xbc>
	{
		performIDR(plot2);  //perform IDR on that plot
    1ccc:	c8 01       	movw	r24, r16
    1cce:	0e 94 0f 11 	call	0x221e	; 0x221e <performIDR>
		
		i = plot2/20 - 1;  //calculate row of matrix which needs to updated
    1cd2:	c8 01       	movw	r24, r16
    1cd4:	64 e1       	ldi	r22, 0x14	; 20
    1cd6:	70 e0       	ldi	r23, 0x00	; 0
    1cd8:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    1cdc:	9b 01       	movw	r18, r22
		j = (plot2%10)/2 - 1;  //calculate column of the matrix which needs to updated
		
		scannedPlot[i][j] = 1;  //set in place of calculated row and column indicating that plot has been scanned
    1cde:	21 50       	subi	r18, 0x01	; 1
    1ce0:	30 40       	sbci	r19, 0x00	; 0
	if(plot2 != 0)  //if coordinate of plot2 is not 0 means it is a valid coordinate
	{
		performIDR(plot2);  //perform IDR on that plot
		
		i = plot2/20 - 1;  //calculate row of matrix which needs to updated
		j = (plot2%10)/2 - 1;  //calculate column of the matrix which needs to updated
    1ce2:	c8 01       	movw	r24, r16
    1ce4:	6a e0       	ldi	r22, 0x0A	; 10
    1ce6:	70 e0       	ldi	r23, 0x00	; 0
    1ce8:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    1cec:	ac 01       	movw	r20, r24
    1cee:	99 23       	and	r25, r25
    1cf0:	14 f4       	brge	.+4      	; 0x1cf6 <scanPlots+0x98>
    1cf2:	4f 5f       	subi	r20, 0xFF	; 255
    1cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cf6:	ca 01       	movw	r24, r20
    1cf8:	95 95       	asr	r25
    1cfa:	87 95       	ror	r24
		
		scannedPlot[i][j] = 1;  //set in place of calculated row and column indicating that plot has been scanned
    1cfc:	f9 01       	movw	r30, r18
    1cfe:	ee 0f       	add	r30, r30
    1d00:	ff 1f       	adc	r31, r31
    1d02:	ee 0f       	add	r30, r30
    1d04:	ff 1f       	adc	r31, r31
    1d06:	e8 0f       	add	r30, r24
    1d08:	f9 1f       	adc	r31, r25
    1d0a:	ee 0f       	add	r30, r30
    1d0c:	ff 1f       	adc	r31, r31
    1d0e:	e7 59       	subi	r30, 0x97	; 151
    1d10:	f9 4f       	sbci	r31, 0xF9	; 249
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	90 e0       	ldi	r25, 0x00	; 0
    1d16:	91 83       	std	Z+1, r25	; 0x01
    1d18:	80 83       	st	Z, r24
	}
}
    1d1a:	df 91       	pop	r29
    1d1c:	cf 91       	pop	r28
    1d1e:	1f 91       	pop	r17
    1d20:	0f 91       	pop	r16
    1d22:	08 95       	ret

00001d24 <scanForWhiteDebris>:
*				  3) call scanPlots function by passing two calculated plot coordinate
* Example Call:	  scanForWhiteDebris();
*
*/
void scanForWhiteDebris()
{
    1d24:	0f 93       	push	r16
    1d26:	1f 93       	push	r17
    1d28:	cf 93       	push	r28
    1d2a:	df 93       	push	r29
	int x = current_pos % 10;  //extract x from current position
    1d2c:	20 91 9b 06 	lds	r18, 0x069B
    1d30:	30 91 9c 06 	lds	r19, 0x069C
    1d34:	c9 01       	movw	r24, r18
    1d36:	6a e0       	ldi	r22, 0x0A	; 10
    1d38:	70 e0       	ldi	r23, 0x00	; 0
    1d3a:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
	int plot1, plot2;  //variable to store plot positions
	int i, j;  //variable to store calculated row and column to update scannedPlot matrix
	int NS = 10, EW = 1;  //constants to add in current position based on orientation
	
	//if either x or y is even then robot is standing on mid point then only do the finding plot operation
	if(x % 2 == 0 || y % 2 == 0)
    1d3e:	80 ff       	sbrs	r24, 0
    1d40:	07 c0       	rjmp	.+14     	; 0x1d50 <scanForWhiteDebris+0x2c>
*
*/
void scanForWhiteDebris()
{
	int x = current_pos % 10;  //extract x from current position
	int y = current_pos / 10;  //extract y from current position
    1d42:	c9 01       	movw	r24, r18
    1d44:	6a e0       	ldi	r22, 0x0A	; 10
    1d46:	70 e0       	ldi	r23, 0x00	; 0
    1d48:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
	int plot1, plot2;  //variable to store plot positions
	int i, j;  //variable to store calculated row and column to update scannedPlot matrix
	int NS = 10, EW = 1;  //constants to add in current position based on orientation
	
	//if either x or y is even then robot is standing on mid point then only do the finding plot operation
	if(x % 2 == 0 || y % 2 == 0)
    1d4c:	60 fd       	sbrc	r22, 0
    1d4e:	92 c0       	rjmp	.+292    	; 0x1e74 <scanForWhiteDebris+0x150>
	{
		//if orientation is either north or south then add EW constant to current position to get two adjacent plot
		if(orientation == point_north || orientation == point_south)
    1d50:	80 91 95 06 	lds	r24, 0x0695
    1d54:	90 91 96 06 	lds	r25, 0x0696
    1d58:	40 91 9d 06 	lds	r20, 0x069D
    1d5c:	50 91 9e 06 	lds	r21, 0x069E
    1d60:	84 17       	cp	r24, r20
    1d62:	95 07       	cpc	r25, r21
    1d64:	39 f0       	breq	.+14     	; 0x1d74 <scanForWhiteDebris+0x50>
    1d66:	40 91 12 02 	lds	r20, 0x0212
    1d6a:	50 91 13 02 	lds	r21, 0x0213
    1d6e:	84 17       	cp	r24, r20
    1d70:	95 07       	cpc	r25, r21
    1d72:	31 f4       	brne	.+12     	; 0x1d80 <scanForWhiteDebris+0x5c>
		{
			plot1 = current_pos - EW;  //do minus EW to get left side of plot
    1d74:	89 01       	movw	r16, r18
    1d76:	01 50       	subi	r16, 0x01	; 1
    1d78:	10 40       	sbci	r17, 0x00	; 0
			plot2 = current_pos + EW;  //do plus EW to get right side of plot
    1d7a:	e9 01       	movw	r28, r18
    1d7c:	21 96       	adiw	r28, 0x01	; 1
    1d7e:	05 c0       	rjmp	.+10     	; 0x1d8a <scanForWhiteDebris+0x66>
		}
		//else orientation is either east or west then add NS constant to current position to get two adjacent plot
		else
		{
			plot1 = current_pos - NS;  //do minus NS to get left side of plot
    1d80:	89 01       	movw	r16, r18
    1d82:	0a 50       	subi	r16, 0x0A	; 10
    1d84:	10 40       	sbci	r17, 0x00	; 0
			plot2 = current_pos + NS;  //do plus NS to get right side of plot
    1d86:	e9 01       	movw	r28, r18
    1d88:	2a 96       	adiw	r28, 0x0a	; 10
		}						
		
		//check if plot is valid
		if(isPlotValid(plot1))
    1d8a:	c8 01       	movw	r24, r16
    1d8c:	0e 94 f5 07 	call	0xfea	; 0xfea <isPlotValid>
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	51 f1       	breq	.+84     	; 0x1de8 <scanForWhiteDebris+0xc4>
		{
			x = plot1 % 10;
			y = plot1 / 10;
    1d94:	c8 01       	movw	r24, r16
    1d96:	6a e0       	ldi	r22, 0x0A	; 10
    1d98:	70 e0       	ldi	r23, 0x00	; 0
    1d9a:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			
			i = y / 2 - 1;
    1d9e:	cb 01       	movw	r24, r22
    1da0:	99 23       	and	r25, r25
    1da2:	0c f4       	brge	.+2      	; 0x1da6 <scanForWhiteDebris+0x82>
    1da4:	01 96       	adiw	r24, 0x01	; 1
    1da6:	fc 01       	movw	r30, r24
    1da8:	f5 95       	asr	r31
    1daa:	e7 95       	ror	r30
			j = x / 2 - 1;
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
    1dac:	31 97       	sbiw	r30, 0x01	; 1
		}						
		
		//check if plot is valid
		if(isPlotValid(plot1))
		{
			x = plot1 % 10;
    1dae:	c8 01       	movw	r24, r16
    1db0:	6a e0       	ldi	r22, 0x0A	; 10
    1db2:	70 e0       	ldi	r23, 0x00	; 0
    1db4:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			y = plot1 / 10;
			
			i = y / 2 - 1;
			j = x / 2 - 1;
    1db8:	99 23       	and	r25, r25
    1dba:	0c f4       	brge	.+2      	; 0x1dbe <scanForWhiteDebris+0x9a>
    1dbc:	01 96       	adiw	r24, 0x01	; 1
    1dbe:	9c 01       	movw	r18, r24
    1dc0:	35 95       	asr	r19
    1dc2:	27 95       	ror	r18
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
    1dc4:	cf 01       	movw	r24, r30
    1dc6:	88 0f       	add	r24, r24
    1dc8:	99 1f       	adc	r25, r25
    1dca:	88 0f       	add	r24, r24
    1dcc:	99 1f       	adc	r25, r25
    1dce:	82 0f       	add	r24, r18
    1dd0:	93 1f       	adc	r25, r19
    1dd2:	fc 01       	movw	r30, r24
    1dd4:	ee 0f       	add	r30, r30
    1dd6:	ff 1f       	adc	r31, r31
    1dd8:	e7 59       	subi	r30, 0x97	; 151
    1dda:	f9 4f       	sbci	r31, 0xF9	; 249
    1ddc:	80 81       	ld	r24, Z
    1dde:	91 81       	ldd	r25, Z+1	; 0x01
    1de0:	81 30       	cpi	r24, 0x01	; 1
    1de2:	91 05       	cpc	r25, r1
    1de4:	31 f4       	brne	.+12     	; 0x1df2 <scanForWhiteDebris+0xce>
    1de6:	03 c0       	rjmp	.+6      	; 0x1dee <scanForWhiteDebris+0xca>
				plot1 = 0;  //if it is already scanned then set it 0
		}
		else  //if plot is not valid means it is outside the arena then set it 0
			plot1=0;
    1de8:	00 e0       	ldi	r16, 0x00	; 0
    1dea:	10 e0       	ldi	r17, 0x00	; 0
    1dec:	02 c0       	rjmp	.+4      	; 0x1df2 <scanForWhiteDebris+0xce>
			i = y / 2 - 1;
			j = x / 2 - 1;
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
				plot1 = 0;  //if it is already scanned then set it 0
    1dee:	00 e0       	ldi	r16, 0x00	; 0
    1df0:	10 e0       	ldi	r17, 0x00	; 0
		}
		else  //if plot is not valid means it is outside the arena then set it 0
			plot1=0;
		
		//check if plot is valid
		if(isPlotValid(plot2))
    1df2:	ce 01       	movw	r24, r28
    1df4:	0e 94 f5 07 	call	0xfea	; 0xfea <isPlotValid>
    1df8:	00 97       	sbiw	r24, 0x00	; 0
    1dfa:	51 f1       	breq	.+84     	; 0x1e50 <scanForWhiteDebris+0x12c>
		{
			x = plot2 % 10;
			y = plot2 / 10;
    1dfc:	ce 01       	movw	r24, r28
    1dfe:	6a e0       	ldi	r22, 0x0A	; 10
    1e00:	70 e0       	ldi	r23, 0x00	; 0
    1e02:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			
			i = y/2 - 1;
    1e06:	cb 01       	movw	r24, r22
    1e08:	99 23       	and	r25, r25
    1e0a:	0c f4       	brge	.+2      	; 0x1e0e <scanForWhiteDebris+0xea>
    1e0c:	01 96       	adiw	r24, 0x01	; 1
    1e0e:	fc 01       	movw	r30, r24
    1e10:	f5 95       	asr	r31
    1e12:	e7 95       	ror	r30
			j = x/2 - 1;
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
    1e14:	31 97       	sbiw	r30, 0x01	; 1
			plot1=0;
		
		//check if plot is valid
		if(isPlotValid(plot2))
		{
			x = plot2 % 10;
    1e16:	ce 01       	movw	r24, r28
    1e18:	6a e0       	ldi	r22, 0x0A	; 10
    1e1a:	70 e0       	ldi	r23, 0x00	; 0
    1e1c:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
			y = plot2 / 10;
			
			i = y/2 - 1;
			j = x/2 - 1;
    1e20:	99 23       	and	r25, r25
    1e22:	0c f4       	brge	.+2      	; 0x1e26 <scanForWhiteDebris+0x102>
    1e24:	01 96       	adiw	r24, 0x01	; 1
    1e26:	9c 01       	movw	r18, r24
    1e28:	35 95       	asr	r19
    1e2a:	27 95       	ror	r18
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
    1e2c:	cf 01       	movw	r24, r30
    1e2e:	88 0f       	add	r24, r24
    1e30:	99 1f       	adc	r25, r25
    1e32:	88 0f       	add	r24, r24
    1e34:	99 1f       	adc	r25, r25
    1e36:	82 0f       	add	r24, r18
    1e38:	93 1f       	adc	r25, r19
    1e3a:	fc 01       	movw	r30, r24
    1e3c:	ee 0f       	add	r30, r30
    1e3e:	ff 1f       	adc	r31, r31
    1e40:	e7 59       	subi	r30, 0x97	; 151
    1e42:	f9 4f       	sbci	r31, 0xF9	; 249
    1e44:	80 81       	ld	r24, Z
    1e46:	91 81       	ldd	r25, Z+1	; 0x01
    1e48:	81 30       	cpi	r24, 0x01	; 1
    1e4a:	91 05       	cpc	r25, r1
    1e4c:	31 f4       	brne	.+12     	; 0x1e5a <scanForWhiteDebris+0x136>
    1e4e:	03 c0       	rjmp	.+6      	; 0x1e56 <scanForWhiteDebris+0x132>
				plot2 = 0;
		}
		else  //if plot is not valid means it is outside the arena then set it 0
			plot2=0;
    1e50:	c0 e0       	ldi	r28, 0x00	; 0
    1e52:	d0 e0       	ldi	r29, 0x00	; 0
    1e54:	02 c0       	rjmp	.+4      	; 0x1e5a <scanForWhiteDebris+0x136>
			i = y/2 - 1;
			j = x/2 - 1;
			
			//check if plot is already scanned or not by checking in scannedPlot matrix
			if(scannedPlot[i][j] == 1)
				plot2 = 0;
    1e56:	c0 e0       	ldi	r28, 0x00	; 0
    1e58:	d0 e0       	ldi	r29, 0x00	; 0
		}
		else  //if plot is not valid means it is outside the arena then set it 0
			plot2=0;
		
		//call scanPlots function by passing two calculated plot to perform further operation 
		scanPlots(plot1, plot2);
    1e5a:	c8 01       	movw	r24, r16
    1e5c:	be 01       	movw	r22, r28
    1e5e:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <scanPlots>
		
		//If search robot has to scan two plots form its mid point and both of them has survivor then rescue robot will perform MSR
		//after rescue robot has done scanning both the plots for survivor type. This done to prevent collision. This done by sending a packet to
		//rescue robot which indicates that search robot has scanned both adjacent plot and rescue robot is allowed to service
		UDR0 = 5;
    1e62:	85 e0       	ldi	r24, 0x05	; 5
    1e64:	80 93 c6 00 	sts	0x00C6, r24
    1e68:	8f ef       	ldi	r24, 0xFF	; 255
    1e6a:	97 e4       	ldi	r25, 0x47	; 71
    1e6c:	01 97       	sbiw	r24, 0x01	; 1
    1e6e:	f1 f7       	brne	.-4      	; 0x1e6c <scanForWhiteDebris+0x148>
    1e70:	00 c0       	rjmp	.+0      	; 0x1e72 <scanForWhiteDebris+0x14e>
    1e72:	00 00       	nop
		_delay_ms(5);
	}
}
    1e74:	df 91       	pop	r29
    1e76:	cf 91       	pop	r28
    1e78:	1f 91       	pop	r17
    1e7a:	0f 91       	pop	r16
    1e7c:	08 95       	ret

00001e7e <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    1e7e:	0e 94 9b 03 	call	0x736	; 0x736 <filter_red>
	pulse=0; //reset the count to 0
    1e82:	10 92 56 06 	sts	0x0656, r1
    1e86:	10 92 57 06 	sts	0x0657, r1
    1e8a:	10 92 58 06 	sts	0x0658, r1
    1e8e:	10 92 59 06 	sts	0x0659, r1
    1e92:	8f ef       	ldi	r24, 0xFF	; 255
    1e94:	9f e7       	ldi	r25, 0x7F	; 127
    1e96:	a4 e0       	ldi	r26, 0x04	; 4
    1e98:	81 50       	subi	r24, 0x01	; 1
    1e9a:	90 40       	sbci	r25, 0x00	; 0
    1e9c:	a0 40       	sbci	r26, 0x00	; 0
    1e9e:	e1 f7       	brne	.-8      	; 0x1e98 <red_read+0x1a>
    1ea0:	00 c0       	rjmp	.+0      	; 0x1ea2 <red_read+0x24>
    1ea2:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    1ea4:	80 91 56 06 	lds	r24, 0x0656
    1ea8:	90 91 57 06 	lds	r25, 0x0657
    1eac:	a0 91 58 06 	lds	r26, 0x0658
    1eb0:	b0 91 59 06 	lds	r27, 0x0659
    1eb4:	80 93 a9 06 	sts	0x06A9, r24
    1eb8:	90 93 aa 06 	sts	0x06AA, r25
    1ebc:	a0 93 ab 06 	sts	0x06AB, r26
    1ec0:	b0 93 ac 06 	sts	0x06AC, r27
}
    1ec4:	08 95       	ret

00001ec6 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    1ec6:	0e 94 9e 03 	call	0x73c	; 0x73c <filter_green>
	pulse=0; //reset the count to 0
    1eca:	10 92 56 06 	sts	0x0656, r1
    1ece:	10 92 57 06 	sts	0x0657, r1
    1ed2:	10 92 58 06 	sts	0x0658, r1
    1ed6:	10 92 59 06 	sts	0x0659, r1
    1eda:	89 e9       	ldi	r24, 0x99	; 153
    1edc:	99 ed       	ldi	r25, 0xD9	; 217
    1ede:	a5 e0       	ldi	r26, 0x05	; 5
    1ee0:	81 50       	subi	r24, 0x01	; 1
    1ee2:	90 40       	sbci	r25, 0x00	; 0
    1ee4:	a0 40       	sbci	r26, 0x00	; 0
    1ee6:	e1 f7       	brne	.-8      	; 0x1ee0 <green_read+0x1a>
    1ee8:	00 00       	nop
	_delay_ms(130); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    1eea:	80 91 56 06 	lds	r24, 0x0656
    1eee:	90 91 57 06 	lds	r25, 0x0657
    1ef2:	a0 91 58 06 	lds	r26, 0x0658
    1ef6:	b0 91 59 06 	lds	r27, 0x0659
    1efa:	80 93 a5 06 	sts	0x06A5, r24
    1efe:	90 93 a6 06 	sts	0x06A6, r25
    1f02:	a0 93 a7 06 	sts	0x06A7, r26
    1f06:	b0 93 a8 06 	sts	0x06A8, r27
}
    1f0a:	08 95       	ret

00001f0c <check_for_survivor>:
 *	 	
 * Example Call: performIDR(44);
 *					
 */
void check_for_survivor()
{
    1f0c:	cf 93       	push	r28
    1f0e:	df 93       	push	r29
	velocity(150,150);
    1f10:	86 e9       	ldi	r24, 0x96	; 150
    1f12:	66 e9       	ldi	r22, 0x96	; 150
    1f14:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
	int greenCounter = 0;//green counter is set to 0
	turn_on_color_sensor();//color sensor turned on 
    1f18:	0e 94 a1 03 	call	0x742	; 0x742 <turn_on_color_sensor>
    1f1c:	8f ef       	ldi	r24, 0xFF	; 255
    1f1e:	9f e7       	ldi	r25, 0x7F	; 127
    1f20:	a4 e0       	ldi	r26, 0x04	; 4
    1f22:	81 50       	subi	r24, 0x01	; 1
    1f24:	90 40       	sbci	r25, 0x00	; 0
    1f26:	a0 40       	sbci	r26, 0x00	; 0
    1f28:	e1 f7       	brne	.-8      	; 0x1f22 <check_for_survivor+0x16>
    1f2a:	00 c0       	rjmp	.+0      	; 0x1f2c <check_for_survivor+0x20>
    1f2c:	00 00       	nop
	_delay_ms(100);
	
	red_read();
    1f2e:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <red_read>
	green_read();
    1f32:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <green_read>
	if(green > red)//if green read is greater than red in first swipe then green counter is incremented 
    1f36:	40 91 a5 06 	lds	r20, 0x06A5
    1f3a:	50 91 a6 06 	lds	r21, 0x06A6
    1f3e:	60 91 a7 06 	lds	r22, 0x06A7
    1f42:	70 91 a8 06 	lds	r23, 0x06A8
    1f46:	80 91 a9 06 	lds	r24, 0x06A9
    1f4a:	90 91 aa 06 	lds	r25, 0x06AA
    1f4e:	a0 91 ab 06 	lds	r26, 0x06AB
    1f52:	b0 91 ac 06 	lds	r27, 0x06AC
 *					
 */
void check_for_survivor()
{
	velocity(150,150);
	int greenCounter = 0;//green counter is set to 0
    1f56:	c1 e0       	ldi	r28, 0x01	; 1
    1f58:	d0 e0       	ldi	r29, 0x00	; 0
    1f5a:	84 17       	cp	r24, r20
    1f5c:	95 07       	cpc	r25, r21
    1f5e:	a6 07       	cpc	r26, r22
    1f60:	b7 07       	cpc	r27, r23
    1f62:	10 f0       	brcs	.+4      	; 0x1f68 <check_for_survivor+0x5c>
    1f64:	c0 e0       	ldi	r28, 0x00	; 0
    1f66:	d0 e0       	ldi	r29, 0x00	; 0
	red_read();
	green_read();
	if(green > red)//if green read is greater than red in first swipe then green counter is incremented 
		greenCounter++;
	
	left_degrees(7); //move slightly to left
    1f68:	87 e0       	ldi	r24, 0x07	; 7
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	0e 94 d3 05 	call	0xba6	; 0xba6 <left_degrees>
	
	red_read();
    1f70:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <red_read>
	green_read();
    1f74:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <green_read>
	if(green > red) //if green read is greater than red in first swipe then green counter is incremented 
    1f78:	40 91 a5 06 	lds	r20, 0x06A5
    1f7c:	50 91 a6 06 	lds	r21, 0x06A6
    1f80:	60 91 a7 06 	lds	r22, 0x06A7
    1f84:	70 91 a8 06 	lds	r23, 0x06A8
    1f88:	80 91 a9 06 	lds	r24, 0x06A9
    1f8c:	90 91 aa 06 	lds	r25, 0x06AA
    1f90:	a0 91 ab 06 	lds	r26, 0x06AB
    1f94:	b0 91 ac 06 	lds	r27, 0x06AC
    1f98:	84 17       	cp	r24, r20
    1f9a:	95 07       	cpc	r25, r21
    1f9c:	a6 07       	cpc	r26, r22
    1f9e:	b7 07       	cpc	r27, r23
    1fa0:	08 f4       	brcc	.+2      	; 0x1fa4 <check_for_survivor+0x98>
		greenCounter++;
    1fa2:	21 96       	adiw	r28, 0x01	; 1
	
	right_degrees(10); //move slightly to right
    1fa4:	8a e0       	ldi	r24, 0x0A	; 10
    1fa6:	90 e0       	ldi	r25, 0x00	; 0
    1fa8:	0e 94 de 05 	call	0xbbc	; 0xbbc <right_degrees>
	
	red_read();
    1fac:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <red_read>
	green_read();
    1fb0:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <green_read>
	if(green > red) //if green read is greater than red in first swipe then green counter is incremented 
    1fb4:	40 91 a5 06 	lds	r20, 0x06A5
    1fb8:	50 91 a6 06 	lds	r21, 0x06A6
    1fbc:	60 91 a7 06 	lds	r22, 0x06A7
    1fc0:	70 91 a8 06 	lds	r23, 0x06A8
    1fc4:	80 91 a9 06 	lds	r24, 0x06A9
    1fc8:	90 91 aa 06 	lds	r25, 0x06AA
    1fcc:	a0 91 ab 06 	lds	r26, 0x06AB
    1fd0:	b0 91 ac 06 	lds	r27, 0x06AC
    1fd4:	84 17       	cp	r24, r20
    1fd6:	95 07       	cpc	r25, r21
    1fd8:	a6 07       	cpc	r26, r22
    1fda:	b7 07       	cpc	r27, r23
    1fdc:	08 f4       	brcc	.+2      	; 0x1fe0 <check_for_survivor+0xd4>
		greenCounter++;
    1fde:	21 96       	adiw	r28, 0x01	; 1
		
	left_degrees(15);// move back to original orientation
    1fe0:	8f e0       	ldi	r24, 0x0F	; 15
    1fe2:	90 e0       	ldi	r25, 0x00	; 0
    1fe4:	0e 94 d3 05 	call	0xba6	; 0xba6 <left_degrees>
		
	if(greenCounter > 0) //if the greenCounter is greater than zero then the green read must have been greater than red read at some point while the scan
    1fe8:	1c 16       	cp	r1, r28
    1fea:	1d 06       	cpc	r1, r29
    1fec:	3c f4       	brge	.+14     	; 0x1ffc <check_for_survivor+0xf0>
		survivor = G; //color is set to green
    1fee:	89 e0       	ldi	r24, 0x09	; 9
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	90 93 b3 06 	sts	0x06B3, r25
    1ff6:	80 93 b2 06 	sts	0x06B2, r24
    1ffa:	06 c0       	rjmp	.+12     	; 0x2008 <check_for_survivor+0xfc>
	else
		survivor = R; //color is set to red
    1ffc:	88 e0       	ldi	r24, 0x08	; 8
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	90 93 b3 06 	sts	0x06B3, r25
    2004:	80 93 b2 06 	sts	0x06B2, r24
	
	turn_off_color_sensor();
    2008:	0e 94 a7 03 	call	0x74e	; 0x74e <turn_off_color_sensor>

	stop();
    200c:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
}
    2010:	df 91       	pop	r29
    2012:	cf 91       	pop	r28
    2014:	08 95       	ret

00002016 <performRescueOperation>:
 *	 	
 * Example Call: performIDR(44);
 *					
 */
void performRescueOperation(char dir)
{
    2016:	cf 93       	push	r28
    2018:	c8 2f       	mov	r28, r24
	gripper_rotate(20);//open gripper servo
    201a:	84 e1       	ldi	r24, 0x14	; 20
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    2022:	8f ef       	ldi	r24, 0xFF	; 255
    2024:	9f ef       	ldi	r25, 0xFF	; 255
    2026:	a8 e0       	ldi	r26, 0x08	; 8
    2028:	81 50       	subi	r24, 0x01	; 1
    202a:	90 40       	sbci	r25, 0x00	; 0
    202c:	a0 40       	sbci	r26, 0x00	; 0
    202e:	e1 f7       	brne	.-8      	; 0x2028 <performRescueOperation+0x12>
    2030:	00 c0       	rjmp	.+0      	; 0x2032 <performRescueOperation+0x1c>
    2032:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(120); //move down elbow servo
    2034:	88 e7       	ldi	r24, 0x78	; 120
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    203c:	8f ef       	ldi	r24, 0xFF	; 255
    203e:	9f ef       	ldi	r25, 0xFF	; 255
    2040:	a8 e0       	ldi	r26, 0x08	; 8
    2042:	81 50       	subi	r24, 0x01	; 1
    2044:	90 40       	sbci	r25, 0x00	; 0
    2046:	a0 40       	sbci	r26, 0x00	; 0
    2048:	e1 f7       	brne	.-8      	; 0x2042 <performRescueOperation+0x2c>
    204a:	00 c0       	rjmp	.+0      	; 0x204c <performRescueOperation+0x36>
    204c:	00 00       	nop
	_delay_ms(200);
	gripper_rotate(85); //close gripper servo
    204e:	85 e5       	ldi	r24, 0x55	; 85
    2050:	90 e0       	ldi	r25, 0x00	; 0
    2052:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    2056:	8f ef       	ldi	r24, 0xFF	; 255
    2058:	9f ef       	ldi	r25, 0xFF	; 255
    205a:	a8 e0       	ldi	r26, 0x08	; 8
    205c:	81 50       	subi	r24, 0x01	; 1
    205e:	90 40       	sbci	r25, 0x00	; 0
    2060:	a0 40       	sbci	r26, 0x00	; 0
    2062:	e1 f7       	brne	.-8      	; 0x205c <performRescueOperation+0x46>
    2064:	00 c0       	rjmp	.+0      	; 0x2066 <performRescueOperation+0x50>
    2066:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(100); //left elbow servo slightly
    2068:	84 e6       	ldi	r24, 0x64	; 100
    206a:	90 e0       	ldi	r25, 0x00	; 0
    206c:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    2070:	8f ef       	ldi	r24, 0xFF	; 255
    2072:	9f ef       	ldi	r25, 0xFF	; 255
    2074:	a8 e0       	ldi	r26, 0x08	; 8
    2076:	81 50       	subi	r24, 0x01	; 1
    2078:	90 40       	sbci	r25, 0x00	; 0
    207a:	a0 40       	sbci	r26, 0x00	; 0
    207c:	e1 f7       	brne	.-8      	; 0x2076 <performRescueOperation+0x60>
    207e:	00 c0       	rjmp	.+0      	; 0x2080 <performRescueOperation+0x6a>
    2080:	00 00       	nop
	_delay_ms(200);
	if(dir == 'L')//if dir specified is Left the the base servo moves toward 20 degrees or else 160 degrees
    2082:	cc 34       	cpi	r28, 0x4C	; 76
    2084:	c9 f5       	brne	.+114    	; 0x20f8 <performRescueOperation+0xe2>
		base_rotate(20);
    2086:	84 e1       	ldi	r24, 0x14	; 20
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
    208e:	8f ef       	ldi	r24, 0xFF	; 255
    2090:	9f ef       	ldi	r25, 0xFF	; 255
    2092:	a8 e0       	ldi	r26, 0x08	; 8
    2094:	81 50       	subi	r24, 0x01	; 1
    2096:	90 40       	sbci	r25, 0x00	; 0
    2098:	a0 40       	sbci	r26, 0x00	; 0
    209a:	e1 f7       	brne	.-8      	; 0x2094 <performRescueOperation+0x7e>
    209c:	00 c0       	rjmp	.+0      	; 0x209e <performRescueOperation+0x88>
    209e:	00 00       	nop
	else
		base_rotate(160);
	_delay_ms(200);
	elbow_rotate(115);//the elbow servo moves slightly below
    20a0:	83 e7       	ldi	r24, 0x73	; 115
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    20a8:	8f ef       	ldi	r24, 0xFF	; 255
    20aa:	9f ef       	ldi	r25, 0xFF	; 255
    20ac:	a8 e0       	ldi	r26, 0x08	; 8
    20ae:	81 50       	subi	r24, 0x01	; 1
    20b0:	90 40       	sbci	r25, 0x00	; 0
    20b2:	a0 40       	sbci	r26, 0x00	; 0
    20b4:	e1 f7       	brne	.-8      	; 0x20ae <performRescueOperation+0x98>
    20b6:	00 c0       	rjmp	.+0      	; 0x20b8 <performRescueOperation+0xa2>
    20b8:	00 00       	nop
	_delay_ms(200);
	gripper_rotate(20);//the white debris is dropped
    20ba:	84 e1       	ldi	r24, 0x14	; 20
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    20c2:	8f ef       	ldi	r24, 0xFF	; 255
    20c4:	9f ef       	ldi	r25, 0xFF	; 255
    20c6:	a8 e0       	ldi	r26, 0x08	; 8
    20c8:	81 50       	subi	r24, 0x01	; 1
    20ca:	90 40       	sbci	r25, 0x00	; 0
    20cc:	a0 40       	sbci	r26, 0x00	; 0
    20ce:	e1 f7       	brne	.-8      	; 0x20c8 <performRescueOperation+0xb2>
    20d0:	00 c0       	rjmp	.+0      	; 0x20d2 <performRescueOperation+0xbc>
    20d2:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(80);//lift elbow servo 
    20d4:	80 e5       	ldi	r24, 0x50	; 80
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    20dc:	8f ef       	ldi	r24, 0xFF	; 255
    20de:	9f ef       	ldi	r25, 0xFF	; 255
    20e0:	a8 e0       	ldi	r26, 0x08	; 8
    20e2:	81 50       	subi	r24, 0x01	; 1
    20e4:	90 40       	sbci	r25, 0x00	; 0
    20e6:	a0 40       	sbci	r26, 0x00	; 0
    20e8:	e1 f7       	brne	.-8      	; 0x20e2 <performRescueOperation+0xcc>
    20ea:	00 c0       	rjmp	.+0      	; 0x20ec <performRescueOperation+0xd6>
    20ec:	00 00       	nop
	_delay_ms(200);
	if(dir == 'L')//if dir specified was left then move base servo to 0 or else 180 so as to bring color sensor over survivor
		base_rotate(0);
    20ee:	80 e0       	ldi	r24, 0x00	; 0
    20f0:	90 e0       	ldi	r25, 0x00	; 0
    20f2:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
    20f6:	38 c0       	rjmp	.+112    	; 0x2168 <performRescueOperation+0x152>
	elbow_rotate(100); //left elbow servo slightly
	_delay_ms(200);
	if(dir == 'L')//if dir specified is Left the the base servo moves toward 20 degrees or else 160 degrees
		base_rotate(20);
	else
		base_rotate(160);
    20f8:	80 ea       	ldi	r24, 0xA0	; 160
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
    2100:	8f ef       	ldi	r24, 0xFF	; 255
    2102:	9f ef       	ldi	r25, 0xFF	; 255
    2104:	a8 e0       	ldi	r26, 0x08	; 8
    2106:	81 50       	subi	r24, 0x01	; 1
    2108:	90 40       	sbci	r25, 0x00	; 0
    210a:	a0 40       	sbci	r26, 0x00	; 0
    210c:	e1 f7       	brne	.-8      	; 0x2106 <performRescueOperation+0xf0>
    210e:	00 c0       	rjmp	.+0      	; 0x2110 <performRescueOperation+0xfa>
    2110:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(115);//the elbow servo moves slightly below
    2112:	83 e7       	ldi	r24, 0x73	; 115
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    211a:	8f ef       	ldi	r24, 0xFF	; 255
    211c:	9f ef       	ldi	r25, 0xFF	; 255
    211e:	a8 e0       	ldi	r26, 0x08	; 8
    2120:	81 50       	subi	r24, 0x01	; 1
    2122:	90 40       	sbci	r25, 0x00	; 0
    2124:	a0 40       	sbci	r26, 0x00	; 0
    2126:	e1 f7       	brne	.-8      	; 0x2120 <performRescueOperation+0x10a>
    2128:	00 c0       	rjmp	.+0      	; 0x212a <performRescueOperation+0x114>
    212a:	00 00       	nop
	_delay_ms(200);
	gripper_rotate(20);//the white debris is dropped
    212c:	84 e1       	ldi	r24, 0x14	; 20
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    2134:	8f ef       	ldi	r24, 0xFF	; 255
    2136:	9f ef       	ldi	r25, 0xFF	; 255
    2138:	a8 e0       	ldi	r26, 0x08	; 8
    213a:	81 50       	subi	r24, 0x01	; 1
    213c:	90 40       	sbci	r25, 0x00	; 0
    213e:	a0 40       	sbci	r26, 0x00	; 0
    2140:	e1 f7       	brne	.-8      	; 0x213a <performRescueOperation+0x124>
    2142:	00 c0       	rjmp	.+0      	; 0x2144 <performRescueOperation+0x12e>
    2144:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(80);//lift elbow servo 
    2146:	80 e5       	ldi	r24, 0x50	; 80
    2148:	90 e0       	ldi	r25, 0x00	; 0
    214a:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    214e:	8f ef       	ldi	r24, 0xFF	; 255
    2150:	9f ef       	ldi	r25, 0xFF	; 255
    2152:	a8 e0       	ldi	r26, 0x08	; 8
    2154:	81 50       	subi	r24, 0x01	; 1
    2156:	90 40       	sbci	r25, 0x00	; 0
    2158:	a0 40       	sbci	r26, 0x00	; 0
    215a:	e1 f7       	brne	.-8      	; 0x2154 <performRescueOperation+0x13e>
    215c:	00 c0       	rjmp	.+0      	; 0x215e <performRescueOperation+0x148>
    215e:	00 00       	nop
	_delay_ms(200);
	if(dir == 'L')//if dir specified was left then move base servo to 0 or else 180 so as to bring color sensor over survivor
		base_rotate(0);
	else
		base_rotate(180);
    2160:	84 eb       	ldi	r24, 0xB4	; 180
    2162:	90 e0       	ldi	r25, 0x00	; 0
    2164:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
    2168:	8f ef       	ldi	r24, 0xFF	; 255
    216a:	9f ef       	ldi	r25, 0xFF	; 255
    216c:	a8 e0       	ldi	r26, 0x08	; 8
    216e:	81 50       	subi	r24, 0x01	; 1
    2170:	90 40       	sbci	r25, 0x00	; 0
    2172:	a0 40       	sbci	r26, 0x00	; 0
    2174:	e1 f7       	brne	.-8      	; 0x216e <performRescueOperation+0x158>
    2176:	00 c0       	rjmp	.+0      	; 0x2178 <performRescueOperation+0x162>
    2178:	00 00       	nop
	_delay_ms(200);
	gripper_rotate(90); //close gripper servo
    217a:	8a e5       	ldi	r24, 0x5A	; 90
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    2182:	8f ef       	ldi	r24, 0xFF	; 255
    2184:	9f ef       	ldi	r25, 0xFF	; 255
    2186:	a8 e0       	ldi	r26, 0x08	; 8
    2188:	81 50       	subi	r24, 0x01	; 1
    218a:	90 40       	sbci	r25, 0x00	; 0
    218c:	a0 40       	sbci	r26, 0x00	; 0
    218e:	e1 f7       	brne	.-8      	; 0x2188 <performRescueOperation+0x172>
    2190:	00 c0       	rjmp	.+0      	; 0x2192 <performRescueOperation+0x17c>
    2192:	00 00       	nop
	_delay_ms(200);
	elbow_rotate(134); //bring down the elbow servo
    2194:	86 e8       	ldi	r24, 0x86	; 134
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    219c:	8f ef       	ldi	r24, 0xFF	; 255
    219e:	9f ef       	ldi	r25, 0xFF	; 255
    21a0:	a8 e0       	ldi	r26, 0x08	; 8
    21a2:	81 50       	subi	r24, 0x01	; 1
    21a4:	90 40       	sbci	r25, 0x00	; 0
    21a6:	a0 40       	sbci	r26, 0x00	; 0
    21a8:	e1 f7       	brne	.-8      	; 0x21a2 <performRescueOperation+0x18c>
    21aa:	00 c0       	rjmp	.+0      	; 0x21ac <performRescueOperation+0x196>
    21ac:	00 00       	nop
	_delay_ms(200);
	
	check_for_survivor(); //sense the color of the survivor
    21ae:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <check_for_survivor>
	
	if(survivor == R) //glow red LED if red survivor
    21b2:	80 91 b2 06 	lds	r24, 0x06B2
    21b6:	90 91 b3 06 	lds	r25, 0x06B3
    21ba:	88 30       	cpi	r24, 0x08	; 8
    21bc:	91 05       	cpc	r25, r1
    21be:	19 f4       	brne	.+6      	; 0x21c6 <performRescueOperation+0x1b0>
		red_led();
    21c0:	0e 94 44 02 	call	0x488	; 0x488 <red_led>
    21c4:	05 c0       	rjmp	.+10     	; 0x21d0 <performRescueOperation+0x1ba>
	else if(survivor == G) //glow green LED if green survivor
    21c6:	89 30       	cpi	r24, 0x09	; 9
    21c8:	91 05       	cpc	r25, r1
    21ca:	11 f4       	brne	.+4      	; 0x21d0 <performRescueOperation+0x1ba>
		green_led();
    21cc:	0e 94 4c 02 	call	0x498	; 0x498 <green_led>
    21d0:	8f ef       	ldi	r24, 0xFF	; 255
    21d2:	9f ef       	ldi	r25, 0xFF	; 255
    21d4:	a9 e5       	ldi	r26, 0x59	; 89
    21d6:	81 50       	subi	r24, 0x01	; 1
    21d8:	90 40       	sbci	r25, 0x00	; 0
    21da:	a0 40       	sbci	r26, 0x00	; 0
    21dc:	e1 f7       	brne	.-8      	; 0x21d6 <performRescueOperation+0x1c0>
    21de:	00 c0       	rjmp	.+0      	; 0x21e0 <performRescueOperation+0x1ca>
    21e0:	00 00       	nop
	_delay_ms(2000);
	turn_off_led();
    21e2:	0e 94 50 02 	call	0x4a0	; 0x4a0 <turn_off_led>
	
	elbow_rotate(0);//lift elbow servo
    21e6:	80 e0       	ldi	r24, 0x00	; 0
    21e8:	90 e0       	ldi	r25, 0x00	; 0
    21ea:	0e 94 18 03 	call	0x630	; 0x630 <elbow_rotate>
    21ee:	8f ef       	ldi	r24, 0xFF	; 255
    21f0:	9f ef       	ldi	r25, 0xFF	; 255
    21f2:	a8 e0       	ldi	r26, 0x08	; 8
    21f4:	81 50       	subi	r24, 0x01	; 1
    21f6:	90 40       	sbci	r25, 0x00	; 0
    21f8:	a0 40       	sbci	r26, 0x00	; 0
    21fa:	e1 f7       	brne	.-8      	; 0x21f4 <performRescueOperation+0x1de>
    21fc:	00 c0       	rjmp	.+0      	; 0x21fe <performRescueOperation+0x1e8>
    21fe:	00 00       	nop
	_delay_ms(200);
	gripper_rotate(20);//open gripper servo
    2200:	84 e1       	ldi	r24, 0x14	; 20
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	0e 94 df 02 	call	0x5be	; 0x5be <gripper_rotate>
    2208:	8f ef       	ldi	r24, 0xFF	; 255
    220a:	9f ef       	ldi	r25, 0xFF	; 255
    220c:	a8 e0       	ldi	r26, 0x08	; 8
    220e:	81 50       	subi	r24, 0x01	; 1
    2210:	90 40       	sbci	r25, 0x00	; 0
    2212:	a0 40       	sbci	r26, 0x00	; 0
    2214:	e1 f7       	brne	.-8      	; 0x220e <__stack+0xf>
    2216:	00 c0       	rjmp	.+0      	; 0x2218 <__stack+0x19>
    2218:	00 00       	nop
	_delay_ms(200);
}
    221a:	cf 91       	pop	r28
    221c:	08 95       	ret

0000221e <performIDR>:
 *	 	
 * Example Call: performIDR(44);
 *					
 */
void performIDR(int scan_pos)
{	
    221e:	ef 92       	push	r14
    2220:	ff 92       	push	r15
    2222:	1f 93       	push	r17
    2224:	cf 93       	push	r28
    2226:	df 93       	push	r29
    2228:	7c 01       	movw	r14, r24
	
	//the difference between a co-ordinate and the one to its north is 10
	//the difference between a co-ordinate and the one to its south is -10
	//the difference between a co-ordinate and the one to its east is 1
	//the difference between a co-ordinate and the one to its west is -1
	int diff=current_pos-scan_pos;
    222a:	c0 91 9b 06 	lds	r28, 0x069B
    222e:	d0 91 9c 06 	lds	r29, 0x069C
    2232:	c8 1b       	sub	r28, r24
    2234:	d9 0b       	sbc	r29, r25
	
	//Please note that the default orientation of kit-dropping mechanism is the the same as that of the bot which is towards the front. Hence the base servo shall by default be at 90 degrees
	if (diff==1&&orientation==point_north||orientation==point_south&&diff==-1||diff==10&&orientation==point_west||orientation==point_east&&diff==-10)//The search robot's servo mechanism must turn left if either of the conditions  is true
    2236:	c1 30       	cpi	r28, 0x01	; 1
    2238:	d1 05       	cpc	r29, r1
    223a:	59 f4       	brne	.+22     	; 0x2252 <performIDR+0x34>
    223c:	20 91 95 06 	lds	r18, 0x0695
    2240:	30 91 96 06 	lds	r19, 0x0696
    2244:	80 91 9d 06 	lds	r24, 0x069D
    2248:	90 91 9e 06 	lds	r25, 0x069E
    224c:	28 17       	cp	r18, r24
    224e:	39 07       	cpc	r19, r25
    2250:	21 f1       	breq	.+72     	; 0x229a <performIDR+0x7c>
    2252:	80 91 95 06 	lds	r24, 0x0695
    2256:	90 91 96 06 	lds	r25, 0x0696
    225a:	20 91 12 02 	lds	r18, 0x0212
    225e:	30 91 13 02 	lds	r19, 0x0213
    2262:	82 17       	cp	r24, r18
    2264:	93 07       	cpc	r25, r19
    2266:	21 f4       	brne	.+8      	; 0x2270 <performIDR+0x52>
    2268:	2f ef       	ldi	r18, 0xFF	; 255
    226a:	cf 3f       	cpi	r28, 0xFF	; 255
    226c:	d2 07       	cpc	r29, r18
    226e:	a9 f0       	breq	.+42     	; 0x229a <performIDR+0x7c>
    2270:	ca 30       	cpi	r28, 0x0A	; 10
    2272:	d1 05       	cpc	r29, r1
    2274:	39 f4       	brne	.+14     	; 0x2284 <performIDR+0x66>
    2276:	20 91 10 02 	lds	r18, 0x0210
    227a:	30 91 11 02 	lds	r19, 0x0211
    227e:	82 17       	cp	r24, r18
    2280:	93 07       	cpc	r25, r19
    2282:	59 f0       	breq	.+22     	; 0x229a <performIDR+0x7c>
    2284:	20 91 14 02 	lds	r18, 0x0214
    2288:	30 91 15 02 	lds	r19, 0x0215
    228c:	82 17       	cp	r24, r18
    228e:	93 07       	cpc	r25, r19
    2290:	41 f4       	brne	.+16     	; 0x22a2 <performIDR+0x84>
    2292:	8f ef       	ldi	r24, 0xFF	; 255
    2294:	c6 3f       	cpi	r28, 0xF6	; 246
    2296:	d8 07       	cpc	r29, r24
    2298:	21 f4       	brne	.+8      	; 0x22a2 <performIDR+0x84>
	{
		base_rotate(0);
    229a:	80 e0       	ldi	r24, 0x00	; 0
    229c:	90 e0       	ldi	r25, 0x00	; 0
    229e:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
		dir = 'L'; // dir of the servo mechanism is set as left
	}
	if (diff==-1&&orientation==point_north||orientation==point_south&&diff==1||diff==-10&&orientation==point_west||orientation==point_east&&diff==10)//The rescue robot's servo mechanism must turn right if either of the conditions  is true
    22a2:	9f ef       	ldi	r25, 0xFF	; 255
    22a4:	cf 3f       	cpi	r28, 0xFF	; 255
    22a6:	d9 07       	cpc	r29, r25
    22a8:	59 f4       	brne	.+22     	; 0x22c0 <performIDR+0xa2>
    22aa:	20 91 95 06 	lds	r18, 0x0695
    22ae:	30 91 96 06 	lds	r19, 0x0696
    22b2:	80 91 9d 06 	lds	r24, 0x069D
    22b6:	90 91 9e 06 	lds	r25, 0x069E
    22ba:	28 17       	cp	r18, r24
    22bc:	39 07       	cpc	r19, r25
    22be:	19 f1       	breq	.+70     	; 0x2306 <performIDR+0xe8>
    22c0:	80 91 95 06 	lds	r24, 0x0695
    22c4:	90 91 96 06 	lds	r25, 0x0696
    22c8:	20 91 12 02 	lds	r18, 0x0212
    22cc:	30 91 13 02 	lds	r19, 0x0213
    22d0:	82 17       	cp	r24, r18
    22d2:	93 07       	cpc	r25, r19
    22d4:	19 f4       	brne	.+6      	; 0x22dc <performIDR+0xbe>
    22d6:	c1 30       	cpi	r28, 0x01	; 1
    22d8:	d1 05       	cpc	r29, r1
    22da:	a9 f0       	breq	.+42     	; 0x2306 <performIDR+0xe8>
    22dc:	af ef       	ldi	r26, 0xFF	; 255
    22de:	c6 3f       	cpi	r28, 0xF6	; 246
    22e0:	da 07       	cpc	r29, r26
    22e2:	39 f4       	brne	.+14     	; 0x22f2 <performIDR+0xd4>
    22e4:	20 91 10 02 	lds	r18, 0x0210
    22e8:	30 91 11 02 	lds	r19, 0x0211
    22ec:	82 17       	cp	r24, r18
    22ee:	93 07       	cpc	r25, r19
    22f0:	51 f0       	breq	.+20     	; 0x2306 <performIDR+0xe8>
    22f2:	20 91 14 02 	lds	r18, 0x0214
    22f6:	30 91 15 02 	lds	r19, 0x0215
    22fa:	82 17       	cp	r24, r18
    22fc:	93 07       	cpc	r25, r19
    22fe:	49 f4       	brne	.+18     	; 0x2312 <performIDR+0xf4>
    2300:	ca 30       	cpi	r28, 0x0A	; 10
    2302:	d1 05       	cpc	r29, r1
    2304:	41 f4       	brne	.+16     	; 0x2316 <performIDR+0xf8>
	{
		base_rotate(180);
    2306:	84 eb       	ldi	r24, 0xB4	; 180
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
		dir = 'R';  // dir of the servo mechanism is set as right
    230e:	12 e5       	ldi	r17, 0x52	; 82
    2310:	03 c0       	rjmp	.+6      	; 0x2318 <performIDR+0xfa>
	if (diff==1&&orientation==point_north||orientation==point_south&&diff==-1||diff==10&&orientation==point_west||orientation==point_east&&diff==-10)//The search robot's servo mechanism must turn left if either of the conditions  is true
	{
		base_rotate(0);
		dir = 'L'; // dir of the servo mechanism is set as left
	}
	if (diff==-1&&orientation==point_north||orientation==point_south&&diff==1||diff==-10&&orientation==point_west||orientation==point_east&&diff==10)//The rescue robot's servo mechanism must turn right if either of the conditions  is true
    2312:	1c e4       	ldi	r17, 0x4C	; 76
    2314:	01 c0       	rjmp	.+2      	; 0x2318 <performIDR+0xfa>
    2316:	1c e4       	ldi	r17, 0x4C	; 76
    2318:	8f ef       	ldi	r24, 0xFF	; 255
    231a:	9f ef       	ldi	r25, 0xFF	; 255
    231c:	a8 e0       	ldi	r26, 0x08	; 8
    231e:	81 50       	subi	r24, 0x01	; 1
    2320:	90 40       	sbci	r25, 0x00	; 0
    2322:	a0 40       	sbci	r26, 0x00	; 0
    2324:	e1 f7       	brne	.-8      	; 0x231e <performIDR+0x100>
    2326:	00 c0       	rjmp	.+0      	; 0x2328 <performIDR+0x10a>
    2328:	00 00       	nop
		dir = 'R';  // dir of the servo mechanism is set as right
	}
	
	_delay_ms(200);
	
	int sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    232a:	8b e0       	ldi	r24, 0x0B	; 11
    232c:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
	int value = Sharp_GP2D12_estimation(sharp);
    2330:	0e 94 15 05 	call	0xa2a	; 0xa2a <Sharp_GP2D12_estimation>
    2334:	ec 01       	movw	r28, r24
	lcd_print(2,1,value,3);
    2336:	82 e0       	ldi	r24, 0x02	; 2
    2338:	61 e0       	ldi	r22, 0x01	; 1
    233a:	ae 01       	movw	r20, r28
    233c:	23 e0       	ldi	r18, 0x03	; 3
    233e:	30 e0       	ldi	r19, 0x00	; 0
    2340:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
	if(value < 200 && value > 20) //checks if white debris is present or not
    2344:	65 97       	sbiw	r28, 0x15	; 21
    2346:	c3 3b       	cpi	r28, 0xB3	; 179
    2348:	d1 05       	cpc	r29, r1
    234a:	f0 f4       	brcc	.+60     	; 0x2388 <performIDR+0x16a>
	{
		performRescueOperation(dir);  //function makes the search robot to move the white debris and then scan the color of the survivor
    234c:	81 2f       	mov	r24, r17
    234e:	0e 94 0b 10 	call	0x2016	; 0x2016 <performRescueOperation>
		UDR0 = (char)survivor; //send survivor color to the rescue bot
    2352:	80 91 b2 06 	lds	r24, 0x06B2
    2356:	e6 ec       	ldi	r30, 0xC6	; 198
    2358:	f0 e0       	ldi	r31, 0x00	; 0
    235a:	80 83       	st	Z, r24
    235c:	af ef       	ldi	r26, 0xFF	; 255
    235e:	b7 e4       	ldi	r27, 0x47	; 71
    2360:	11 97       	sbiw	r26, 0x01	; 1
    2362:	f1 f7       	brne	.-4      	; 0x2360 <performIDR+0x142>
    2364:	00 c0       	rjmp	.+0      	; 0x2366 <performIDR+0x148>
    2366:	00 00       	nop
		_delay_ms(5);
		UDR0 = (char)scan_pos;//send survivor co-ordinate to rescue bot
    2368:	e0 82       	st	Z, r14
    236a:	8f ef       	ldi	r24, 0xFF	; 255
    236c:	97 e4       	ldi	r25, 0x47	; 71
    236e:	01 97       	sbiw	r24, 0x01	; 1
    2370:	f1 f7       	brne	.-4      	; 0x236e <performIDR+0x150>
    2372:	00 c0       	rjmp	.+0      	; 0x2374 <performIDR+0x156>
    2374:	00 00       	nop
		_delay_ms(5);
		UDR0 = 4;
    2376:	84 e0       	ldi	r24, 0x04	; 4
    2378:	80 83       	st	Z, r24
    237a:	af ef       	ldi	r26, 0xFF	; 255
    237c:	b7 e4       	ldi	r27, 0x47	; 71
    237e:	11 97       	sbiw	r26, 0x01	; 1
    2380:	f1 f7       	brne	.-4      	; 0x237e <performIDR+0x160>
    2382:	00 c0       	rjmp	.+0      	; 0x2384 <performIDR+0x166>
    2384:	00 00       	nop
    2386:	1d c0       	rjmp	.+58     	; 0x23c2 <performIDR+0x1a4>
		_delay_ms(5);
	}
	else
	{
		//if no white debris is found then ring the buzzer for 2 seconds and glow blue LED 
		int sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    2388:	8b e0       	ldi	r24, 0x0B	; 11
    238a:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
		int value = Sharp_GP2D12_estimation(sharp);
    238e:	0e 94 15 05 	call	0xa2a	; 0xa2a <Sharp_GP2D12_estimation>
    2392:	ac 01       	movw	r20, r24
		lcd_print(2,1,value,3);
    2394:	82 e0       	ldi	r24, 0x02	; 2
    2396:	61 e0       	ldi	r22, 0x01	; 1
    2398:	23 e0       	ldi	r18, 0x03	; 3
    239a:	30 e0       	ldi	r19, 0x00	; 0
    239c:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
		buzzer_on();
    23a0:	0e 94 6d 07 	call	0xeda	; 0xeda <buzzer_on>
		blue_led();
    23a4:	0e 94 48 02 	call	0x490	; 0x490 <blue_led>
    23a8:	8f ef       	ldi	r24, 0xFF	; 255
    23aa:	9f ef       	ldi	r25, 0xFF	; 255
    23ac:	a9 e5       	ldi	r26, 0x59	; 89
    23ae:	81 50       	subi	r24, 0x01	; 1
    23b0:	90 40       	sbci	r25, 0x00	; 0
    23b2:	a0 40       	sbci	r26, 0x00	; 0
    23b4:	e1 f7       	brne	.-8      	; 0x23ae <performIDR+0x190>
    23b6:	00 c0       	rjmp	.+0      	; 0x23b8 <performIDR+0x19a>
    23b8:	00 00       	nop
		_delay_ms(2000);
		buzzer_off();
    23ba:	0e 94 71 07 	call	0xee2	; 0xee2 <buzzer_off>
		turn_off_led();
    23be:	0e 94 50 02 	call	0x4a0	; 0x4a0 <turn_off_led>
	}
	base_rotate(90);  //reset the servo mechanism to its default orientation
    23c2:	8a e5       	ldi	r24, 0x5A	; 90
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	0e 94 51 03 	call	0x6a2	; 0x6a2 <base_rotate>
	stop();
    23ca:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
	plotScanCounter++;//increment the number of plots scanned i.e plotScanCounter
    23ce:	80 91 97 06 	lds	r24, 0x0697
    23d2:	90 91 98 06 	lds	r25, 0x0698
    23d6:	01 96       	adiw	r24, 0x01	; 1
    23d8:	90 93 98 06 	sts	0x0698, r25
    23dc:	80 93 97 06 	sts	0x0697, r24
}
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	1f 91       	pop	r17
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	08 95       	ret

000023ec <north>:
 * Example Call: north(pointing_east);
 *
 */
void north(unsigned int current_orientation) 
{
	if (current_orientation == point_east) 
    23ec:	20 91 14 02 	lds	r18, 0x0214
    23f0:	30 91 15 02 	lds	r19, 0x0215
    23f4:	28 17       	cp	r18, r24
    23f6:	39 07       	cpc	r19, r25
    23f8:	49 f4       	brne	.+18     	; 0x240c <north+0x20>
	{
        velocity(255,255);
    23fa:	8f ef       	ldi	r24, 0xFF	; 255
    23fc:	6f ef       	ldi	r22, 0xFF	; 255
    23fe:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_left(70);
    2402:	86 e4       	ldi	r24, 0x46	; 70
    2404:	90 e0       	ldi	r25, 0x00	; 0
    2406:	0e 94 75 07 	call	0xeea	; 0xeea <turn_left>
    240a:	1f c0       	rjmp	.+62     	; 0x244a <north+0x5e>
    } 
	else if (current_orientation == point_west) 
    240c:	20 91 10 02 	lds	r18, 0x0210
    2410:	30 91 11 02 	lds	r19, 0x0211
    2414:	28 17       	cp	r18, r24
    2416:	39 07       	cpc	r19, r25
    2418:	49 f4       	brne	.+18     	; 0x242c <north+0x40>
	{ 
        velocity(255,255);
    241a:	8f ef       	ldi	r24, 0xFF	; 255
    241c:	6f ef       	ldi	r22, 0xFF	; 255
    241e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(70);
    2422:	86 e4       	ldi	r24, 0x46	; 70
    2424:	90 e0       	ldi	r25, 0x00	; 0
    2426:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
    242a:	0f c0       	rjmp	.+30     	; 0x244a <north+0x5e>
    }
	else if (current_orientation == point_south)
    242c:	20 91 12 02 	lds	r18, 0x0212
    2430:	30 91 13 02 	lds	r19, 0x0213
    2434:	28 17       	cp	r18, r24
    2436:	39 07       	cpc	r19, r25
    2438:	41 f4       	brne	.+16     	; 0x244a <north+0x5e>
	{
		velocity(255,255);
    243a:	8f ef       	ldi	r24, 0xFF	; 255
    243c:	6f ef       	ldi	r22, 0xFF	; 255
    243e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(160);
    2442:	80 ea       	ldi	r24, 0xA0	; 160
    2444:	90 e0       	ldi	r25, 0x00	; 0
    2446:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
	}
	orientation = point_north;
    244a:	80 91 9d 06 	lds	r24, 0x069D
    244e:	90 91 9e 06 	lds	r25, 0x069E
    2452:	90 93 96 06 	sts	0x0696, r25
    2456:	80 93 95 06 	sts	0x0695, r24
}
    245a:	08 95       	ret

0000245c <south>:
 * Example Call: south(pointing_east);
 *
 */
void south(unsigned int current_orientation) 
{
    if (current_orientation == point_east) 
    245c:	20 91 14 02 	lds	r18, 0x0214
    2460:	30 91 15 02 	lds	r19, 0x0215
    2464:	28 17       	cp	r18, r24
    2466:	39 07       	cpc	r19, r25
    2468:	49 f4       	brne	.+18     	; 0x247c <south+0x20>
	{
        velocity(255,255);
    246a:	8f ef       	ldi	r24, 0xFF	; 255
    246c:	6f ef       	ldi	r22, 0xFF	; 255
    246e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(70);
    2472:	86 e4       	ldi	r24, 0x46	; 70
    2474:	90 e0       	ldi	r25, 0x00	; 0
    2476:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
    247a:	1f c0       	rjmp	.+62     	; 0x24ba <south+0x5e>
    } 
	else if (current_orientation == point_west) 
    247c:	20 91 10 02 	lds	r18, 0x0210
    2480:	30 91 11 02 	lds	r19, 0x0211
    2484:	28 17       	cp	r18, r24
    2486:	39 07       	cpc	r19, r25
    2488:	49 f4       	brne	.+18     	; 0x249c <south+0x40>
	{
        velocity(255,255);
    248a:	8f ef       	ldi	r24, 0xFF	; 255
    248c:	6f ef       	ldi	r22, 0xFF	; 255
    248e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_left(70);
    2492:	86 e4       	ldi	r24, 0x46	; 70
    2494:	90 e0       	ldi	r25, 0x00	; 0
    2496:	0e 94 75 07 	call	0xeea	; 0xeea <turn_left>
    249a:	0f c0       	rjmp	.+30     	; 0x24ba <south+0x5e>
    }
	else if (current_orientation == point_north)
    249c:	20 91 9d 06 	lds	r18, 0x069D
    24a0:	30 91 9e 06 	lds	r19, 0x069E
    24a4:	28 17       	cp	r18, r24
    24a6:	39 07       	cpc	r19, r25
    24a8:	41 f4       	brne	.+16     	; 0x24ba <south+0x5e>
	{
		velocity(255,255);
    24aa:	8f ef       	ldi	r24, 0xFF	; 255
    24ac:	6f ef       	ldi	r22, 0xFF	; 255
    24ae:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(160);
    24b2:	80 ea       	ldi	r24, 0xA0	; 160
    24b4:	90 e0       	ldi	r25, 0x00	; 0
    24b6:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
	}
    orientation = point_south;
    24ba:	80 91 12 02 	lds	r24, 0x0212
    24be:	90 91 13 02 	lds	r25, 0x0213
    24c2:	90 93 96 06 	sts	0x0696, r25
    24c6:	80 93 95 06 	sts	0x0695, r24
}
    24ca:	08 95       	ret

000024cc <west>:
 * Example Call: north(pointing_east);
 *
 */
void west(unsigned int current_orientation) 
{ 
    if (current_orientation == point_north) 
    24cc:	20 91 9d 06 	lds	r18, 0x069D
    24d0:	30 91 9e 06 	lds	r19, 0x069E
    24d4:	28 17       	cp	r18, r24
    24d6:	39 07       	cpc	r19, r25
    24d8:	49 f4       	brne	.+18     	; 0x24ec <west+0x20>
	{ 
        velocity(255,255);
    24da:	8f ef       	ldi	r24, 0xFF	; 255
    24dc:	6f ef       	ldi	r22, 0xFF	; 255
    24de:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
	    turn_left(70);
    24e2:	86 e4       	ldi	r24, 0x46	; 70
    24e4:	90 e0       	ldi	r25, 0x00	; 0
    24e6:	0e 94 75 07 	call	0xeea	; 0xeea <turn_left>
    24ea:	1f c0       	rjmp	.+62     	; 0x252a <west+0x5e>
    } 
	else if (current_orientation == point_south) 
    24ec:	20 91 12 02 	lds	r18, 0x0212
    24f0:	30 91 13 02 	lds	r19, 0x0213
    24f4:	28 17       	cp	r18, r24
    24f6:	39 07       	cpc	r19, r25
    24f8:	49 f4       	brne	.+18     	; 0x250c <west+0x40>
	{ 
		velocity(255,255);
    24fa:	8f ef       	ldi	r24, 0xFF	; 255
    24fc:	6f ef       	ldi	r22, 0xFF	; 255
    24fe:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
        turn_right(70);      
    2502:	86 e4       	ldi	r24, 0x46	; 70
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
    250a:	0f c0       	rjmp	.+30     	; 0x252a <west+0x5e>
    }
	else if (current_orientation == point_east)
    250c:	20 91 14 02 	lds	r18, 0x0214
    2510:	30 91 15 02 	lds	r19, 0x0215
    2514:	28 17       	cp	r18, r24
    2516:	39 07       	cpc	r19, r25
    2518:	41 f4       	brne	.+16     	; 0x252a <west+0x5e>
	{ 
		velocity(255,255);
    251a:	8f ef       	ldi	r24, 0xFF	; 255
    251c:	6f ef       	ldi	r22, 0xFF	; 255
    251e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(160);
    2522:	80 ea       	ldi	r24, 0xA0	; 160
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
	}
    orientation = point_west;
    252a:	80 91 10 02 	lds	r24, 0x0210
    252e:	90 91 11 02 	lds	r25, 0x0211
    2532:	90 93 96 06 	sts	0x0696, r25
    2536:	80 93 95 06 	sts	0x0695, r24
}
    253a:	08 95       	ret

0000253c <east>:
 * Example Call: south(pointing_east);
 *
 */
void east(int current_orientation) 
{
    if (current_orientation == point_north) 
    253c:	20 91 9d 06 	lds	r18, 0x069D
    2540:	30 91 9e 06 	lds	r19, 0x069E
    2544:	82 17       	cp	r24, r18
    2546:	93 07       	cpc	r25, r19
    2548:	49 f4       	brne	.+18     	; 0x255c <east+0x20>
	{
       velocity(255,255);
    254a:	8f ef       	ldi	r24, 0xFF	; 255
    254c:	6f ef       	ldi	r22, 0xFF	; 255
    254e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
	   turn_right(70);
    2552:	86 e4       	ldi	r24, 0x46	; 70
    2554:	90 e0       	ldi	r25, 0x00	; 0
    2556:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
    255a:	1f c0       	rjmp	.+62     	; 0x259a <east+0x5e>
    } 
	else if (current_orientation == point_south) 
    255c:	20 91 12 02 	lds	r18, 0x0212
    2560:	30 91 13 02 	lds	r19, 0x0213
    2564:	82 17       	cp	r24, r18
    2566:	93 07       	cpc	r25, r19
    2568:	49 f4       	brne	.+18     	; 0x257c <east+0x40>
	{ 
        velocity(255,255);
    256a:	8f ef       	ldi	r24, 0xFF	; 255
    256c:	6f ef       	ldi	r22, 0xFF	; 255
    256e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
        turn_left(70);
    2572:	86 e4       	ldi	r24, 0x46	; 70
    2574:	90 e0       	ldi	r25, 0x00	; 0
    2576:	0e 94 75 07 	call	0xeea	; 0xeea <turn_left>
    257a:	0f c0       	rjmp	.+30     	; 0x259a <east+0x5e>
    }
	else if (current_orientation == point_west)
    257c:	20 91 10 02 	lds	r18, 0x0210
    2580:	30 91 11 02 	lds	r19, 0x0211
    2584:	82 17       	cp	r24, r18
    2586:	93 07       	cpc	r25, r19
    2588:	41 f4       	brne	.+16     	; 0x259a <east+0x5e>
	{
		velocity(255,255);
    258a:	8f ef       	ldi	r24, 0xFF	; 255
    258c:	6f ef       	ldi	r22, 0xFF	; 255
    258e:	0e 94 55 07 	call	0xeaa	; 0xeaa <velocity>
		turn_right(160);
    2592:	80 ea       	ldi	r24, 0xA0	; 160
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	0e 94 a4 07 	call	0xf48	; 0xf48 <turn_right>
	}
    orientation = point_east;
    259a:	80 91 14 02 	lds	r24, 0x0214
    259e:	90 91 15 02 	lds	r25, 0x0215
    25a2:	90 93 96 06 	sts	0x0696, r25
    25a6:	80 93 95 06 	sts	0x0695, r24
}
    25aa:	08 95       	ret

000025ac <travel>:
 * Example Call: travel(12,13);
 *					OR
 *				  travel(current_position,next_position)
 */
void travel(int from, int to) 
{
    25ac:	cf 92       	push	r12
    25ae:	df 92       	push	r13
    25b0:	ef 92       	push	r14
    25b2:	ff 92       	push	r15
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17
    25b8:	cf 93       	push	r28
    25ba:	df 93       	push	r29
    25bc:	7c 01       	movw	r14, r24
    25be:	6b 01       	movw	r12, r22
    int x1 = from % 10;
    int y1 = from / 10;
    int x2 = to % 10;
    int y2 = to / 10;
	lcd_print(2,5,from,2);
    25c0:	82 e0       	ldi	r24, 0x02	; 2
    25c2:	65 e0       	ldi	r22, 0x05	; 5
    25c4:	a7 01       	movw	r20, r14
    25c6:	22 e0       	ldi	r18, 0x02	; 2
    25c8:	30 e0       	ldi	r19, 0x00	; 0
    25ca:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
	lcd_print(2,8,to,2);
    25ce:	82 e0       	ldi	r24, 0x02	; 2
    25d0:	68 e0       	ldi	r22, 0x08	; 8
    25d2:	a6 01       	movw	r20, r12
    25d4:	22 e0       	ldi	r18, 0x02	; 2
    25d6:	30 e0       	ldi	r19, 0x00	; 0
    25d8:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
    if (from != to) 
    25dc:	ec 14       	cp	r14, r12
    25de:	fd 04       	cpc	r15, r13
    25e0:	09 f4       	brne	.+2      	; 0x25e4 <travel+0x38>
    25e2:	58 c0       	rjmp	.+176    	; 0x2694 <travel+0xe8>
 *				  travel(current_position,next_position)
 */
void travel(int from, int to) 
{
    int x1 = from % 10;
    int y1 = from / 10;
    25e4:	2a e0       	ldi	r18, 0x0A	; 10
    25e6:	30 e0       	ldi	r19, 0x00	; 0
    25e8:	c7 01       	movw	r24, r14
    25ea:	b9 01       	movw	r22, r18
    25ec:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    25f0:	8b 01       	movw	r16, r22
    int x2 = to % 10;
    int y2 = to / 10;
    25f2:	c6 01       	movw	r24, r12
    25f4:	b9 01       	movw	r22, r18
    25f6:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    25fa:	eb 01       	movw	r28, r22
	lcd_print(2,5,from,2);
	lcd_print(2,8,to,2);
    if (from != to) 
	{
            if (y1 != y2) 
    25fc:	06 17       	cp	r16, r22
    25fe:	17 07       	cpc	r17, r23
    2600:	e9 f0       	breq	.+58     	; 0x263c <travel+0x90>
			{
                if (y1 > y2) // e.g travel(21,11) in this case one has to travel south
    2602:	60 17       	cp	r22, r16
    2604:	71 07       	cpc	r23, r17
    2606:	64 f4       	brge	.+24     	; 0x2620 <travel+0x74>
                    while (y1 != y2) 
					{
                        south(orientation);
    2608:	80 91 95 06 	lds	r24, 0x0695
    260c:	90 91 96 06 	lds	r25, 0x0696
    2610:	0e 94 2e 12 	call	0x245c	; 0x245c <south>
                        y1--;
    2614:	01 50       	subi	r16, 0x01	; 1
    2616:	10 40       	sbci	r17, 0x00	; 0
    if (from != to) 
	{
            if (y1 != y2) 
			{
                if (y1 > y2) // e.g travel(21,11) in this case one has to travel south
                    while (y1 != y2) 
    2618:	c0 17       	cp	r28, r16
    261a:	d1 07       	cpc	r29, r17
    261c:	a9 f7       	brne	.-22     	; 0x2608 <travel+0x5c>
    261e:	0e c0       	rjmp	.+28     	; 0x263c <travel+0x90>
					{
                        south(orientation);
                        y1--;
                    } 
				else if (y2 > y1)// e.g travel(11,21) in this case one has to travel north
    2620:	06 17       	cp	r16, r22
    2622:	17 07       	cpc	r17, r23
    2624:	5c f4       	brge	.+22     	; 0x263c <travel+0x90>
                    while (y2 != y1) 
					{
                        north(orientation);
    2626:	80 91 95 06 	lds	r24, 0x0695
    262a:	90 91 96 06 	lds	r25, 0x0696
    262e:	0e 94 f6 11 	call	0x23ec	; 0x23ec <north>
                        y1++;
    2632:	0f 5f       	subi	r16, 0xFF	; 255
    2634:	1f 4f       	sbci	r17, 0xFF	; 255
					{
                        south(orientation);
                        y1--;
                    } 
				else if (y2 > y1)// e.g travel(11,21) in this case one has to travel north
                    while (y2 != y1) 
    2636:	c0 17       	cp	r28, r16
    2638:	d1 07       	cpc	r29, r17
    263a:	a9 f7       	brne	.-22     	; 0x2626 <travel+0x7a>
 *					OR
 *				  travel(current_position,next_position)
 */
void travel(int from, int to) 
{
    int x1 = from % 10;
    263c:	2a e0       	ldi	r18, 0x0A	; 10
    263e:	30 e0       	ldi	r19, 0x00	; 0
    2640:	c7 01       	movw	r24, r14
    2642:	b9 01       	movw	r22, r18
    2644:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    2648:	8c 01       	movw	r16, r24
    int y1 = from / 10;
    int x2 = to % 10;
    264a:	c6 01       	movw	r24, r12
    264c:	b9 01       	movw	r22, r18
    264e:	0e 94 79 18 	call	0x30f2	; 0x30f2 <__divmodhi4>
    2652:	ec 01       	movw	r28, r24
					{
                        north(orientation);
                        y1++;
                    }
            }
            if (x1 != x2) 
    2654:	08 17       	cp	r16, r24
    2656:	19 07       	cpc	r17, r25
    2658:	e9 f0       	breq	.+58     	; 0x2694 <travel+0xe8>
			{
                if (x1 > x2)// e.g travel(12,11) in this case one has to travel west
    265a:	80 17       	cp	r24, r16
    265c:	91 07       	cpc	r25, r17
    265e:	64 f4       	brge	.+24     	; 0x2678 <travel+0xcc>
                    while (x1 != x2) 
					{
                        west(orientation);
    2660:	80 91 95 06 	lds	r24, 0x0695
    2664:	90 91 96 06 	lds	r25, 0x0696
    2668:	0e 94 66 12 	call	0x24cc	; 0x24cc <west>
                        x1--;
    266c:	01 50       	subi	r16, 0x01	; 1
    266e:	10 40       	sbci	r17, 0x00	; 0
                    }
            }
            if (x1 != x2) 
			{
                if (x1 > x2)// e.g travel(12,11) in this case one has to travel west
                    while (x1 != x2) 
    2670:	c0 17       	cp	r28, r16
    2672:	d1 07       	cpc	r29, r17
    2674:	a9 f7       	brne	.-22     	; 0x2660 <travel+0xb4>
    2676:	0e c0       	rjmp	.+28     	; 0x2694 <travel+0xe8>
					{
                        west(orientation);
                        x1--;

                    } 
				else if (x2 > x1)// e.g travel(11,12) in this case one has to travel east
    2678:	08 17       	cp	r16, r24
    267a:	19 07       	cpc	r17, r25
    267c:	5c f4       	brge	.+22     	; 0x2694 <travel+0xe8>
                    while (x1 != x2) 
					{
                        east(orientation);
    267e:	80 91 95 06 	lds	r24, 0x0695
    2682:	90 91 96 06 	lds	r25, 0x0696
    2686:	0e 94 9e 12 	call	0x253c	; 0x253c <east>
                        x1++;
    268a:	0f 5f       	subi	r16, 0xFF	; 255
    268c:	1f 4f       	sbci	r17, 0xFF	; 255
                        west(orientation);
                        x1--;

                    } 
				else if (x2 > x1)// e.g travel(11,12) in this case one has to travel east
                    while (x1 != x2) 
    268e:	c0 17       	cp	r28, r16
    2690:	d1 07       	cpc	r29, r17
    2692:	a9 f7       	brne	.-22     	; 0x267e <travel+0xd2>
                        x1++;
					}
            }
        }
		
		scanForBlackDebris();
    2694:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <scanForBlackDebris>
		scanForWhiteDebris();
    2698:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <scanForWhiteDebris>
		if(resetPath != 1)
    269c:	80 91 5a 06 	lds	r24, 0x065A
    26a0:	90 91 5b 06 	lds	r25, 0x065B
    26a4:	81 30       	cpi	r24, 0x01	; 1
    26a6:	91 05       	cpc	r25, r1
    26a8:	11 f0       	breq	.+4      	; 0x26ae <travel+0x102>
			follow();
    26aa:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <follow>
}
    26ae:	df 91       	pop	r29
    26b0:	cf 91       	pop	r28
    26b2:	1f 91       	pop	r17
    26b4:	0f 91       	pop	r16
    26b6:	ff 90       	pop	r15
    26b8:	ef 90       	pop	r14
    26ba:	df 90       	pop	r13
    26bc:	cf 90       	pop	r12
    26be:	08 95       	ret

000026c0 <travelPath>:
 *	 	
 * Example Call: travelPath(paths);
 *					
 */
void travelPath(struct pathStack paths)
{
    26c0:	ef 92       	push	r14
    26c2:	ff 92       	push	r15
    26c4:	0f 93       	push	r16
    26c6:	1f 93       	push	r17
    26c8:	cf 93       	push	r28
    26ca:	df 93       	push	r29
    26cc:	cd b7       	in	r28, 0x3d	; 61
    26ce:	de b7       	in	r29, 0x3e	; 62
	for(int i = paths.length; i > 0; i--) //the loop shall iterate from the length of the structure to 1 
    26d0:	ce 52       	subi	r28, 0x2E	; 46
    26d2:	df 4f       	sbci	r29, 0xFF	; 255
    26d4:	e8 80       	ld	r14, Y
    26d6:	f9 80       	ldd	r15, Y+1	; 0x01
    26d8:	c2 5d       	subi	r28, 0xD2	; 210
    26da:	d0 40       	sbci	r29, 0x00	; 0
    26dc:	1e 14       	cp	r1, r14
    26de:	1f 04       	cpc	r1, r15
    26e0:	0c f5       	brge	.+66     	; 0x2724 <travelPath+0x64>
 *         2) and also check the reset path flag if it is one then the path needs to be recalculated so break the current travel path loop
 *	 	
 * Example Call: travelPath(paths);
 *					
 */
void travelPath(struct pathStack paths)
    26e2:	87 01       	movw	r16, r14
    26e4:	00 0f       	add	r16, r16
    26e6:	11 1f       	adc	r17, r17
    26e8:	8a e0       	ldi	r24, 0x0A	; 10
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	8c 0f       	add	r24, r28
    26ee:	9d 1f       	adc	r25, r29
    26f0:	08 0f       	add	r16, r24
    26f2:	19 1f       	adc	r17, r25
{
	for(int i = paths.length; i > 0; i--) //the loop shall iterate from the length of the structure to 1 
	{
		travel(paths.path[i], paths.path[i-1]); //travel function is called node by node to travel from one node to other adjacent node 
    26f4:	f8 01       	movw	r30, r16
    26f6:	80 81       	ld	r24, Z
    26f8:	91 81       	ldd	r25, Z+1	; 0x01
    26fa:	72 91       	ld	r23, -Z
    26fc:	62 91       	ld	r22, -Z
    26fe:	8f 01       	movw	r16, r30
    2700:	0e 94 d6 12 	call	0x25ac	; 0x25ac <travel>
		
		if(resetPath == 1)//if the path has been reset then stop following and break
    2704:	80 91 5a 06 	lds	r24, 0x065A
    2708:	90 91 5b 06 	lds	r25, 0x065B
    270c:	81 30       	cpi	r24, 0x01	; 1
    270e:	91 05       	cpc	r25, r1
    2710:	19 f4       	brne	.+6      	; 0x2718 <travelPath+0x58>
		{
			stop();
    2712:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
			return;
    2716:	08 c0       	rjmp	.+16     	; 0x2728 <travelPath+0x68>
 * Example Call: travelPath(paths);
 *					
 */
void travelPath(struct pathStack paths)
{
	for(int i = paths.length; i > 0; i--) //the loop shall iterate from the length of the structure to 1 
    2718:	08 94       	sec
    271a:	e1 08       	sbc	r14, r1
    271c:	f1 08       	sbc	r15, r1
    271e:	e1 14       	cp	r14, r1
    2720:	f1 04       	cpc	r15, r1
    2722:	41 f7       	brne	.-48     	; 0x26f4 <travelPath+0x34>
			stop();
			return;
		}
	}
	//After reaching the destination plot scan for the white debris
	scanForWhiteDebris();
    2724:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <scanForWhiteDebris>
}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	1f 91       	pop	r17
    272e:	0f 91       	pop	r16
    2730:	ff 90       	pop	r15
    2732:	ef 90       	pop	r14
    2734:	08 95       	ret

00002736 <sendPathtoRescueBot>:
 * Output: void
 * Logic:  this function shall make the search bot send its path to the rescue bot so it may avoid traveling by this path 
 * Example Call: sendPathtoRescueBot(path);			
 */
void sendPathtoRescueBot(struct pathStack path)
{
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	cd b7       	in	r28, 0x3d	; 61
    273c:	de b7       	in	r29, 0x3e	; 62
	for (int i = path.length; i >= 0; i--)//loop shall iterate from the length of the path to 0 and send the path node by node
    273e:	c2 53       	subi	r28, 0x32	; 50
    2740:	df 4f       	sbci	r29, 0xFF	; 255
    2742:	88 81       	ld	r24, Y
    2744:	99 81       	ldd	r25, Y+1	; 0x01
    2746:	ce 5c       	subi	r28, 0xCE	; 206
    2748:	d0 40       	sbci	r29, 0x00	; 0
    274a:	99 23       	and	r25, r25
    274c:	dc f0       	brlt	.+54     	; 0x2784 <sendPathtoRescueBot+0x4e>
 * Input: struct pathStack path -> the path to be followed to reach intended destination
 * Output: void
 * Logic:  this function shall make the search bot send its path to the rescue bot so it may avoid traveling by this path 
 * Example Call: sendPathtoRescueBot(path);			
 */
void sendPathtoRescueBot(struct pathStack path)
    274e:	fc 01       	movw	r30, r24
    2750:	31 96       	adiw	r30, 0x01	; 1
    2752:	ee 0f       	add	r30, r30
    2754:	ff 1f       	adc	r31, r31
    2756:	26 e0       	ldi	r18, 0x06	; 6
    2758:	30 e0       	ldi	r19, 0x00	; 0
    275a:	2c 0f       	add	r18, r28
    275c:	3d 1f       	adc	r19, r29
    275e:	e2 0f       	add	r30, r18
    2760:	f3 1f       	adc	r31, r19
{
	for (int i = path.length; i >= 0; i--)//loop shall iterate from the length of the path to 0 and send the path node by node
	{
		UDR0 = (char)path.path[i];
    2762:	46 ec       	ldi	r20, 0xC6	; 198
    2764:	50 e0       	ldi	r21, 0x00	; 0
 * Logic:  this function shall make the search bot send its path to the rescue bot so it may avoid traveling by this path 
 * Example Call: sendPathtoRescueBot(path);			
 */
void sendPathtoRescueBot(struct pathStack path)
{
	for (int i = path.length; i >= 0; i--)//loop shall iterate from the length of the path to 0 and send the path node by node
    2766:	32 97       	sbiw	r30, 0x02	; 2
	{
		UDR0 = (char)path.path[i];
    2768:	20 81       	ld	r18, Z
    276a:	da 01       	movw	r26, r20
    276c:	2c 93       	st	X, r18
    276e:	af ef       	ldi	r26, 0xFF	; 255
    2770:	b7 e4       	ldi	r27, 0x47	; 71
    2772:	11 97       	sbiw	r26, 0x01	; 1
    2774:	f1 f7       	brne	.-4      	; 0x2772 <sendPathtoRescueBot+0x3c>
    2776:	00 c0       	rjmp	.+0      	; 0x2778 <sendPathtoRescueBot+0x42>
    2778:	00 00       	nop
 * Logic:  this function shall make the search bot send its path to the rescue bot so it may avoid traveling by this path 
 * Example Call: sendPathtoRescueBot(path);			
 */
void sendPathtoRescueBot(struct pathStack path)
{
	for (int i = path.length; i >= 0; i--)//loop shall iterate from the length of the path to 0 and send the path node by node
    277a:	01 97       	sbiw	r24, 0x01	; 1
    277c:	bf ef       	ldi	r27, 0xFF	; 255
    277e:	8f 3f       	cpi	r24, 0xFF	; 255
    2780:	9b 07       	cpc	r25, r27
    2782:	89 f7       	brne	.-30     	; 0x2766 <sendPathtoRescueBot+0x30>
	{
		UDR0 = (char)path.path[i];
		_delay_ms(5);
	}
	UDR0 = 1; //to indicate end of path sending routine to the rescue
    2784:	81 e0       	ldi	r24, 0x01	; 1
    2786:	80 93 c6 00 	sts	0x00C6, r24
    278a:	8f ef       	ldi	r24, 0xFF	; 255
    278c:	9f e3       	ldi	r25, 0x3F	; 63
    278e:	a2 e0       	ldi	r26, 0x02	; 2
    2790:	81 50       	subi	r24, 0x01	; 1
    2792:	90 40       	sbci	r25, 0x00	; 0
    2794:	a0 40       	sbci	r26, 0x00	; 0
    2796:	e1 f7       	brne	.-8      	; 0x2790 <sendPathtoRescueBot+0x5a>
    2798:	00 c0       	rjmp	.+0      	; 0x279a <sendPathtoRescueBot+0x64>
    279a:	00 00       	nop
	_delay_ms(50);
}
    279c:	df 91       	pop	r29
    279e:	cf 91       	pop	r28
    27a0:	08 95       	ret

000027a2 <gotoNearestCornerAndStop>:
 * Output: void
 * Logic:  this function shall make the search bot go to the nearest corner in the arena after it has scanned all plots so that rescue may travel freely in the arena
 * Example Call: gotoNearestCornerAndStop();			
 */
void gotoNearestCornerAndStop()
{
    27a2:	af 92       	push	r10
    27a4:	bf 92       	push	r11
    27a6:	df 92       	push	r13
    27a8:	ef 92       	push	r14
    27aa:	ff 92       	push	r15
    27ac:	0f 93       	push	r16
    27ae:	1f 93       	push	r17
    27b0:	cf 93       	push	r28
    27b2:	df 93       	push	r29
    27b4:	cd b7       	in	r28, 0x3d	; 61
    27b6:	de b7       	in	r29, 0x3e	; 62
    27b8:	c2 5d       	subi	r28, 0xD2	; 210
    27ba:	d0 40       	sbci	r29, 0x00	; 0
    27bc:	0f b6       	in	r0, 0x3f	; 63
    27be:	f8 94       	cli
    27c0:	de bf       	out	0x3e, r29	; 62
    27c2:	0f be       	out	0x3f, r0	; 63
    27c4:	cd bf       	out	0x3d, r28	; 61
	int cornersCoordinates[4] = {11, 19, 91, 99}; //these are the co-ordinates of the corner nodes
    27c6:	de 01       	movw	r26, r28
    27c8:	11 96       	adiw	r26, 0x01	; 1
    27ca:	e0 e0       	ldi	r30, 0x00	; 0
    27cc:	f2 e0       	ldi	r31, 0x02	; 2
    27ce:	88 e0       	ldi	r24, 0x08	; 8
    27d0:	01 90       	ld	r0, Z+
    27d2:	0d 92       	st	X+, r0
    27d4:	81 50       	subi	r24, 0x01	; 1
    27d6:	e1 f7       	brne	.-8      	; 0x27d0 <gotoNearestCornerAndStop+0x2e>
 * Input: void
 * Output: void
 * Logic:  this function shall make the search bot go to the nearest corner in the arena after it has scanned all plots so that rescue may travel freely in the arena
 * Example Call: gotoNearestCornerAndStop();			
 */
void gotoNearestCornerAndStop()
    27d8:	8e 01       	movw	r16, r28
    27da:	07 5f       	subi	r16, 0xF7	; 247
    27dc:	1f 4f       	sbci	r17, 0xFF	; 255
	int cornersCoordinates[4] = {11, 19, 91, 99}; //these are the co-ordinates of the corner nodes
	int selectedCorner = 0;
	//loop shall end when the search bot arrives at some corner co-ordinate 
	do 
	{
		selectedCorner = 0;
    27de:	aa 24       	eor	r10, r10
    27e0:	bb 24       	eor	r11, r11
			int diff = abs(current_pos - cornersCoordinates[i]); //the node which gives the least difference shall be our chosen node
			if(diff < mindiff)
			selectedCorner = cornersCoordinates[i];//selectedCorner is changed if a different corner gives a lesser difference i.e closer 
		}
		struct pathStack paths = findPath(current_pos, selectedCorner); //path is computed for the intended corner
		travelPath(paths);
    27e2:	0f 2e       	mov	r0, r31
    27e4:	fa ec       	ldi	r31, 0xCA	; 202
    27e6:	df 2e       	mov	r13, r31
    27e8:	f0 2d       	mov	r31, r0
	{
		selectedCorner = 0;
		int mindiff = 999; //parameter for closest node computation is set to a large value
		for(int i = 0; i < 4; i++) //loop iterates through all 4 corner vertex
		{
			int diff = abs(current_pos - cornersCoordinates[i]); //the node which gives the least difference shall be our chosen node
    27ea:	60 91 9b 06 	lds	r22, 0x069B
    27ee:	70 91 9c 06 	lds	r23, 0x069C
    27f2:	fe 01       	movw	r30, r28
    27f4:	31 96       	adiw	r30, 0x01	; 1
	int cornersCoordinates[4] = {11, 19, 91, 99}; //these are the co-ordinates of the corner nodes
	int selectedCorner = 0;
	//loop shall end when the search bot arrives at some corner co-ordinate 
	do 
	{
		selectedCorner = 0;
    27f6:	75 01       	movw	r14, r10
		int mindiff = 999; //parameter for closest node computation is set to a large value
		for(int i = 0; i < 4; i++) //loop iterates through all 4 corner vertex
		{
			int diff = abs(current_pos - cornersCoordinates[i]); //the node which gives the least difference shall be our chosen node
    27f8:	21 91       	ld	r18, Z+
    27fa:	31 91       	ld	r19, Z+
    27fc:	cb 01       	movw	r24, r22
    27fe:	82 1b       	sub	r24, r18
    2800:	93 0b       	sbc	r25, r19
    2802:	1a f4       	brpl	.+6      	; 0x280a <gotoNearestCornerAndStop+0x68>
    2804:	90 95       	com	r25
    2806:	81 95       	neg	r24
    2808:	9f 4f       	sbci	r25, 0xFF	; 255
			if(diff < mindiff)
    280a:	43 e0       	ldi	r20, 0x03	; 3
    280c:	87 3e       	cpi	r24, 0xE7	; 231
    280e:	94 07       	cpc	r25, r20
    2810:	0c f4       	brge	.+2      	; 0x2814 <gotoNearestCornerAndStop+0x72>
			selectedCorner = cornersCoordinates[i];//selectedCorner is changed if a different corner gives a lesser difference i.e closer 
    2812:	79 01       	movw	r14, r18
	//loop shall end when the search bot arrives at some corner co-ordinate 
	do 
	{
		selectedCorner = 0;
		int mindiff = 999; //parameter for closest node computation is set to a large value
		for(int i = 0; i < 4; i++) //loop iterates through all 4 corner vertex
    2814:	e0 17       	cp	r30, r16
    2816:	f1 07       	cpc	r31, r17
    2818:	79 f7       	brne	.-34     	; 0x27f8 <gotoNearestCornerAndStop+0x56>
		{
			int diff = abs(current_pos - cornersCoordinates[i]); //the node which gives the least difference shall be our chosen node
			if(diff < mindiff)
			selectedCorner = cornersCoordinates[i];//selectedCorner is changed if a different corner gives a lesser difference i.e closer 
		}
		struct pathStack paths = findPath(current_pos, selectedCorner); //path is computed for the intended corner
    281a:	c8 01       	movw	r24, r16
    281c:	a7 01       	movw	r20, r14
    281e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <findPath>
		travelPath(paths);
    2822:	8d b7       	in	r24, 0x3d	; 61
    2824:	9e b7       	in	r25, 0x3e	; 62
    2826:	8a 5c       	subi	r24, 0xCA	; 202
    2828:	90 40       	sbci	r25, 0x00	; 0
    282a:	0f b6       	in	r0, 0x3f	; 63
    282c:	f8 94       	cli
    282e:	9e bf       	out	0x3e, r25	; 62
    2830:	0f be       	out	0x3f, r0	; 63
    2832:	8d bf       	out	0x3d, r24	; 61
    2834:	ed b7       	in	r30, 0x3d	; 61
    2836:	fe b7       	in	r31, 0x3e	; 62
    2838:	31 96       	adiw	r30, 0x01	; 1
    283a:	d8 01       	movw	r26, r16
    283c:	8d 2d       	mov	r24, r13
    283e:	0d 90       	ld	r0, X+
    2840:	01 92       	st	Z+, r0
    2842:	81 50       	subi	r24, 0x01	; 1
    2844:	e1 f7       	brne	.-8      	; 0x283e <gotoNearestCornerAndStop+0x9c>
    2846:	0e 94 60 13 	call	0x26c0	; 0x26c0 <travelPath>
	}
	while(current_pos != selectedCorner);		
    284a:	8d b7       	in	r24, 0x3d	; 61
    284c:	9e b7       	in	r25, 0x3e	; 62
    284e:	86 53       	subi	r24, 0x36	; 54
    2850:	9f 4f       	sbci	r25, 0xFF	; 255
    2852:	0f b6       	in	r0, 0x3f	; 63
    2854:	f8 94       	cli
    2856:	9e bf       	out	0x3e, r25	; 62
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	8d bf       	out	0x3d, r24	; 61
    285c:	80 91 9b 06 	lds	r24, 0x069B
    2860:	90 91 9c 06 	lds	r25, 0x069C
    2864:	e8 16       	cp	r14, r24
    2866:	f9 06       	cpc	r15, r25
    2868:	09 f0       	breq	.+2      	; 0x286c <gotoNearestCornerAndStop+0xca>
    286a:	bf cf       	rjmp	.-130    	; 0x27ea <gotoNearestCornerAndStop+0x48>
	
}
    286c:	ce 52       	subi	r28, 0x2E	; 46
    286e:	df 4f       	sbci	r29, 0xFF	; 255
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	de bf       	out	0x3e, r29	; 62
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	cd bf       	out	0x3d, r28	; 61
    287a:	df 91       	pop	r29
    287c:	cf 91       	pop	r28
    287e:	1f 91       	pop	r17
    2880:	0f 91       	pop	r16
    2882:	ff 90       	pop	r15
    2884:	ef 90       	pop	r14
    2886:	df 90       	pop	r13
    2888:	bf 90       	pop	r11
    288a:	af 90       	pop	r10
    288c:	08 95       	ret

0000288e <main>:
		   3)stop
			  
 * Example Call: gotoNearestCornerAndStop();			
 */
int main(void)
{
    288e:	1f 93       	push	r17
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
    2898:	ca 5c       	subi	r28, 0xCA	; 202
    289a:	d0 40       	sbci	r29, 0x00	; 0
    289c:	0f b6       	in	r0, 0x3f	; 63
    289e:	f8 94       	cli
    28a0:	de bf       	out	0x3e, r29	; 62
    28a2:	0f be       	out	0x3f, r0	; 63
    28a4:	cd bf       	out	0x3d, r28	; 61
	init_devices();
    28a6:	0e 94 5a 07 	call	0xeb4	; 0xeb4 <init_devices>
	lcd_set_4bit();
    28aa:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
	lcd_init();
    28ae:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_init>
	color_sensor_scaling();
    28b2:	0e 94 98 03 	call	0x730	; 0x730 <color_sensor_scaling>
	init_cinfo_matrix();//initialize the table that holds co-ordinate information
    28b6:	0e 94 0d 08 	call	0x101a	; 0x101a <init_cinfo_matrix>
	
	//set the servo mechanism to its default orientation
	base_servo(90);
    28ba:	8a e5       	ldi	r24, 0x5A	; 90
    28bc:	0e 94 7f 02 	call	0x4fe	; 0x4fe <base_servo>
    28c0:	8f ef       	ldi	r24, 0xFF	; 255
    28c2:	9f e7       	ldi	r25, 0x7F	; 127
    28c4:	ad e0       	ldi	r26, 0x0D	; 13
    28c6:	81 50       	subi	r24, 0x01	; 1
    28c8:	90 40       	sbci	r25, 0x00	; 0
    28ca:	a0 40       	sbci	r26, 0x00	; 0
    28cc:	e1 f7       	brne	.-8      	; 0x28c6 <main+0x38>
    28ce:	00 c0       	rjmp	.+0      	; 0x28d0 <main+0x42>
    28d0:	00 00       	nop
	_delay_ms(300);
	gripper_servo(20);
    28d2:	84 e1       	ldi	r24, 0x14	; 20
    28d4:	0e 94 b1 02 	call	0x562	; 0x562 <gripper_servo>
    28d8:	8f ef       	ldi	r24, 0xFF	; 255
    28da:	9f e7       	ldi	r25, 0x7F	; 127
    28dc:	ad e0       	ldi	r26, 0x0D	; 13
    28de:	81 50       	subi	r24, 0x01	; 1
    28e0:	90 40       	sbci	r25, 0x00	; 0
    28e2:	a0 40       	sbci	r26, 0x00	; 0
    28e4:	e1 f7       	brne	.-8      	; 0x28de <main+0x50>
    28e6:	00 c0       	rjmp	.+0      	; 0x28e8 <main+0x5a>
    28e8:	00 00       	nop
	_delay_ms(300);
	elbow_servo(0);
    28ea:	80 e0       	ldi	r24, 0x00	; 0
    28ec:	0e 94 98 02 	call	0x530	; 0x530 <elbow_servo>
    28f0:	8f ef       	ldi	r24, 0xFF	; 255
    28f2:	9f e7       	ldi	r25, 0x7F	; 127
    28f4:	ad e0       	ldi	r26, 0x0D	; 13
    28f6:	81 50       	subi	r24, 0x01	; 1
    28f8:	90 40       	sbci	r25, 0x00	; 0
    28fa:	a0 40       	sbci	r26, 0x00	; 0
    28fc:	e1 f7       	brne	.-8      	; 0x28f6 <main+0x68>
    28fe:	00 c0       	rjmp	.+0      	; 0x2900 <main+0x72>
    2900:	00 00       	nop
	_delay_ms(300);
	servo_base_free();
    2902:	0e 94 ca 02 	call	0x594	; 0x594 <servo_base_free>
	servo_elbow_free();
    2906:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <servo_elbow_free>
	servo_gripper_free();
    290a:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <servo_gripper_free>
	follow();//follow line 
    290e:	0e 94 6a 0d 	call	0x1ad4	; 0x1ad4 <follow>
	scanForBlackDebris();//scan for black debris at the front of start 
    2912:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <scanForBlackDebris>
			break;
		}
		not_scanned_plot = findUnscannedPlot();//fetch the next unscanned plot
		getAdjacentPlotPoints(not_scanned_plot);//get the locations from where the search may scan the survivor i.e the mid-point nodes which are adjacent to the survivor plot
		struct pathStack path = selectMinPathtoDestinationPlot();
		sendPathtoRescueBot(path);//obtain the shortest path to reach any one of those nodes 
    2916:	1a ec       	ldi	r17, 0xCA	; 202
	servo_gripper_free();
	follow();//follow line 
	scanForBlackDebris();//scan for black debris at the front of start 
	while(1)
	{
		stop();//stop
    2918:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
		if(resetPath==1)//if path has been reset then change the flag to 0
    291c:	80 91 5a 06 	lds	r24, 0x065A
    2920:	90 91 5b 06 	lds	r25, 0x065B
    2924:	81 30       	cpi	r24, 0x01	; 1
    2926:	91 05       	cpc	r25, r1
    2928:	21 f4       	brne	.+8      	; 0x2932 <main+0xa4>
		    resetPath = 0;
    292a:	10 92 5b 06 	sts	0x065B, r1
    292e:	10 92 5a 06 	sts	0x065A, r1
			
		if(plotScanCounter == 16)//if all plots scanned then send packet to rescue to set its searchComplete flag and then go and stand at the nearest corner node
    2932:	80 91 97 06 	lds	r24, 0x0697
    2936:	90 91 98 06 	lds	r25, 0x0698
    293a:	80 31       	cpi	r24, 0x10	; 16
    293c:	91 05       	cpc	r25, r1
    293e:	e1 f4       	brne	.+56     	; 0x2978 <main+0xea>
		{
			stop();
    2940:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
			UDR0 = 7;//send terminal packet to the rescue to set its searchComplete flag to 1
    2944:	87 e0       	ldi	r24, 0x07	; 7
    2946:	80 93 c6 00 	sts	0x00C6, r24
    294a:	af ef       	ldi	r26, 0xFF	; 255
    294c:	b7 e4       	ldi	r27, 0x47	; 71
    294e:	11 97       	sbiw	r26, 0x01	; 1
    2950:	f1 f7       	brne	.-4      	; 0x294e <main+0xc0>
    2952:	00 c0       	rjmp	.+0      	; 0x2954 <main+0xc6>
    2954:	00 00       	nop
			_delay_ms(5);
			gotoNearestCornerAndStop();//go and stand at the nearest corner node
    2956:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <gotoNearestCornerAndStop>
		travelPath(path);//follow that path
		int sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
		int value = Sharp_GP2D12_estimation(sharp);
		lcd_print(2,1,value,3);
	}
	stop();
    295a:	0e 94 11 05 	call	0xa22	; 0xa22 <stop>
    295e:	80 e0       	ldi	r24, 0x00	; 0
    2960:	90 e0       	ldi	r25, 0x00	; 0
    2962:	c6 53       	subi	r28, 0x36	; 54
    2964:	df 4f       	sbci	r29, 0xFF	; 255
    2966:	0f b6       	in	r0, 0x3f	; 63
    2968:	f8 94       	cli
    296a:	de bf       	out	0x3e, r29	; 62
    296c:	0f be       	out	0x3f, r0	; 63
    296e:	cd bf       	out	0x3d, r28	; 61
    2970:	df 91       	pop	r29
    2972:	cf 91       	pop	r28
    2974:	1f 91       	pop	r17
    2976:	08 95       	ret
			UDR0 = 7;//send terminal packet to the rescue to set its searchComplete flag to 1
			_delay_ms(5);
			gotoNearestCornerAndStop();//go and stand at the nearest corner node
			break;
		}
		not_scanned_plot = findUnscannedPlot();//fetch the next unscanned plot
    2978:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <findUnscannedPlot>
    297c:	90 93 9a 06 	sts	0x069A, r25
    2980:	80 93 99 06 	sts	0x0699, r24
		getAdjacentPlotPoints(not_scanned_plot);//get the locations from where the search may scan the survivor i.e the mid-point nodes which are adjacent to the survivor plot
    2984:	0e 94 08 0a 	call	0x1410	; 0x1410 <getAdjacentPlotPoints>
		struct pathStack path = selectMinPathtoDestinationPlot();
    2988:	ce 01       	movw	r24, r28
    298a:	01 96       	adiw	r24, 0x01	; 1
    298c:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <selectMinPathtoDestinationPlot>
		sendPathtoRescueBot(path);//obtain the shortest path to reach any one of those nodes 
    2990:	8d b7       	in	r24, 0x3d	; 61
    2992:	9e b7       	in	r25, 0x3e	; 62
    2994:	8a 5c       	subi	r24, 0xCA	; 202
    2996:	90 40       	sbci	r25, 0x00	; 0
    2998:	0f b6       	in	r0, 0x3f	; 63
    299a:	f8 94       	cli
    299c:	9e bf       	out	0x3e, r25	; 62
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	8d bf       	out	0x3d, r24	; 61
    29a2:	ad b7       	in	r26, 0x3d	; 61
    29a4:	be b7       	in	r27, 0x3e	; 62
    29a6:	11 96       	adiw	r26, 0x01	; 1
    29a8:	fe 01       	movw	r30, r28
    29aa:	31 96       	adiw	r30, 0x01	; 1
    29ac:	81 2f       	mov	r24, r17
    29ae:	01 90       	ld	r0, Z+
    29b0:	0d 92       	st	X+, r0
    29b2:	81 50       	subi	r24, 0x01	; 1
    29b4:	e1 f7       	brne	.-8      	; 0x29ae <main+0x120>
    29b6:	0e 94 9b 13 	call	0x2736	; 0x2736 <sendPathtoRescueBot>
		travelPath(path);//follow that path
    29ba:	ad b7       	in	r26, 0x3d	; 61
    29bc:	be b7       	in	r27, 0x3e	; 62
    29be:	a6 53       	subi	r26, 0x36	; 54
    29c0:	bf 4f       	sbci	r27, 0xFF	; 255
    29c2:	0f b6       	in	r0, 0x3f	; 63
    29c4:	f8 94       	cli
    29c6:	be bf       	out	0x3e, r27	; 62
    29c8:	0f be       	out	0x3f, r0	; 63
    29ca:	ad bf       	out	0x3d, r26	; 61
    29cc:	8d b7       	in	r24, 0x3d	; 61
    29ce:	9e b7       	in	r25, 0x3e	; 62
    29d0:	8a 5c       	subi	r24, 0xCA	; 202
    29d2:	90 40       	sbci	r25, 0x00	; 0
    29d4:	0f b6       	in	r0, 0x3f	; 63
    29d6:	f8 94       	cli
    29d8:	9e bf       	out	0x3e, r25	; 62
    29da:	0f be       	out	0x3f, r0	; 63
    29dc:	8d bf       	out	0x3d, r24	; 61
    29de:	ad b7       	in	r26, 0x3d	; 61
    29e0:	be b7       	in	r27, 0x3e	; 62
    29e2:	11 96       	adiw	r26, 0x01	; 1
    29e4:	fe 01       	movw	r30, r28
    29e6:	31 96       	adiw	r30, 0x01	; 1
    29e8:	81 2f       	mov	r24, r17
    29ea:	01 90       	ld	r0, Z+
    29ec:	0d 92       	st	X+, r0
    29ee:	81 50       	subi	r24, 0x01	; 1
    29f0:	e1 f7       	brne	.-8      	; 0x29ea <main+0x15c>
    29f2:	0e 94 60 13 	call	0x26c0	; 0x26c0 <travelPath>
		int sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    29f6:	ad b7       	in	r26, 0x3d	; 61
    29f8:	be b7       	in	r27, 0x3e	; 62
    29fa:	a6 53       	subi	r26, 0x36	; 54
    29fc:	bf 4f       	sbci	r27, 0xFF	; 255
    29fe:	0f b6       	in	r0, 0x3f	; 63
    2a00:	f8 94       	cli
    2a02:	be bf       	out	0x3e, r27	; 62
    2a04:	0f be       	out	0x3f, r0	; 63
    2a06:	ad bf       	out	0x3d, r26	; 61
    2a08:	8b e0       	ldi	r24, 0x0B	; 11
    2a0a:	0e 94 4b 06 	call	0xc96	; 0xc96 <ADC_Conversion>
		int value = Sharp_GP2D12_estimation(sharp);
    2a0e:	0e 94 15 05 	call	0xa2a	; 0xa2a <Sharp_GP2D12_estimation>
    2a12:	ac 01       	movw	r20, r24
		lcd_print(2,1,value,3);
    2a14:	82 e0       	ldi	r24, 0x02	; 2
    2a16:	61 e0       	ldi	r22, 0x01	; 1
    2a18:	23 e0       	ldi	r18, 0x03	; 3
    2a1a:	30 e0       	ldi	r19, 0x00	; 0
    2a1c:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
	}
    2a20:	7b cf       	rjmp	.-266    	; 0x2918 <main+0x8a>

00002a22 <__subsf3>:
    2a22:	50 58       	subi	r21, 0x80	; 128

00002a24 <__addsf3>:
    2a24:	bb 27       	eor	r27, r27
    2a26:	aa 27       	eor	r26, r26
    2a28:	0e d0       	rcall	.+28     	; 0x2a46 <__addsf3x>
    2a2a:	4d c1       	rjmp	.+666    	; 0x2cc6 <__fp_round>
    2a2c:	3e d1       	rcall	.+636    	; 0x2caa <__fp_pscA>
    2a2e:	30 f0       	brcs	.+12     	; 0x2a3c <__addsf3+0x18>
    2a30:	43 d1       	rcall	.+646    	; 0x2cb8 <__fp_pscB>
    2a32:	20 f0       	brcs	.+8      	; 0x2a3c <__addsf3+0x18>
    2a34:	31 f4       	brne	.+12     	; 0x2a42 <__addsf3+0x1e>
    2a36:	9f 3f       	cpi	r25, 0xFF	; 255
    2a38:	11 f4       	brne	.+4      	; 0x2a3e <__addsf3+0x1a>
    2a3a:	1e f4       	brtc	.+6      	; 0x2a42 <__addsf3+0x1e>
    2a3c:	33 c1       	rjmp	.+614    	; 0x2ca4 <__fp_nan>
    2a3e:	0e f4       	brtc	.+2      	; 0x2a42 <__addsf3+0x1e>
    2a40:	e0 95       	com	r30
    2a42:	e7 fb       	bst	r30, 7
    2a44:	29 c1       	rjmp	.+594    	; 0x2c98 <__fp_inf>

00002a46 <__addsf3x>:
    2a46:	e9 2f       	mov	r30, r25
    2a48:	4f d1       	rcall	.+670    	; 0x2ce8 <__fp_split3>
    2a4a:	80 f3       	brcs	.-32     	; 0x2a2c <__addsf3+0x8>
    2a4c:	ba 17       	cp	r27, r26
    2a4e:	62 07       	cpc	r22, r18
    2a50:	73 07       	cpc	r23, r19
    2a52:	84 07       	cpc	r24, r20
    2a54:	95 07       	cpc	r25, r21
    2a56:	18 f0       	brcs	.+6      	; 0x2a5e <__addsf3x+0x18>
    2a58:	71 f4       	brne	.+28     	; 0x2a76 <__addsf3x+0x30>
    2a5a:	9e f5       	brtc	.+102    	; 0x2ac2 <__addsf3x+0x7c>
    2a5c:	67 c1       	rjmp	.+718    	; 0x2d2c <__fp_zero>
    2a5e:	0e f4       	brtc	.+2      	; 0x2a62 <__addsf3x+0x1c>
    2a60:	e0 95       	com	r30
    2a62:	0b 2e       	mov	r0, r27
    2a64:	ba 2f       	mov	r27, r26
    2a66:	a0 2d       	mov	r26, r0
    2a68:	0b 01       	movw	r0, r22
    2a6a:	b9 01       	movw	r22, r18
    2a6c:	90 01       	movw	r18, r0
    2a6e:	0c 01       	movw	r0, r24
    2a70:	ca 01       	movw	r24, r20
    2a72:	a0 01       	movw	r20, r0
    2a74:	11 24       	eor	r1, r1
    2a76:	ff 27       	eor	r31, r31
    2a78:	59 1b       	sub	r21, r25
    2a7a:	99 f0       	breq	.+38     	; 0x2aa2 <__addsf3x+0x5c>
    2a7c:	59 3f       	cpi	r21, 0xF9	; 249
    2a7e:	50 f4       	brcc	.+20     	; 0x2a94 <__addsf3x+0x4e>
    2a80:	50 3e       	cpi	r21, 0xE0	; 224
    2a82:	68 f1       	brcs	.+90     	; 0x2ade <__addsf3x+0x98>
    2a84:	1a 16       	cp	r1, r26
    2a86:	f0 40       	sbci	r31, 0x00	; 0
    2a88:	a2 2f       	mov	r26, r18
    2a8a:	23 2f       	mov	r18, r19
    2a8c:	34 2f       	mov	r19, r20
    2a8e:	44 27       	eor	r20, r20
    2a90:	58 5f       	subi	r21, 0xF8	; 248
    2a92:	f3 cf       	rjmp	.-26     	; 0x2a7a <__addsf3x+0x34>
    2a94:	46 95       	lsr	r20
    2a96:	37 95       	ror	r19
    2a98:	27 95       	ror	r18
    2a9a:	a7 95       	ror	r26
    2a9c:	f0 40       	sbci	r31, 0x00	; 0
    2a9e:	53 95       	inc	r21
    2aa0:	c9 f7       	brne	.-14     	; 0x2a94 <__addsf3x+0x4e>
    2aa2:	7e f4       	brtc	.+30     	; 0x2ac2 <__addsf3x+0x7c>
    2aa4:	1f 16       	cp	r1, r31
    2aa6:	ba 0b       	sbc	r27, r26
    2aa8:	62 0b       	sbc	r22, r18
    2aaa:	73 0b       	sbc	r23, r19
    2aac:	84 0b       	sbc	r24, r20
    2aae:	ba f0       	brmi	.+46     	; 0x2ade <__addsf3x+0x98>
    2ab0:	91 50       	subi	r25, 0x01	; 1
    2ab2:	a1 f0       	breq	.+40     	; 0x2adc <__addsf3x+0x96>
    2ab4:	ff 0f       	add	r31, r31
    2ab6:	bb 1f       	adc	r27, r27
    2ab8:	66 1f       	adc	r22, r22
    2aba:	77 1f       	adc	r23, r23
    2abc:	88 1f       	adc	r24, r24
    2abe:	c2 f7       	brpl	.-16     	; 0x2ab0 <__addsf3x+0x6a>
    2ac0:	0e c0       	rjmp	.+28     	; 0x2ade <__addsf3x+0x98>
    2ac2:	ba 0f       	add	r27, r26
    2ac4:	62 1f       	adc	r22, r18
    2ac6:	73 1f       	adc	r23, r19
    2ac8:	84 1f       	adc	r24, r20
    2aca:	48 f4       	brcc	.+18     	; 0x2ade <__addsf3x+0x98>
    2acc:	87 95       	ror	r24
    2ace:	77 95       	ror	r23
    2ad0:	67 95       	ror	r22
    2ad2:	b7 95       	ror	r27
    2ad4:	f7 95       	ror	r31
    2ad6:	9e 3f       	cpi	r25, 0xFE	; 254
    2ad8:	08 f0       	brcs	.+2      	; 0x2adc <__addsf3x+0x96>
    2ada:	b3 cf       	rjmp	.-154    	; 0x2a42 <__addsf3+0x1e>
    2adc:	93 95       	inc	r25
    2ade:	88 0f       	add	r24, r24
    2ae0:	08 f0       	brcs	.+2      	; 0x2ae4 <__addsf3x+0x9e>
    2ae2:	99 27       	eor	r25, r25
    2ae4:	ee 0f       	add	r30, r30
    2ae6:	97 95       	ror	r25
    2ae8:	87 95       	ror	r24
    2aea:	08 95       	ret

00002aec <__divsf3>:
    2aec:	0c d0       	rcall	.+24     	; 0x2b06 <__divsf3x>
    2aee:	eb c0       	rjmp	.+470    	; 0x2cc6 <__fp_round>
    2af0:	e3 d0       	rcall	.+454    	; 0x2cb8 <__fp_pscB>
    2af2:	40 f0       	brcs	.+16     	; 0x2b04 <__divsf3+0x18>
    2af4:	da d0       	rcall	.+436    	; 0x2caa <__fp_pscA>
    2af6:	30 f0       	brcs	.+12     	; 0x2b04 <__divsf3+0x18>
    2af8:	21 f4       	brne	.+8      	; 0x2b02 <__divsf3+0x16>
    2afa:	5f 3f       	cpi	r21, 0xFF	; 255
    2afc:	19 f0       	breq	.+6      	; 0x2b04 <__divsf3+0x18>
    2afe:	cc c0       	rjmp	.+408    	; 0x2c98 <__fp_inf>
    2b00:	51 11       	cpse	r21, r1
    2b02:	15 c1       	rjmp	.+554    	; 0x2d2e <__fp_szero>
    2b04:	cf c0       	rjmp	.+414    	; 0x2ca4 <__fp_nan>

00002b06 <__divsf3x>:
    2b06:	f0 d0       	rcall	.+480    	; 0x2ce8 <__fp_split3>
    2b08:	98 f3       	brcs	.-26     	; 0x2af0 <__divsf3+0x4>

00002b0a <__divsf3_pse>:
    2b0a:	99 23       	and	r25, r25
    2b0c:	c9 f3       	breq	.-14     	; 0x2b00 <__divsf3+0x14>
    2b0e:	55 23       	and	r21, r21
    2b10:	b1 f3       	breq	.-20     	; 0x2afe <__divsf3+0x12>
    2b12:	95 1b       	sub	r25, r21
    2b14:	55 0b       	sbc	r21, r21
    2b16:	bb 27       	eor	r27, r27
    2b18:	aa 27       	eor	r26, r26
    2b1a:	62 17       	cp	r22, r18
    2b1c:	73 07       	cpc	r23, r19
    2b1e:	84 07       	cpc	r24, r20
    2b20:	38 f0       	brcs	.+14     	; 0x2b30 <__divsf3_pse+0x26>
    2b22:	9f 5f       	subi	r25, 0xFF	; 255
    2b24:	5f 4f       	sbci	r21, 0xFF	; 255
    2b26:	22 0f       	add	r18, r18
    2b28:	33 1f       	adc	r19, r19
    2b2a:	44 1f       	adc	r20, r20
    2b2c:	aa 1f       	adc	r26, r26
    2b2e:	a9 f3       	breq	.-22     	; 0x2b1a <__divsf3_pse+0x10>
    2b30:	33 d0       	rcall	.+102    	; 0x2b98 <__divsf3_pse+0x8e>
    2b32:	0e 2e       	mov	r0, r30
    2b34:	3a f0       	brmi	.+14     	; 0x2b44 <__divsf3_pse+0x3a>
    2b36:	e0 e8       	ldi	r30, 0x80	; 128
    2b38:	30 d0       	rcall	.+96     	; 0x2b9a <__divsf3_pse+0x90>
    2b3a:	91 50       	subi	r25, 0x01	; 1
    2b3c:	50 40       	sbci	r21, 0x00	; 0
    2b3e:	e6 95       	lsr	r30
    2b40:	00 1c       	adc	r0, r0
    2b42:	ca f7       	brpl	.-14     	; 0x2b36 <__divsf3_pse+0x2c>
    2b44:	29 d0       	rcall	.+82     	; 0x2b98 <__divsf3_pse+0x8e>
    2b46:	fe 2f       	mov	r31, r30
    2b48:	27 d0       	rcall	.+78     	; 0x2b98 <__divsf3_pse+0x8e>
    2b4a:	66 0f       	add	r22, r22
    2b4c:	77 1f       	adc	r23, r23
    2b4e:	88 1f       	adc	r24, r24
    2b50:	bb 1f       	adc	r27, r27
    2b52:	26 17       	cp	r18, r22
    2b54:	37 07       	cpc	r19, r23
    2b56:	48 07       	cpc	r20, r24
    2b58:	ab 07       	cpc	r26, r27
    2b5a:	b0 e8       	ldi	r27, 0x80	; 128
    2b5c:	09 f0       	breq	.+2      	; 0x2b60 <__divsf3_pse+0x56>
    2b5e:	bb 0b       	sbc	r27, r27
    2b60:	80 2d       	mov	r24, r0
    2b62:	bf 01       	movw	r22, r30
    2b64:	ff 27       	eor	r31, r31
    2b66:	93 58       	subi	r25, 0x83	; 131
    2b68:	5f 4f       	sbci	r21, 0xFF	; 255
    2b6a:	2a f0       	brmi	.+10     	; 0x2b76 <__divsf3_pse+0x6c>
    2b6c:	9e 3f       	cpi	r25, 0xFE	; 254
    2b6e:	51 05       	cpc	r21, r1
    2b70:	68 f0       	brcs	.+26     	; 0x2b8c <__divsf3_pse+0x82>
    2b72:	92 c0       	rjmp	.+292    	; 0x2c98 <__fp_inf>
    2b74:	dc c0       	rjmp	.+440    	; 0x2d2e <__fp_szero>
    2b76:	5f 3f       	cpi	r21, 0xFF	; 255
    2b78:	ec f3       	brlt	.-6      	; 0x2b74 <__divsf3_pse+0x6a>
    2b7a:	98 3e       	cpi	r25, 0xE8	; 232
    2b7c:	dc f3       	brlt	.-10     	; 0x2b74 <__divsf3_pse+0x6a>
    2b7e:	86 95       	lsr	r24
    2b80:	77 95       	ror	r23
    2b82:	67 95       	ror	r22
    2b84:	b7 95       	ror	r27
    2b86:	f7 95       	ror	r31
    2b88:	9f 5f       	subi	r25, 0xFF	; 255
    2b8a:	c9 f7       	brne	.-14     	; 0x2b7e <__divsf3_pse+0x74>
    2b8c:	88 0f       	add	r24, r24
    2b8e:	91 1d       	adc	r25, r1
    2b90:	96 95       	lsr	r25
    2b92:	87 95       	ror	r24
    2b94:	97 f9       	bld	r25, 7
    2b96:	08 95       	ret
    2b98:	e1 e0       	ldi	r30, 0x01	; 1
    2b9a:	66 0f       	add	r22, r22
    2b9c:	77 1f       	adc	r23, r23
    2b9e:	88 1f       	adc	r24, r24
    2ba0:	bb 1f       	adc	r27, r27
    2ba2:	62 17       	cp	r22, r18
    2ba4:	73 07       	cpc	r23, r19
    2ba6:	84 07       	cpc	r24, r20
    2ba8:	ba 07       	cpc	r27, r26
    2baa:	20 f0       	brcs	.+8      	; 0x2bb4 <__divsf3_pse+0xaa>
    2bac:	62 1b       	sub	r22, r18
    2bae:	73 0b       	sbc	r23, r19
    2bb0:	84 0b       	sbc	r24, r20
    2bb2:	ba 0b       	sbc	r27, r26
    2bb4:	ee 1f       	adc	r30, r30
    2bb6:	88 f7       	brcc	.-30     	; 0x2b9a <__divsf3_pse+0x90>
    2bb8:	e0 95       	com	r30
    2bba:	08 95       	ret

00002bbc <__fixsfsi>:
    2bbc:	04 d0       	rcall	.+8      	; 0x2bc6 <__fixunssfsi>
    2bbe:	68 94       	set
    2bc0:	b1 11       	cpse	r27, r1
    2bc2:	b5 c0       	rjmp	.+362    	; 0x2d2e <__fp_szero>
    2bc4:	08 95       	ret

00002bc6 <__fixunssfsi>:
    2bc6:	98 d0       	rcall	.+304    	; 0x2cf8 <__fp_splitA>
    2bc8:	88 f0       	brcs	.+34     	; 0x2bec <__fixunssfsi+0x26>
    2bca:	9f 57       	subi	r25, 0x7F	; 127
    2bcc:	90 f0       	brcs	.+36     	; 0x2bf2 <__fixunssfsi+0x2c>
    2bce:	b9 2f       	mov	r27, r25
    2bd0:	99 27       	eor	r25, r25
    2bd2:	b7 51       	subi	r27, 0x17	; 23
    2bd4:	a0 f0       	brcs	.+40     	; 0x2bfe <__fixunssfsi+0x38>
    2bd6:	d1 f0       	breq	.+52     	; 0x2c0c <__fixunssfsi+0x46>
    2bd8:	66 0f       	add	r22, r22
    2bda:	77 1f       	adc	r23, r23
    2bdc:	88 1f       	adc	r24, r24
    2bde:	99 1f       	adc	r25, r25
    2be0:	1a f0       	brmi	.+6      	; 0x2be8 <__fixunssfsi+0x22>
    2be2:	ba 95       	dec	r27
    2be4:	c9 f7       	brne	.-14     	; 0x2bd8 <__fixunssfsi+0x12>
    2be6:	12 c0       	rjmp	.+36     	; 0x2c0c <__fixunssfsi+0x46>
    2be8:	b1 30       	cpi	r27, 0x01	; 1
    2bea:	81 f0       	breq	.+32     	; 0x2c0c <__fixunssfsi+0x46>
    2bec:	9f d0       	rcall	.+318    	; 0x2d2c <__fp_zero>
    2bee:	b1 e0       	ldi	r27, 0x01	; 1
    2bf0:	08 95       	ret
    2bf2:	9c c0       	rjmp	.+312    	; 0x2d2c <__fp_zero>
    2bf4:	67 2f       	mov	r22, r23
    2bf6:	78 2f       	mov	r23, r24
    2bf8:	88 27       	eor	r24, r24
    2bfa:	b8 5f       	subi	r27, 0xF8	; 248
    2bfc:	39 f0       	breq	.+14     	; 0x2c0c <__fixunssfsi+0x46>
    2bfe:	b9 3f       	cpi	r27, 0xF9	; 249
    2c00:	cc f3       	brlt	.-14     	; 0x2bf4 <__fixunssfsi+0x2e>
    2c02:	86 95       	lsr	r24
    2c04:	77 95       	ror	r23
    2c06:	67 95       	ror	r22
    2c08:	b3 95       	inc	r27
    2c0a:	d9 f7       	brne	.-10     	; 0x2c02 <__fixunssfsi+0x3c>
    2c0c:	3e f4       	brtc	.+14     	; 0x2c1c <__fixunssfsi+0x56>
    2c0e:	90 95       	com	r25
    2c10:	80 95       	com	r24
    2c12:	70 95       	com	r23
    2c14:	61 95       	neg	r22
    2c16:	7f 4f       	sbci	r23, 0xFF	; 255
    2c18:	8f 4f       	sbci	r24, 0xFF	; 255
    2c1a:	9f 4f       	sbci	r25, 0xFF	; 255
    2c1c:	08 95       	ret

00002c1e <__floatunsisf>:
    2c1e:	e8 94       	clt
    2c20:	09 c0       	rjmp	.+18     	; 0x2c34 <__floatsisf+0x12>

00002c22 <__floatsisf>:
    2c22:	97 fb       	bst	r25, 7
    2c24:	3e f4       	brtc	.+14     	; 0x2c34 <__floatsisf+0x12>
    2c26:	90 95       	com	r25
    2c28:	80 95       	com	r24
    2c2a:	70 95       	com	r23
    2c2c:	61 95       	neg	r22
    2c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c30:	8f 4f       	sbci	r24, 0xFF	; 255
    2c32:	9f 4f       	sbci	r25, 0xFF	; 255
    2c34:	99 23       	and	r25, r25
    2c36:	a9 f0       	breq	.+42     	; 0x2c62 <__floatsisf+0x40>
    2c38:	f9 2f       	mov	r31, r25
    2c3a:	96 e9       	ldi	r25, 0x96	; 150
    2c3c:	bb 27       	eor	r27, r27
    2c3e:	93 95       	inc	r25
    2c40:	f6 95       	lsr	r31
    2c42:	87 95       	ror	r24
    2c44:	77 95       	ror	r23
    2c46:	67 95       	ror	r22
    2c48:	b7 95       	ror	r27
    2c4a:	f1 11       	cpse	r31, r1
    2c4c:	f8 cf       	rjmp	.-16     	; 0x2c3e <__floatsisf+0x1c>
    2c4e:	fa f4       	brpl	.+62     	; 0x2c8e <__floatsisf+0x6c>
    2c50:	bb 0f       	add	r27, r27
    2c52:	11 f4       	brne	.+4      	; 0x2c58 <__floatsisf+0x36>
    2c54:	60 ff       	sbrs	r22, 0
    2c56:	1b c0       	rjmp	.+54     	; 0x2c8e <__floatsisf+0x6c>
    2c58:	6f 5f       	subi	r22, 0xFF	; 255
    2c5a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c5c:	8f 4f       	sbci	r24, 0xFF	; 255
    2c5e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c60:	16 c0       	rjmp	.+44     	; 0x2c8e <__floatsisf+0x6c>
    2c62:	88 23       	and	r24, r24
    2c64:	11 f0       	breq	.+4      	; 0x2c6a <__floatsisf+0x48>
    2c66:	96 e9       	ldi	r25, 0x96	; 150
    2c68:	11 c0       	rjmp	.+34     	; 0x2c8c <__floatsisf+0x6a>
    2c6a:	77 23       	and	r23, r23
    2c6c:	21 f0       	breq	.+8      	; 0x2c76 <__floatsisf+0x54>
    2c6e:	9e e8       	ldi	r25, 0x8E	; 142
    2c70:	87 2f       	mov	r24, r23
    2c72:	76 2f       	mov	r23, r22
    2c74:	05 c0       	rjmp	.+10     	; 0x2c80 <__floatsisf+0x5e>
    2c76:	66 23       	and	r22, r22
    2c78:	71 f0       	breq	.+28     	; 0x2c96 <__floatsisf+0x74>
    2c7a:	96 e8       	ldi	r25, 0x86	; 134
    2c7c:	86 2f       	mov	r24, r22
    2c7e:	70 e0       	ldi	r23, 0x00	; 0
    2c80:	60 e0       	ldi	r22, 0x00	; 0
    2c82:	2a f0       	brmi	.+10     	; 0x2c8e <__floatsisf+0x6c>
    2c84:	9a 95       	dec	r25
    2c86:	66 0f       	add	r22, r22
    2c88:	77 1f       	adc	r23, r23
    2c8a:	88 1f       	adc	r24, r24
    2c8c:	da f7       	brpl	.-10     	; 0x2c84 <__floatsisf+0x62>
    2c8e:	88 0f       	add	r24, r24
    2c90:	96 95       	lsr	r25
    2c92:	87 95       	ror	r24
    2c94:	97 f9       	bld	r25, 7
    2c96:	08 95       	ret

00002c98 <__fp_inf>:
    2c98:	97 f9       	bld	r25, 7
    2c9a:	9f 67       	ori	r25, 0x7F	; 127
    2c9c:	80 e8       	ldi	r24, 0x80	; 128
    2c9e:	70 e0       	ldi	r23, 0x00	; 0
    2ca0:	60 e0       	ldi	r22, 0x00	; 0
    2ca2:	08 95       	ret

00002ca4 <__fp_nan>:
    2ca4:	9f ef       	ldi	r25, 0xFF	; 255
    2ca6:	80 ec       	ldi	r24, 0xC0	; 192
    2ca8:	08 95       	ret

00002caa <__fp_pscA>:
    2caa:	00 24       	eor	r0, r0
    2cac:	0a 94       	dec	r0
    2cae:	16 16       	cp	r1, r22
    2cb0:	17 06       	cpc	r1, r23
    2cb2:	18 06       	cpc	r1, r24
    2cb4:	09 06       	cpc	r0, r25
    2cb6:	08 95       	ret

00002cb8 <__fp_pscB>:
    2cb8:	00 24       	eor	r0, r0
    2cba:	0a 94       	dec	r0
    2cbc:	12 16       	cp	r1, r18
    2cbe:	13 06       	cpc	r1, r19
    2cc0:	14 06       	cpc	r1, r20
    2cc2:	05 06       	cpc	r0, r21
    2cc4:	08 95       	ret

00002cc6 <__fp_round>:
    2cc6:	09 2e       	mov	r0, r25
    2cc8:	03 94       	inc	r0
    2cca:	00 0c       	add	r0, r0
    2ccc:	11 f4       	brne	.+4      	; 0x2cd2 <__fp_round+0xc>
    2cce:	88 23       	and	r24, r24
    2cd0:	52 f0       	brmi	.+20     	; 0x2ce6 <__fp_round+0x20>
    2cd2:	bb 0f       	add	r27, r27
    2cd4:	40 f4       	brcc	.+16     	; 0x2ce6 <__fp_round+0x20>
    2cd6:	bf 2b       	or	r27, r31
    2cd8:	11 f4       	brne	.+4      	; 0x2cde <__fp_round+0x18>
    2cda:	60 ff       	sbrs	r22, 0
    2cdc:	04 c0       	rjmp	.+8      	; 0x2ce6 <__fp_round+0x20>
    2cde:	6f 5f       	subi	r22, 0xFF	; 255
    2ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce2:	8f 4f       	sbci	r24, 0xFF	; 255
    2ce4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ce6:	08 95       	ret

00002ce8 <__fp_split3>:
    2ce8:	57 fd       	sbrc	r21, 7
    2cea:	90 58       	subi	r25, 0x80	; 128
    2cec:	44 0f       	add	r20, r20
    2cee:	55 1f       	adc	r21, r21
    2cf0:	59 f0       	breq	.+22     	; 0x2d08 <__fp_splitA+0x10>
    2cf2:	5f 3f       	cpi	r21, 0xFF	; 255
    2cf4:	71 f0       	breq	.+28     	; 0x2d12 <__fp_splitA+0x1a>
    2cf6:	47 95       	ror	r20

00002cf8 <__fp_splitA>:
    2cf8:	88 0f       	add	r24, r24
    2cfa:	97 fb       	bst	r25, 7
    2cfc:	99 1f       	adc	r25, r25
    2cfe:	61 f0       	breq	.+24     	; 0x2d18 <__fp_splitA+0x20>
    2d00:	9f 3f       	cpi	r25, 0xFF	; 255
    2d02:	79 f0       	breq	.+30     	; 0x2d22 <__fp_splitA+0x2a>
    2d04:	87 95       	ror	r24
    2d06:	08 95       	ret
    2d08:	12 16       	cp	r1, r18
    2d0a:	13 06       	cpc	r1, r19
    2d0c:	14 06       	cpc	r1, r20
    2d0e:	55 1f       	adc	r21, r21
    2d10:	f2 cf       	rjmp	.-28     	; 0x2cf6 <__fp_split3+0xe>
    2d12:	46 95       	lsr	r20
    2d14:	f1 df       	rcall	.-30     	; 0x2cf8 <__fp_splitA>
    2d16:	08 c0       	rjmp	.+16     	; 0x2d28 <__fp_splitA+0x30>
    2d18:	16 16       	cp	r1, r22
    2d1a:	17 06       	cpc	r1, r23
    2d1c:	18 06       	cpc	r1, r24
    2d1e:	99 1f       	adc	r25, r25
    2d20:	f1 cf       	rjmp	.-30     	; 0x2d04 <__fp_splitA+0xc>
    2d22:	86 95       	lsr	r24
    2d24:	71 05       	cpc	r23, r1
    2d26:	61 05       	cpc	r22, r1
    2d28:	08 94       	sec
    2d2a:	08 95       	ret

00002d2c <__fp_zero>:
    2d2c:	e8 94       	clt

00002d2e <__fp_szero>:
    2d2e:	bb 27       	eor	r27, r27
    2d30:	66 27       	eor	r22, r22
    2d32:	77 27       	eor	r23, r23
    2d34:	cb 01       	movw	r24, r22
    2d36:	97 f9       	bld	r25, 7
    2d38:	08 95       	ret

00002d3a <__mulsf3>:
    2d3a:	0b d0       	rcall	.+22     	; 0x2d52 <__mulsf3x>
    2d3c:	c4 cf       	rjmp	.-120    	; 0x2cc6 <__fp_round>
    2d3e:	b5 df       	rcall	.-150    	; 0x2caa <__fp_pscA>
    2d40:	28 f0       	brcs	.+10     	; 0x2d4c <__mulsf3+0x12>
    2d42:	ba df       	rcall	.-140    	; 0x2cb8 <__fp_pscB>
    2d44:	18 f0       	brcs	.+6      	; 0x2d4c <__mulsf3+0x12>
    2d46:	95 23       	and	r25, r21
    2d48:	09 f0       	breq	.+2      	; 0x2d4c <__mulsf3+0x12>
    2d4a:	a6 cf       	rjmp	.-180    	; 0x2c98 <__fp_inf>
    2d4c:	ab cf       	rjmp	.-170    	; 0x2ca4 <__fp_nan>
    2d4e:	11 24       	eor	r1, r1
    2d50:	ee cf       	rjmp	.-36     	; 0x2d2e <__fp_szero>

00002d52 <__mulsf3x>:
    2d52:	ca df       	rcall	.-108    	; 0x2ce8 <__fp_split3>
    2d54:	a0 f3       	brcs	.-24     	; 0x2d3e <__mulsf3+0x4>

00002d56 <__mulsf3_pse>:
    2d56:	95 9f       	mul	r25, r21
    2d58:	d1 f3       	breq	.-12     	; 0x2d4e <__mulsf3+0x14>
    2d5a:	95 0f       	add	r25, r21
    2d5c:	50 e0       	ldi	r21, 0x00	; 0
    2d5e:	55 1f       	adc	r21, r21
    2d60:	62 9f       	mul	r22, r18
    2d62:	f0 01       	movw	r30, r0
    2d64:	72 9f       	mul	r23, r18
    2d66:	bb 27       	eor	r27, r27
    2d68:	f0 0d       	add	r31, r0
    2d6a:	b1 1d       	adc	r27, r1
    2d6c:	63 9f       	mul	r22, r19
    2d6e:	aa 27       	eor	r26, r26
    2d70:	f0 0d       	add	r31, r0
    2d72:	b1 1d       	adc	r27, r1
    2d74:	aa 1f       	adc	r26, r26
    2d76:	64 9f       	mul	r22, r20
    2d78:	66 27       	eor	r22, r22
    2d7a:	b0 0d       	add	r27, r0
    2d7c:	a1 1d       	adc	r26, r1
    2d7e:	66 1f       	adc	r22, r22
    2d80:	82 9f       	mul	r24, r18
    2d82:	22 27       	eor	r18, r18
    2d84:	b0 0d       	add	r27, r0
    2d86:	a1 1d       	adc	r26, r1
    2d88:	62 1f       	adc	r22, r18
    2d8a:	73 9f       	mul	r23, r19
    2d8c:	b0 0d       	add	r27, r0
    2d8e:	a1 1d       	adc	r26, r1
    2d90:	62 1f       	adc	r22, r18
    2d92:	83 9f       	mul	r24, r19
    2d94:	a0 0d       	add	r26, r0
    2d96:	61 1d       	adc	r22, r1
    2d98:	22 1f       	adc	r18, r18
    2d9a:	74 9f       	mul	r23, r20
    2d9c:	33 27       	eor	r19, r19
    2d9e:	a0 0d       	add	r26, r0
    2da0:	61 1d       	adc	r22, r1
    2da2:	23 1f       	adc	r18, r19
    2da4:	84 9f       	mul	r24, r20
    2da6:	60 0d       	add	r22, r0
    2da8:	21 1d       	adc	r18, r1
    2daa:	82 2f       	mov	r24, r18
    2dac:	76 2f       	mov	r23, r22
    2dae:	6a 2f       	mov	r22, r26
    2db0:	11 24       	eor	r1, r1
    2db2:	9f 57       	subi	r25, 0x7F	; 127
    2db4:	50 40       	sbci	r21, 0x00	; 0
    2db6:	8a f0       	brmi	.+34     	; 0x2dda <__mulsf3_pse+0x84>
    2db8:	e1 f0       	breq	.+56     	; 0x2df2 <__mulsf3_pse+0x9c>
    2dba:	88 23       	and	r24, r24
    2dbc:	4a f0       	brmi	.+18     	; 0x2dd0 <__mulsf3_pse+0x7a>
    2dbe:	ee 0f       	add	r30, r30
    2dc0:	ff 1f       	adc	r31, r31
    2dc2:	bb 1f       	adc	r27, r27
    2dc4:	66 1f       	adc	r22, r22
    2dc6:	77 1f       	adc	r23, r23
    2dc8:	88 1f       	adc	r24, r24
    2dca:	91 50       	subi	r25, 0x01	; 1
    2dcc:	50 40       	sbci	r21, 0x00	; 0
    2dce:	a9 f7       	brne	.-22     	; 0x2dba <__mulsf3_pse+0x64>
    2dd0:	9e 3f       	cpi	r25, 0xFE	; 254
    2dd2:	51 05       	cpc	r21, r1
    2dd4:	70 f0       	brcs	.+28     	; 0x2df2 <__mulsf3_pse+0x9c>
    2dd6:	60 cf       	rjmp	.-320    	; 0x2c98 <__fp_inf>
    2dd8:	aa cf       	rjmp	.-172    	; 0x2d2e <__fp_szero>
    2dda:	5f 3f       	cpi	r21, 0xFF	; 255
    2ddc:	ec f3       	brlt	.-6      	; 0x2dd8 <__mulsf3_pse+0x82>
    2dde:	98 3e       	cpi	r25, 0xE8	; 232
    2de0:	dc f3       	brlt	.-10     	; 0x2dd8 <__mulsf3_pse+0x82>
    2de2:	86 95       	lsr	r24
    2de4:	77 95       	ror	r23
    2de6:	67 95       	ror	r22
    2de8:	b7 95       	ror	r27
    2dea:	f7 95       	ror	r31
    2dec:	e7 95       	ror	r30
    2dee:	9f 5f       	subi	r25, 0xFF	; 255
    2df0:	c1 f7       	brne	.-16     	; 0x2de2 <__mulsf3_pse+0x8c>
    2df2:	fe 2b       	or	r31, r30
    2df4:	88 0f       	add	r24, r24
    2df6:	91 1d       	adc	r25, r1
    2df8:	96 95       	lsr	r25
    2dfa:	87 95       	ror	r24
    2dfc:	97 f9       	bld	r25, 7
    2dfe:	08 95       	ret

00002e00 <pow>:
    2e00:	fa 01       	movw	r30, r20
    2e02:	ee 0f       	add	r30, r30
    2e04:	ff 1f       	adc	r31, r31
    2e06:	30 96       	adiw	r30, 0x00	; 0
    2e08:	21 05       	cpc	r18, r1
    2e0a:	31 05       	cpc	r19, r1
    2e0c:	99 f1       	breq	.+102    	; 0x2e74 <pow+0x74>
    2e0e:	61 15       	cp	r22, r1
    2e10:	71 05       	cpc	r23, r1
    2e12:	61 f4       	brne	.+24     	; 0x2e2c <pow+0x2c>
    2e14:	80 38       	cpi	r24, 0x80	; 128
    2e16:	bf e3       	ldi	r27, 0x3F	; 63
    2e18:	9b 07       	cpc	r25, r27
    2e1a:	49 f1       	breq	.+82     	; 0x2e6e <pow+0x6e>
    2e1c:	68 94       	set
    2e1e:	90 38       	cpi	r25, 0x80	; 128
    2e20:	81 05       	cpc	r24, r1
    2e22:	61 f0       	breq	.+24     	; 0x2e3c <pow+0x3c>
    2e24:	80 38       	cpi	r24, 0x80	; 128
    2e26:	bf ef       	ldi	r27, 0xFF	; 255
    2e28:	9b 07       	cpc	r25, r27
    2e2a:	41 f0       	breq	.+16     	; 0x2e3c <pow+0x3c>
    2e2c:	99 23       	and	r25, r25
    2e2e:	42 f5       	brpl	.+80     	; 0x2e80 <pow+0x80>
    2e30:	ff 3f       	cpi	r31, 0xFF	; 255
    2e32:	e1 05       	cpc	r30, r1
    2e34:	31 05       	cpc	r19, r1
    2e36:	21 05       	cpc	r18, r1
    2e38:	11 f1       	breq	.+68     	; 0x2e7e <pow+0x7e>
    2e3a:	e8 94       	clt
    2e3c:	08 94       	sec
    2e3e:	e7 95       	ror	r30
    2e40:	d9 01       	movw	r26, r18
    2e42:	aa 23       	and	r26, r26
    2e44:	29 f4       	brne	.+10     	; 0x2e50 <pow+0x50>
    2e46:	ab 2f       	mov	r26, r27
    2e48:	be 2f       	mov	r27, r30
    2e4a:	f8 5f       	subi	r31, 0xF8	; 248
    2e4c:	d0 f3       	brcs	.-12     	; 0x2e42 <pow+0x42>
    2e4e:	10 c0       	rjmp	.+32     	; 0x2e70 <pow+0x70>
    2e50:	ff 5f       	subi	r31, 0xFF	; 255
    2e52:	70 f4       	brcc	.+28     	; 0x2e70 <pow+0x70>
    2e54:	a6 95       	lsr	r26
    2e56:	e0 f7       	brcc	.-8      	; 0x2e50 <pow+0x50>
    2e58:	f7 39       	cpi	r31, 0x97	; 151
    2e5a:	50 f0       	brcs	.+20     	; 0x2e70 <pow+0x70>
    2e5c:	19 f0       	breq	.+6      	; 0x2e64 <pow+0x64>
    2e5e:	ff 3a       	cpi	r31, 0xAF	; 175
    2e60:	38 f4       	brcc	.+14     	; 0x2e70 <pow+0x70>
    2e62:	9f 77       	andi	r25, 0x7F	; 127
    2e64:	9f 93       	push	r25
    2e66:	0c d0       	rcall	.+24     	; 0x2e80 <pow+0x80>
    2e68:	0f 90       	pop	r0
    2e6a:	07 fc       	sbrc	r0, 7
    2e6c:	90 58       	subi	r25, 0x80	; 128
    2e6e:	08 95       	ret
    2e70:	3e f0       	brts	.+14     	; 0x2e80 <pow+0x80>
    2e72:	18 cf       	rjmp	.-464    	; 0x2ca4 <__fp_nan>
    2e74:	60 e0       	ldi	r22, 0x00	; 0
    2e76:	70 e0       	ldi	r23, 0x00	; 0
    2e78:	80 e8       	ldi	r24, 0x80	; 128
    2e7a:	9f e3       	ldi	r25, 0x3F	; 63
    2e7c:	08 95       	ret
    2e7e:	4f e7       	ldi	r20, 0x7F	; 127
    2e80:	9f 77       	andi	r25, 0x7F	; 127
    2e82:	5f 93       	push	r21
    2e84:	4f 93       	push	r20
    2e86:	3f 93       	push	r19
    2e88:	2f 93       	push	r18
    2e8a:	9e d0       	rcall	.+316    	; 0x2fc8 <log>
    2e8c:	2f 91       	pop	r18
    2e8e:	3f 91       	pop	r19
    2e90:	4f 91       	pop	r20
    2e92:	5f 91       	pop	r21
    2e94:	52 df       	rcall	.-348    	; 0x2d3a <__mulsf3>
    2e96:	05 c0       	rjmp	.+10     	; 0x2ea2 <exp>
    2e98:	19 f4       	brne	.+6      	; 0x2ea0 <pow+0xa0>
    2e9a:	0e f0       	brts	.+2      	; 0x2e9e <pow+0x9e>
    2e9c:	fd ce       	rjmp	.-518    	; 0x2c98 <__fp_inf>
    2e9e:	46 cf       	rjmp	.-372    	; 0x2d2c <__fp_zero>
    2ea0:	01 cf       	rjmp	.-510    	; 0x2ca4 <__fp_nan>

00002ea2 <exp>:
    2ea2:	2a df       	rcall	.-428    	; 0x2cf8 <__fp_splitA>
    2ea4:	c8 f3       	brcs	.-14     	; 0x2e98 <pow+0x98>
    2ea6:	96 38       	cpi	r25, 0x86	; 134
    2ea8:	c0 f7       	brcc	.-16     	; 0x2e9a <pow+0x9a>
    2eaa:	07 f8       	bld	r0, 7
    2eac:	0f 92       	push	r0
    2eae:	e8 94       	clt
    2eb0:	2b e3       	ldi	r18, 0x3B	; 59
    2eb2:	3a ea       	ldi	r19, 0xAA	; 170
    2eb4:	48 eb       	ldi	r20, 0xB8	; 184
    2eb6:	5f e7       	ldi	r21, 0x7F	; 127
    2eb8:	4e df       	rcall	.-356    	; 0x2d56 <__mulsf3_pse>
    2eba:	0f 92       	push	r0
    2ebc:	0f 92       	push	r0
    2ebe:	0f 92       	push	r0
    2ec0:	4d b7       	in	r20, 0x3d	; 61
    2ec2:	5e b7       	in	r21, 0x3e	; 62
    2ec4:	0f 92       	push	r0
    2ec6:	c0 d0       	rcall	.+384    	; 0x3048 <modf>
    2ec8:	e4 ee       	ldi	r30, 0xE4	; 228
    2eca:	f0 e0       	ldi	r31, 0x00	; 0
    2ecc:	16 d0       	rcall	.+44     	; 0x2efa <__fp_powser>
    2ece:	4f 91       	pop	r20
    2ed0:	5f 91       	pop	r21
    2ed2:	ef 91       	pop	r30
    2ed4:	ff 91       	pop	r31
    2ed6:	e5 95       	asr	r30
    2ed8:	ee 1f       	adc	r30, r30
    2eda:	ff 1f       	adc	r31, r31
    2edc:	49 f0       	breq	.+18     	; 0x2ef0 <exp+0x4e>
    2ede:	fe 57       	subi	r31, 0x7E	; 126
    2ee0:	e0 68       	ori	r30, 0x80	; 128
    2ee2:	44 27       	eor	r20, r20
    2ee4:	ee 0f       	add	r30, r30
    2ee6:	44 1f       	adc	r20, r20
    2ee8:	fa 95       	dec	r31
    2eea:	e1 f7       	brne	.-8      	; 0x2ee4 <exp+0x42>
    2eec:	41 95       	neg	r20
    2eee:	55 0b       	sbc	r21, r21
    2ef0:	32 d0       	rcall	.+100    	; 0x2f56 <ldexp>
    2ef2:	0f 90       	pop	r0
    2ef4:	07 fe       	sbrs	r0, 7
    2ef6:	26 c0       	rjmp	.+76     	; 0x2f44 <inverse>
    2ef8:	08 95       	ret

00002efa <__fp_powser>:
    2efa:	df 93       	push	r29
    2efc:	cf 93       	push	r28
    2efe:	1f 93       	push	r17
    2f00:	0f 93       	push	r16
    2f02:	ff 92       	push	r15
    2f04:	ef 92       	push	r14
    2f06:	df 92       	push	r13
    2f08:	7b 01       	movw	r14, r22
    2f0a:	8c 01       	movw	r16, r24
    2f0c:	68 94       	set
    2f0e:	05 c0       	rjmp	.+10     	; 0x2f1a <__fp_powser+0x20>
    2f10:	da 2e       	mov	r13, r26
    2f12:	ef 01       	movw	r28, r30
    2f14:	1e df       	rcall	.-452    	; 0x2d52 <__mulsf3x>
    2f16:	fe 01       	movw	r30, r28
    2f18:	e8 94       	clt
    2f1a:	a5 91       	lpm	r26, Z+
    2f1c:	25 91       	lpm	r18, Z+
    2f1e:	35 91       	lpm	r19, Z+
    2f20:	45 91       	lpm	r20, Z+
    2f22:	55 91       	lpm	r21, Z+
    2f24:	ae f3       	brts	.-22     	; 0x2f10 <__fp_powser+0x16>
    2f26:	ef 01       	movw	r28, r30
    2f28:	8e dd       	rcall	.-1252   	; 0x2a46 <__addsf3x>
    2f2a:	fe 01       	movw	r30, r28
    2f2c:	97 01       	movw	r18, r14
    2f2e:	a8 01       	movw	r20, r16
    2f30:	da 94       	dec	r13
    2f32:	79 f7       	brne	.-34     	; 0x2f12 <__fp_powser+0x18>
    2f34:	df 90       	pop	r13
    2f36:	ef 90       	pop	r14
    2f38:	ff 90       	pop	r15
    2f3a:	0f 91       	pop	r16
    2f3c:	1f 91       	pop	r17
    2f3e:	cf 91       	pop	r28
    2f40:	df 91       	pop	r29
    2f42:	08 95       	ret

00002f44 <inverse>:
    2f44:	9b 01       	movw	r18, r22
    2f46:	ac 01       	movw	r20, r24
    2f48:	60 e0       	ldi	r22, 0x00	; 0
    2f4a:	70 e0       	ldi	r23, 0x00	; 0
    2f4c:	80 e8       	ldi	r24, 0x80	; 128
    2f4e:	9f e3       	ldi	r25, 0x3F	; 63
    2f50:	cd cd       	rjmp	.-1126   	; 0x2aec <__divsf3>
    2f52:	a2 ce       	rjmp	.-700    	; 0x2c98 <__fp_inf>
    2f54:	ac c0       	rjmp	.+344    	; 0x30ae <__fp_mpack>

00002f56 <ldexp>:
    2f56:	d0 de       	rcall	.-608    	; 0x2cf8 <__fp_splitA>
    2f58:	e8 f3       	brcs	.-6      	; 0x2f54 <inverse+0x10>
    2f5a:	99 23       	and	r25, r25
    2f5c:	d9 f3       	breq	.-10     	; 0x2f54 <inverse+0x10>
    2f5e:	94 0f       	add	r25, r20
    2f60:	51 1d       	adc	r21, r1
    2f62:	bb f3       	brvs	.-18     	; 0x2f52 <inverse+0xe>
    2f64:	91 50       	subi	r25, 0x01	; 1
    2f66:	50 40       	sbci	r21, 0x00	; 0
    2f68:	94 f0       	brlt	.+36     	; 0x2f8e <ldexp+0x38>
    2f6a:	59 f0       	breq	.+22     	; 0x2f82 <ldexp+0x2c>
    2f6c:	88 23       	and	r24, r24
    2f6e:	32 f0       	brmi	.+12     	; 0x2f7c <ldexp+0x26>
    2f70:	66 0f       	add	r22, r22
    2f72:	77 1f       	adc	r23, r23
    2f74:	88 1f       	adc	r24, r24
    2f76:	91 50       	subi	r25, 0x01	; 1
    2f78:	50 40       	sbci	r21, 0x00	; 0
    2f7a:	c1 f7       	brne	.-16     	; 0x2f6c <ldexp+0x16>
    2f7c:	9e 3f       	cpi	r25, 0xFE	; 254
    2f7e:	51 05       	cpc	r21, r1
    2f80:	44 f7       	brge	.-48     	; 0x2f52 <inverse+0xe>
    2f82:	88 0f       	add	r24, r24
    2f84:	91 1d       	adc	r25, r1
    2f86:	96 95       	lsr	r25
    2f88:	87 95       	ror	r24
    2f8a:	97 f9       	bld	r25, 7
    2f8c:	08 95       	ret
    2f8e:	5f 3f       	cpi	r21, 0xFF	; 255
    2f90:	ac f0       	brlt	.+42     	; 0x2fbc <ldexp+0x66>
    2f92:	98 3e       	cpi	r25, 0xE8	; 232
    2f94:	9c f0       	brlt	.+38     	; 0x2fbc <ldexp+0x66>
    2f96:	bb 27       	eor	r27, r27
    2f98:	86 95       	lsr	r24
    2f9a:	77 95       	ror	r23
    2f9c:	67 95       	ror	r22
    2f9e:	b7 95       	ror	r27
    2fa0:	08 f4       	brcc	.+2      	; 0x2fa4 <ldexp+0x4e>
    2fa2:	b1 60       	ori	r27, 0x01	; 1
    2fa4:	93 95       	inc	r25
    2fa6:	c1 f7       	brne	.-16     	; 0x2f98 <ldexp+0x42>
    2fa8:	bb 0f       	add	r27, r27
    2faa:	58 f7       	brcc	.-42     	; 0x2f82 <ldexp+0x2c>
    2fac:	11 f4       	brne	.+4      	; 0x2fb2 <ldexp+0x5c>
    2fae:	60 ff       	sbrs	r22, 0
    2fb0:	e8 cf       	rjmp	.-48     	; 0x2f82 <ldexp+0x2c>
    2fb2:	6f 5f       	subi	r22, 0xFF	; 255
    2fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb6:	8f 4f       	sbci	r24, 0xFF	; 255
    2fb8:	9f 4f       	sbci	r25, 0xFF	; 255
    2fba:	e3 cf       	rjmp	.-58     	; 0x2f82 <ldexp+0x2c>
    2fbc:	b8 ce       	rjmp	.-656    	; 0x2d2e <__fp_szero>
    2fbe:	0e f0       	brts	.+2      	; 0x2fc2 <ldexp+0x6c>
    2fc0:	76 c0       	rjmp	.+236    	; 0x30ae <__fp_mpack>
    2fc2:	70 ce       	rjmp	.-800    	; 0x2ca4 <__fp_nan>
    2fc4:	68 94       	set
    2fc6:	68 ce       	rjmp	.-816    	; 0x2c98 <__fp_inf>

00002fc8 <log>:
    2fc8:	97 de       	rcall	.-722    	; 0x2cf8 <__fp_splitA>
    2fca:	c8 f3       	brcs	.-14     	; 0x2fbe <ldexp+0x68>
    2fcc:	99 23       	and	r25, r25
    2fce:	d1 f3       	breq	.-12     	; 0x2fc4 <ldexp+0x6e>
    2fd0:	c6 f3       	brts	.-16     	; 0x2fc2 <ldexp+0x6c>
    2fd2:	df 93       	push	r29
    2fd4:	cf 93       	push	r28
    2fd6:	1f 93       	push	r17
    2fd8:	0f 93       	push	r16
    2fda:	ff 92       	push	r15
    2fdc:	c9 2f       	mov	r28, r25
    2fde:	dd 27       	eor	r29, r29
    2fe0:	88 23       	and	r24, r24
    2fe2:	2a f0       	brmi	.+10     	; 0x2fee <log+0x26>
    2fe4:	21 97       	sbiw	r28, 0x01	; 1
    2fe6:	66 0f       	add	r22, r22
    2fe8:	77 1f       	adc	r23, r23
    2fea:	88 1f       	adc	r24, r24
    2fec:	da f7       	brpl	.-10     	; 0x2fe4 <log+0x1c>
    2fee:	20 e0       	ldi	r18, 0x00	; 0
    2ff0:	30 e0       	ldi	r19, 0x00	; 0
    2ff2:	40 e8       	ldi	r20, 0x80	; 128
    2ff4:	5f eb       	ldi	r21, 0xBF	; 191
    2ff6:	9f e3       	ldi	r25, 0x3F	; 63
    2ff8:	88 39       	cpi	r24, 0x98	; 152
    2ffa:	20 f0       	brcs	.+8      	; 0x3004 <log+0x3c>
    2ffc:	80 3e       	cpi	r24, 0xE0	; 224
    2ffe:	30 f0       	brcs	.+12     	; 0x300c <log+0x44>
    3000:	21 96       	adiw	r28, 0x01	; 1
    3002:	8f 77       	andi	r24, 0x7F	; 127
    3004:	0f dd       	rcall	.-1506   	; 0x2a24 <__addsf3>
    3006:	ec e0       	ldi	r30, 0x0C	; 12
    3008:	f1 e0       	ldi	r31, 0x01	; 1
    300a:	03 c0       	rjmp	.+6      	; 0x3012 <log+0x4a>
    300c:	0b dd       	rcall	.-1514   	; 0x2a24 <__addsf3>
    300e:	e9 e3       	ldi	r30, 0x39	; 57
    3010:	f1 e0       	ldi	r31, 0x01	; 1
    3012:	73 df       	rcall	.-282    	; 0x2efa <__fp_powser>
    3014:	8b 01       	movw	r16, r22
    3016:	be 01       	movw	r22, r28
    3018:	ec 01       	movw	r28, r24
    301a:	fb 2e       	mov	r15, r27
    301c:	6f 57       	subi	r22, 0x7F	; 127
    301e:	71 09       	sbc	r23, r1
    3020:	75 95       	asr	r23
    3022:	77 1f       	adc	r23, r23
    3024:	88 0b       	sbc	r24, r24
    3026:	99 0b       	sbc	r25, r25
    3028:	fc dd       	rcall	.-1032   	; 0x2c22 <__floatsisf>
    302a:	28 e1       	ldi	r18, 0x18	; 24
    302c:	32 e7       	ldi	r19, 0x72	; 114
    302e:	41 e3       	ldi	r20, 0x31	; 49
    3030:	5f e3       	ldi	r21, 0x3F	; 63
    3032:	8f de       	rcall	.-738    	; 0x2d52 <__mulsf3x>
    3034:	af 2d       	mov	r26, r15
    3036:	98 01       	movw	r18, r16
    3038:	ae 01       	movw	r20, r28
    303a:	ff 90       	pop	r15
    303c:	0f 91       	pop	r16
    303e:	1f 91       	pop	r17
    3040:	cf 91       	pop	r28
    3042:	df 91       	pop	r29
    3044:	00 dd       	rcall	.-1536   	; 0x2a46 <__addsf3x>
    3046:	3f ce       	rjmp	.-898    	; 0x2cc6 <__fp_round>

00003048 <modf>:
    3048:	fa 01       	movw	r30, r20
    304a:	dc 01       	movw	r26, r24
    304c:	aa 0f       	add	r26, r26
    304e:	bb 1f       	adc	r27, r27
    3050:	9b 01       	movw	r18, r22
    3052:	ac 01       	movw	r20, r24
    3054:	bf 57       	subi	r27, 0x7F	; 127
    3056:	28 f4       	brcc	.+10     	; 0x3062 <modf+0x1a>
    3058:	22 27       	eor	r18, r18
    305a:	33 27       	eor	r19, r19
    305c:	44 27       	eor	r20, r20
    305e:	50 78       	andi	r21, 0x80	; 128
    3060:	1f c0       	rjmp	.+62     	; 0x30a0 <modf+0x58>
    3062:	b7 51       	subi	r27, 0x17	; 23
    3064:	88 f4       	brcc	.+34     	; 0x3088 <modf+0x40>
    3066:	ab 2f       	mov	r26, r27
    3068:	00 24       	eor	r0, r0
    306a:	46 95       	lsr	r20
    306c:	37 95       	ror	r19
    306e:	27 95       	ror	r18
    3070:	01 1c       	adc	r0, r1
    3072:	a3 95       	inc	r26
    3074:	d2 f3       	brmi	.-12     	; 0x306a <modf+0x22>
    3076:	00 20       	and	r0, r0
    3078:	69 f0       	breq	.+26     	; 0x3094 <modf+0x4c>
    307a:	22 0f       	add	r18, r18
    307c:	33 1f       	adc	r19, r19
    307e:	44 1f       	adc	r20, r20
    3080:	b3 95       	inc	r27
    3082:	da f3       	brmi	.-10     	; 0x307a <modf+0x32>
    3084:	0d d0       	rcall	.+26     	; 0x30a0 <modf+0x58>
    3086:	cd cc       	rjmp	.-1638   	; 0x2a22 <__subsf3>
    3088:	61 30       	cpi	r22, 0x01	; 1
    308a:	71 05       	cpc	r23, r1
    308c:	a0 e8       	ldi	r26, 0x80	; 128
    308e:	8a 07       	cpc	r24, r26
    3090:	b9 46       	sbci	r27, 0x69	; 105
    3092:	30 f4       	brcc	.+12     	; 0x30a0 <modf+0x58>
    3094:	9b 01       	movw	r18, r22
    3096:	ac 01       	movw	r20, r24
    3098:	66 27       	eor	r22, r22
    309a:	77 27       	eor	r23, r23
    309c:	88 27       	eor	r24, r24
    309e:	90 78       	andi	r25, 0x80	; 128
    30a0:	30 96       	adiw	r30, 0x00	; 0
    30a2:	21 f0       	breq	.+8      	; 0x30ac <modf+0x64>
    30a4:	20 83       	st	Z, r18
    30a6:	31 83       	std	Z+1, r19	; 0x01
    30a8:	42 83       	std	Z+2, r20	; 0x02
    30aa:	53 83       	std	Z+3, r21	; 0x03
    30ac:	08 95       	ret

000030ae <__fp_mpack>:
    30ae:	9f 3f       	cpi	r25, 0xFF	; 255
    30b0:	31 f0       	breq	.+12     	; 0x30be <__fp_mpack_finite+0xc>

000030b2 <__fp_mpack_finite>:
    30b2:	91 50       	subi	r25, 0x01	; 1
    30b4:	20 f4       	brcc	.+8      	; 0x30be <__fp_mpack_finite+0xc>
    30b6:	87 95       	ror	r24
    30b8:	77 95       	ror	r23
    30ba:	67 95       	ror	r22
    30bc:	b7 95       	ror	r27
    30be:	88 0f       	add	r24, r24
    30c0:	91 1d       	adc	r25, r1
    30c2:	96 95       	lsr	r25
    30c4:	87 95       	ror	r24
    30c6:	97 f9       	bld	r25, 7
    30c8:	08 95       	ret

000030ca <__udivmodhi4>:
    30ca:	aa 1b       	sub	r26, r26
    30cc:	bb 1b       	sub	r27, r27
    30ce:	51 e1       	ldi	r21, 0x11	; 17
    30d0:	07 c0       	rjmp	.+14     	; 0x30e0 <__udivmodhi4_ep>

000030d2 <__udivmodhi4_loop>:
    30d2:	aa 1f       	adc	r26, r26
    30d4:	bb 1f       	adc	r27, r27
    30d6:	a6 17       	cp	r26, r22
    30d8:	b7 07       	cpc	r27, r23
    30da:	10 f0       	brcs	.+4      	; 0x30e0 <__udivmodhi4_ep>
    30dc:	a6 1b       	sub	r26, r22
    30de:	b7 0b       	sbc	r27, r23

000030e0 <__udivmodhi4_ep>:
    30e0:	88 1f       	adc	r24, r24
    30e2:	99 1f       	adc	r25, r25
    30e4:	5a 95       	dec	r21
    30e6:	a9 f7       	brne	.-22     	; 0x30d2 <__udivmodhi4_loop>
    30e8:	80 95       	com	r24
    30ea:	90 95       	com	r25
    30ec:	bc 01       	movw	r22, r24
    30ee:	cd 01       	movw	r24, r26
    30f0:	08 95       	ret

000030f2 <__divmodhi4>:
    30f2:	97 fb       	bst	r25, 7
    30f4:	09 2e       	mov	r0, r25
    30f6:	07 26       	eor	r0, r23
    30f8:	0a d0       	rcall	.+20     	; 0x310e <__divmodhi4_neg1>
    30fa:	77 fd       	sbrc	r23, 7
    30fc:	04 d0       	rcall	.+8      	; 0x3106 <__divmodhi4_neg2>
    30fe:	e5 df       	rcall	.-54     	; 0x30ca <__udivmodhi4>
    3100:	06 d0       	rcall	.+12     	; 0x310e <__divmodhi4_neg1>
    3102:	00 20       	and	r0, r0
    3104:	1a f4       	brpl	.+6      	; 0x310c <__divmodhi4_exit>

00003106 <__divmodhi4_neg2>:
    3106:	70 95       	com	r23
    3108:	61 95       	neg	r22
    310a:	7f 4f       	sbci	r23, 0xFF	; 255

0000310c <__divmodhi4_exit>:
    310c:	08 95       	ret

0000310e <__divmodhi4_neg1>:
    310e:	f6 f7       	brtc	.-4      	; 0x310c <__divmodhi4_exit>
    3110:	90 95       	com	r25
    3112:	81 95       	neg	r24
    3114:	9f 4f       	sbci	r25, 0xFF	; 255
    3116:	08 95       	ret

00003118 <_exit>:
    3118:	f8 94       	cli

0000311a <__stop_program>:
    311a:	ff cf       	rjmp	.-2      	; 0x311a <__stop_program>
